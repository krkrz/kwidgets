//
// $Id: KGridLayout.tjs,v 1.10 2007/09/17 21:05:14 cvs Exp $
//


/*----------------------------------------------------------------------
 * グリッドレイアウト
 ----------------------------------------------------------------------*/
global.KGridLayoutWidgetStyle =
	[
		[ "drawBordersAroundIndividualWidgets", "drawBordersAroundIndividualWidgets", false ]
	];


class KGridLayout extends KLayout
{
	// X方向の要素数, Y方向の要素数
	var xcount, ycount;
	// アイテム、逆引き
	var items, revItems;
	// 行/列ごとの最大、最小サイズ
	var minWidthForColumn;
	var maxWidthForColumn;
	var minHeightForRow;
	var maxHeightForRow;
	var widthForColumn;
	var heightForRow;
	var logicalMaxWidth, logicalMaxHeight;
	var ignoreHiddenChild = true;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param win ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KGridLayout(win, opts = %[]) {
		// 親呼び出し
		super.KLayout(win, opts);

		// 最初は要素0から。
		xcount = ycount = 0;
		items = %[];
		revItems = %[];
		ignoreHiddenChild = getOption("ignoreHiddenChild", true);
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KGridLayoutWidgetStyle);
		}
	}

	// 特定のポジションをあらわす文字列を返す
	function posExp(x, y) {
		return "" + x + ":" + y;
	}

	// 特定のポジションにある子ウィジェットを返す
	function childAt(x, y) {
		return items[posExp(x, y)];
	}

	// 子ウィジェットに対応した位置を返す
	function posAt(child) {
		return revItems[child];
	}

	/*------------------------------
	 * 子ウィジェットを特定のグリッドに配置する
	 *
	 * @param x グリッドX座標(0〜)
	 * @param y グリッドY座標(0〜)
	 * @param child 子ウィジェット
	 * @param colspan カラム結合
	 * @param rowspan ロウ結合
	 ------------------------------*/
	function add(x, y, child, colspan = 1, rowspan = 1) {
		xcount = Math.max(x + colspan, xcount);
		ycount = Math.max(y + rowspan, ycount);
		items[posExp(x, y)] = child;
		revItems[child] = [ x, y, colspan, rowspan ];
		child.parent = this;
		redrawContents();
	}

	/*------------------------------
	 * 子ウィジェットを取り除く
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var pos = revItems[child];
		delete items[posExp(pos[0], pos[1])];
		delete revItems[child];
		child.parent = widgetDepot;
		xcount = 0;
		ycount = 0;
		eachDictionary(revItems, function(key, value) {
			xcount = Math.max(value[0] + value[2], xcount);
			ycount = Math.max(value[1] + value[3], ycount);
		} incontextof(this));

		redrawContents();

		if (doInvalidate)
			invalidate child;
	}

	/*------------------------------
	 * 子ウィジェットを全て取り除く
	 *
	 * @param doInvalidate 取り除いた子ウィジェットを無効化するか
	 ------------------------------*/
	function removeAll(doInvalidate = true)
	{
		if(doInvalidate)
			eachDictionary(items, function(key, value) { invalidate value; } incontextof(this));
		else
			eachDictionary(items, function(key, value) { value.parent = widgetDepot; } incontextof(this));
		(Dictionary.clear incontextof items)();
		(Dictionary.clear incontextof revItems)();
		xcount = 0;
		ycount = 0;
		redrawContents();
	}

	/*------------------------------
	 * アクティブなスペースをカウントする
	 ------------------------------*/
	function isActiveSpaceHorizontal(x) {
		return x < xcount - 1 && maxWidthForColumn[x] != 0;
	}

	function isActiveSpaceVertical(y) {
		return y < ycount - 1 && maxHeightForRow[y] != 0;
	}

	/*------------------------------
	 * レイアウトを計算する
	 ------------------------------*/
	function onCalculateLayout {
		// グリッドの行・列ごとに最大幅、最小幅を計算する。
		minWidthForColumn = [];
		maxWidthForColumn = [];
		minHeightForRow = [];
		maxHeightForRow = [];

		for (var x = 0; x < xcount; x++)
			for (var y = 0; y < ycount; y++) {
				var child = childAt(x, y);
				if (child === void
					|| ! child.visible)
					continue;
				var revItem, colspan, rowspan;
				revItem = revItems[child], colspan = revItem[2], rowspan = revItem[3];
				var cb;
				if (widgetStyle.drawBordersAroundIndividualWidgets)
					cb = getChildBoundsWithoutPadding(child);
				else
					cb = getChildBoundsWithoutBorderPadding(child);
				if (colspan == 1) {
					minWidthForColumn[x] = Math.max(minWidthForColumn[x], cb.minWidth);
					maxWidthForColumn[x] = Math.max(maxWidthForColumn[x], cb.maxWidth);
				}
				if (rowspan == 1) {
					minHeightForRow[y] =   Math.max(minHeightForRow[y], cb.minHeight);
					maxHeightForRow[y] =   Math.max(maxHeightForRow[y], cb.maxHeight);
				}
			}

		for (var x = 0; x < xcount; x++)
			for (var y = 0; y < ycount; y++) {
				var child = childAt(x, y);
				if (child === void
					|| ! child.visible)
					continue;
				var revItem, colspan, rowspan;
				revItem = revItems[child], colspan = revItem[2], rowspan = revItem[3];
				if (colspan > 1) {
					var cb;
					if (widgetStyle.drawBordersAroundIndividualWidgets)
						cb = getChildBoundsWithoutPadding(child);
					else
						cb = getChildBoundsWithoutBorderPadding(child);
					var minW, maxW, w;
					minW = Math.max(0, cb.minWidth - spaceHorizontal * (colspan - 1));
					w = 0; for (var i = 0; i < colspan; i++) w += minWidthForColumn[x + i];
					if (w < minW) for (var i = 0; i < colspan; i++) minWidthForColumn[x + i] += int((minW - w) * (i + 1) / colspan) - int((minW - w) * i / colspan);
					maxW = Math.max(0, cb.maxWidth - spaceHorizontal * (colspan - 1));
					w = 0; for (var i = 0; i < colspan; i++) w += maxWidthForColumn[x + i];
					if (w < maxW) for (var i = 0; i < colspan; i++) maxWidthForColumn[x + i] += int((maxW - w) * (i + 1) / colspan) - int((maxW - w) * i / colspan);
				}
				if (rowspan > 1) {
					var cb = getChildBoundsWithoutPadding(child);
					var minH, maxH, h;
					minH = Math.max(0, cb.minHeight - spaceVertical * (rowspan - 1));
					h = 0; for (var i = 0; i < rowspan; i++) h += minHeightForRow[y + i];
					if (h < minH) for (var i = 0; i < rowspan; i++) minHeightForRow[y + i] += int((minH - h) * (i + 1) / rowspan) - int((minH - h) * i / rowspan);
					maxH = Math.max(0, cb.maxHeight - spaceVertical * (rowspan - 1));
					h = 0; for (var i = 0; i < rowspan; i++) h += maxHeightForRow[y + i];
					if (h < maxH) for (var i = 0; i < rowspan; i++) maxHeightForRow[y + i] += int((maxH - h) * (i + 1) / rowspan) - int((maxH - h) * i / rowspan);
				}
			}

		// グリッド全体の最大・最小サイズを決定する
		var minW, minH, maxW, maxH;

		var sumSpaceHorizontal = 0, sumSpaceVertical = 0;

		if (ignoreHiddenChild) {
			for (var i = 0; i < xcount; i++) if (isActiveSpaceHorizontal(i)) sumSpaceHorizontal += spaceHorizontal;
			for (var i = 0; i < ycount; i++) if (isActiveSpaceVertical(i))   sumSpaceVertical += spaceVertical;
		} else {
			sumSpaceHorizontal = (xcount - 1) * spaceHorizontal;
			sumSpaceVertical = (ycount - 1) * spaceVertical;
		}

		var wofst = widgetStyle.drawBordersAroundIndividualWidgets ? layoutStyle.paddingLeft + layoutStyle.paddingRight : borderPaddingWidth;
		minW = maxW = sumSpaceHorizontal + wofst;
		for (var x = 0; x < xcount; x++) {
			minW += minWidthForColumn[x];
			maxW += maxWidthForColumn[x];
		}

		var hofst = widgetStyle.drawBordersAroundIndividualWidgets ? layoutStyle.paddingTop + layoutStyle.paddingBottom : borderPaddingHeight;
		minH = maxH = sumSpaceVertical + hofst;
		for (var y = 0; y < ycount; y++) {
			minH += minHeightForRow[y];
			maxH += maxHeightForRow[y];
		}

		// 最大・最小サイズを決定する
		logicalMaxWidth = maxW;
		logicalMaxHeight = maxH;
		setMinMaxSize(minW, minH, maxW, maxH);
	}

	/*------------------------------
	 * レイアウトに従ってウィジェットを配置する
	 ------------------------------*/
	function onLocateLayout {
		if (widgetStyle.drawBordersAroundIndividualWidgets)
			fillRect(0, 0, width, height, borderStyle.backgroundColor);
		else
			drawBorder(borderStyle, 0, 0, width, height);

		// 行、列ごとのサイズを決定する
		widthForColumn = [];
		heightForRow = [];

		// 大まかに、minとmaxの比率から幅・高さを決定する
		var minWidthRatio, maxWidthRatio, minHeightRatio, maxHeightRatio;

		minWidthRatio = (logicalMaxWidth - width);
		maxWidthRatio = (width - minWidth);

		for (var x = 0; x < xcount; x++) {
			if (logicalMaxWidth == minWidth)
				widthForColumn[x] = minWidthForColumn[x];
			else
				widthForColumn[x] =
				((minWidthForColumn[x] * minWidthRatio
				  + maxWidthForColumn[x] * maxWidthRatio)
				 / (logicalMaxWidth - minWidth));
		}

		minHeightRatio = (logicalMaxHeight - height);
		maxHeightRatio = (height - minHeight);

		for (var y = 0; y < ycount; y++) {
			if (logicalMaxHeight == minHeight)
				heightForRow[y] = minHeightForRow[y];
			else
				heightForRow[y] =
				((minHeightForRow[y] * minHeightRatio
				  + maxHeightForRow[y] * maxHeightRatio)
				 / (logicalMaxHeight - minHeight));
		}

		var xpos, ypos;
		xpos = widgetStyle.drawBordersAroundIndividualWidgets ? layoutStyle.paddingLeft : borderPaddingLeft;

		var d = 0;
		for (var i = 0; i < widthForColumn.count; i++) {
			var v = int(widthForColumn[i] + d + 0.5);
			d += widthForColumn[i] - v;
			widthForColumn[i] = v;
		}
		for (var i = 0; i < heightForRow.count; i++) {
			var v = int(heightForRow[i] + d + 0.5);
			d += heightForRow[i] - v;
			heightForRow[i] = v;
		}

		for (var x = 0; x < xcount; x++) {
			ypos = widgetStyle.drawBordersAroundIndividualWidgets ? layoutStyle.paddingTop : borderPaddingTop;
			for (var y = 0; y < ycount; y++) {
				var child = childAt(x, y);
				if (child !== void
					&& child.visible) {
					var revItem, colspan, rowspan;
					revItem = revItems[child], colspan = revItem[2], rowspan = revItem[3];
					var w, h;
					w = spaceHorizontal * (colspan - 1);
					h = spaceVertical * (rowspan - 1);
					for (var i = 0; i < colspan; i++)
						w += widthForColumn[x + i];
					for (var i = 0; i < rowspan; i++)
						h += heightForRow[y + i];
					if (widgetStyle.drawBordersAroundIndividualWidgets)
						embedChildWithoutPadding(xpos, ypos, w, h, child);
					else
						embedChildWithoutBorderPadding(xpos, ypos, w, h, child);
				}
				ypos += heightForRow[y] + ((! ignoreHiddenChild || isActiveSpaceVertical(y)) ? spaceVertical : 0);
			}
			xpos += widthForColumn[x] + ((! ignoreHiddenChild || isActiveSpaceHorizontal(x)) ? spaceHorizontal : 0);
		}
	}
};

/**----------------------------------------------------------------------
 * 横方向 レイアウト
 ----------------------------------------------------------------------*/
class KHorizontalBarLayout extends KGridLayout
{
	/**------------------------------
	 * 横方向にウィジェットを一直線に並べるレイアウトです。
	 *
	 * @param win ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KHorizontalBarLayout(win, name = "") {
		super.KGridLayout(...);
	}

	/*------------------------------
	 * ウィジェットを追加します
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		super.add(xcount, 0, child);
	}

	/*-----------------------------
	 * ウィジェットを取り除きます
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var pos = revItems[child];
		var prevItems = items;
		items = %[];
		eachDictionary(revItems, function(key, value, pos, prevItems) {
			var item = prevItems[posExp(value[0], value[1])];
			if (value[0] > pos[0])
				value[0] --;
			items[posExp(value[0], value[1])] = item;
		} incontextof(this), pos, prevItems);
		super.remove(child, doInvalidate);
	}
}


/**----------------------------------------------------------------------
 * 縦方向 レイアウト
 ----------------------------------------------------------------------*/
class KVerticalBarLayout extends KGridLayout
{
	/**------------------------------
	 * 縦方向にウィジェットを一直線に並べるレイアウトです。
	 *
	 * @param win ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KVerticalBarLayout(win, name = "") {
		super.KGridLayout(...);
	}

	/*------------------------------
	 * ウィジェットを追加します
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		super.add(0, ycount, child);
	}

	/*-----------------------------
	 * ウィジェットを取り除きます
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var pos = revItems[child];
		var prevItems = items;
		var items = %[];
		eachDictionary(revItems, function(key, value, pos, prevItems) {
			var item = prevItems[posExp(value[0], value[1])];
			if (value[1] > pos[1])
				value[1] --;
			items[posExp(value[0], value[1])] = item;
		} incontextof(this), pos, prevItems);
		super.remove(child, doInvalidate);
	}
}




/**----------------------------------------------------------------------
 * 横方向 レイアウト
 ----------------------------------------------------------------------*/
class KHorizontalBarLayout extends KGridLayout
{
	/**------------------------------
	 * 横方向にウィジェットを一直線に並べるレイアウトです。
	 *
	 * @param win ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KHorizontalBarLayout(win, name = "") {
		super.KGridLayout(...);
	}

	/*------------------------------
	 * ウィジェットを追加します
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		super.add(xcount, 0, child);
	}

	/*-----------------------------
	 * ウィジェットを取り除きます
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var pos = revItems[child];
		var prevItems = items;
		items = %[];
		eachDictionary(revItems, function(key, value, pos, prevItems) {
			var item = prevItems[posExp(value[0], value[1])];
			if (value[0] > pos[0])
				value[0] --;
			items[posExp(value[0], value[1])] = item;
		} incontextof(this), pos, prevItems);
		super.remove(child, doInvalidate);
	}
}


/**----------------------------------------------------------------------
 * 縦方向 レイアウト
 ----------------------------------------------------------------------*/
class KVerticalBarLayout extends KGridLayout
{
	/**------------------------------
	 * 縦方向にウィジェットを一直線に並べるレイアウトです。
	 *
	 * @param win ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KVerticalBarLayout(win, name = "") {
		super.KGridLayout(...);
	}

	/*------------------------------
	 * ウィジェットを追加します
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		super.add(0, ycount, child);
	}

	/*-----------------------------
	 * ウィジェットを取り除きます
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var pos = revItems[child];
		var prevItems = items;
		var items = %[];
		eachDictionary(revItems, function(key, value, pos, prevItems) {
			var item = prevItems[posExp(value[0], value[1])];
			if (value[1] > pos[1])
				value[1] --;
			items[posExp(value[0], value[1])] = item;
		} incontextof(this), pos, prevItems);
		super.remove(child, doInvalidate);
	}
}


