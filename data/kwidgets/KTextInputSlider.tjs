/**----------------------------------------------------------------------
 * テキストインプットスライダー
 ----------------------------------------------------------------------*/
global.KTextInputSliderArgsFormat =
	[
			%[ key: "width", defaultValue: SLIDER_ADAPTIVE_WIDTH ],
			%[ key: "height" ],
			%[ key: "left" ],
			%[ key: "right" ],
			%[ key: "stride", defaultValue: 1 ],
			%[ key: "name", defaultValue: "" ]
	];

global.KTextInputSliderWidgetStyleDefinition =
	[
		[ "textInputId", "textinputId" ],
		[ "sliderId", "sliderId" ],
		[ "width", "width" ],
		[ "height", "height" ],
		[ "placeTextOnRightsideOfSlider", "placeTextOnRightsideOfSlider", false ],
		[ "variable", "variable", false ],
		[ "focusOnSliderClick", true ]
	];

class KTextInputSliderEmbededSlider extends KSlider
{
	function KTextInputSliderEmbededSlider() {
		super.KSlider(...);
	}

	function focus() {
		if (parent.getOption("focusOnSliderClick", true))
			parent.textInput.focus();
	}
}

class KTextInputSlider extends KValueEntity
{
	var _value;
	var textInput;
	var slider;
	// 辞書
	var dict;

	/*------------------------------
	 * テキストインプットとスライダーを合成したウィジェットです。
	 *
	 * @param win ウィンドウ
	 * @param w 幅
	 * @param h 高さ
	 * @param minValue 値の最小値
	 * @param maxValue 値の最大値
	 * @param name 名前
	 * @param step 刻み幅
	 ------------------------------*/
	function KTextInputSlider(window, *) {
		var options = parseOldStyleWidgetArgs(KTextInputSliderArgsFormat, *);

		super.KValueEntity(window, options);

		earlyUpdateWidgetStyle();

		hasImage = false;

		var w = getOption("width", SLIDER_ADAPTIVE_WIDTH);
		var h = getOption("height", 20);
		var stride = getOption("stride");
		var left = getOption("left");
		var right = getOption("right");
		var v = getOption("value", left);

		textInput = new KTextInput(window, %[ name: "_textInput",
											  id: widgetStyle.textInputId,
											  lockStyleMoficationOnAttach: true,
											  width: h * 2,
											  height: h,
											  type: stride == int(stride) ? TEXT_DIGIT : TEXT_REAL,
											  hint: getOption("hint", ""),
											  value: string(v) ]);
		slider = new KTextInputSliderEmbededSlider(window, %[ name: "_slider",
															  id: widgetStyle.sliderId,
															  lockStyleMoficationOnAttach: true,
															  width: w,
															  height: h,
															  left: left,
															  right: right,
															  stride: stride,
															  focusable: false,
															  value: v,
															  hint: getOption("hint", ""),
															  leftIcon: getOption("leftIcon", ""),
															  leftIconHint: getOption("leftIconHint", ""),
															  rightIcon: getOption("rightIcon", ""),
															  rightIconHint: getOption("rightIconHint", ""),
															  interpolation: getOption("interpolation", false)
															]);
		slider.onStartInterpolation = _onStartInterpolation;
		slider.onStopInterpolation = _onStopInterpolation;

		textInput.parent = this;
		slider.parent = this;

		_value = v;
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KTextInputSliderWidgetStyleDefinition);
		}
	}

	/**------------------------------
	 * 値を設定する
	 *
	 * @param v 値
	 * @return 値
	 ------------------------------*/
	property value {
		getter {
			return _value;
		}
		setter(v) {
			slider.value = v;
			_value = slider.value;
			textInput.value = string(_value);
		}
	}

	property completedValue {
		getter {
			return slider.completedValue;
		}
	}

	function interpolate(value) {
		slider.interpolate(value);
	}

	function complete {
		slider.complete();
	}

	function _onStartInterpolation() {
		onStartInterpolation();
	}

	function _onStopInterpolation() {
		onStopInterpolation();
	}

	function onStartInterpolation() {
	}

	function onStopInterpolation() {
	}

	/**------------------------------
	 * 子の値変更を受けて値を同期
	 ------------------------------*/
	function onChildValueModified(child, newValue) {
		value = newValue;
		invalidateValue();
	}

	/**------------------------------
	 * 描画
	 ------------------------------*/
	function onDrawContents() {
		textInput.lockStyleModification();
		slider.lockStyleModification();

		textInput.id = widgetStyle.textInputId;
		slider.id = widgetStyle.sliderId;

		var w = widgetStyle.width !== void ? widgetStyle.width : getOption("width", SLIDER_ADAPTIVE_WIDTH);
		var h = widgetStyle.height !== void ? widgetStyle.height : getOption("height", void);
		if (h === void) {
			textInput.unlockStyleModification();
			h = textInput.height;
		}

		var fontHeight = textInput.fontStyle.fontHeight;

		textInput.overwriteStyle(%[ width: fontHeight * 3, height: h ]);
		if (w == SLIDER_ADAPTIVE_WIDTH) {
			slider.overwriteStyle(%[ width: w, height: h ]);
			slider.unlockStyleModification();
			w = slider.minWidth + spaceHorizontal + textInput.width;
		}
		slider.overwriteStyle(%[ width: w - spaceHorizontal - textInput.width, height: h, variable: widgetStyle.variable ]);

		textInput.unlockStyleModification();
		slider.unlockStyleModification();

		if (! widgetStyle.variable) 
			setFixedSize(w + slider.innerMargin.width, h);
		else {
			setMinMaxSize(w + slider.innerMargin.width, h, K_WIDGET_MAX_POSSIBLE_WIDTH, h);
			slider.setSize(width - textInput.width - spaceHorizontal, slider.height);
		}

		if (! widgetStyle.placeTextOnRightsideOfSlider) {
			textInput.setPos(0, (h - textInput.height) / 2);
			slider.setPos(textInput.width + spaceHorizontal, (h - slider.height) / 2);
		} else {
			textInput.setPos(slider.width + spaceHorizontal, (h - textInput.height) / 2);
			slider.setPos(0, (h - slider.height) / 2);
		}

	}

	/*------------------------------
	 * レガシー
	 ------------------------------*/
	property leftValue {
		getter {
			return slider.leftValue;
		}
	}

	property rightValue {
		getter {
			return slider.rightValue;
		}
	}

	property minValue {
		getter {
			return slider.minValue;
		}
	}

	property maxValue {
		getter {
			return slider.maxValue;
		}
	}

	property step {
		getter {
			return slider.step;
		}
	}

	function updateRange {
		slider.updateRange(...);
	}

};
