/**----------------------------------------------------------------------
 * テキストインプットスライダー
 ----------------------------------------------------------------------*/
global.KTextInputSliderArgsFormat =
	[
			%[ key: "width", defaultValue: SLIDER_ADAPTIVE_WIDTH ],
			%[ key: "height" ],
			%[ key: "left" ],
			%[ key: "right" ],
			%[ key: "stride", defaultValue: 1 ],
			%[ key: "name", defaultValue: "" ]
	];

global.KTextInputSliderWidgetStyleDefinition =
	[
		[ "textInputId", "textinputId" ],
		[ "sliderId", "sliderId" ],
		[ "width", "width" ],
		[ "height", "height" ],
		[ "placeTextOnRightsideOfSlider", "placeTextOnRightsideOfSlider", false ],
		[ "variable", "variable", false ],
		[ "focusOnSliderClick", "focusOnSliderClick", true ],
		[ "unitLabelId", "unitLabelId" ]
	];

class KTextInputSlider extends KValueEntity
{
	var _value;
	var textInput;
	var slider;
	var unitLabel;
	// 辞書
	var dict;

	/*------------------------------
	 * テキストインプットとスライダーを合成したウィジェットです。
	 *
	 * @param win ウィンドウ
	 * @param w 幅
	 * @param h 高さ
	 * @param minValue 値の最小値
	 * @param maxValue 値の最大値
	 * @param name 名前
	 * @param step 刻み幅
	 ------------------------------*/
	function KTextInputSlider(window, *) {
		var options = parseOldStyleWidgetArgs(KTextInputSliderArgsFormat, *);

		super.KValueEntity(window, options);

		earlyUpdateWidgetStyle();

		hasImage = false;

		var w = getOption("width", SLIDER_ADAPTIVE_WIDTH);
		var h = getOption("height", 20);
		var stride = getOption("stride");
		var left = getOption("left");
		var right = getOption("right");
		var v = getOption("value", left);

		textInput = new KTextInput(window, %[ name: "_textInput",
											  id: widgetStyle.textInputId,
											  lockStyleMoficationOnAttach: true,
											  width: h * 2,
											  height: h,
											  type: stride == int(stride) ? TEXT_DIGIT : TEXT_REAL,
											  hint: getOption("hint", ""),
											  value: string(v) ]);
		var sliderClass = getOption("sliderClass", "KSlider");
		slider = new global[sliderClass](window, %[ name: "_slider",
													id: widgetStyle.sliderId,
													lockStyleMoficationOnAttach: true,
													width: w,
													height: h,
													left: left,
													right: right,
													stride: stride,
													focusable: false,
													value: v,
													hint: getOption("hint", ""),
													leftIcon: getOption("leftIcon", ""),
													leftIconHint: getOption("leftIconHint", ""),
													rightIcon: getOption("rightIcon", ""),
													rightIconHint: getOption("rightIconHint", ""),
													interpolation: getOption("interpolation", false)
												  ]);
		slider.focus = onSliderFocus;
		slider.onStartInterpolation = _onStartInterpolation;
		slider.onStopInterpolation = _onStopInterpolation;

		textInput.parent = this;
		slider.parent = this;

		var unitLabelText = getOption("unitLabel", "");
		if (unitLabelText != "") {
			unitLabel = new KTextLabel(window, %[ name, "_unitLabel",
												  id: widgetStyle.unitLabelId,
												  label: unitLabelText,
												  hint: getOption("hint", "") ]);
			unitLabel.parent = this;
		}
		_value = v;
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KTextInputSliderWidgetStyleDefinition);
		}
	}

	/**------------------------------
	 * 値を設定する
	 *
	 * @param v 値
	 * @return 値
	 ------------------------------*/
	property value {
		getter {
			return _value;
		}
		setter(v) {
			slider.value = v;
			_value = slider.value;
			textInput.value = string(_value);
		}
	}

	property completedValue {
		getter {
			return slider.completedValue;
		}
	}

	function interpolate(value) {
		slider.interpolate(value);
	}

	function complete {
		slider.complete();
	}

	function _onStartInterpolation() {
		onStartInterpolation();
	}

	function _onStopInterpolation() {
		onStopInterpolation();
	}

	function onStartInterpolation() {
	}

	function onStopInterpolation() {
	}

	function onSliderFocus {
		if (getOption("focusOnSliderClick", true))
			textInput.focus();
	}

	/**------------------------------
	 * 子の値変更を受けて値を同期
	 ------------------------------*/
	function onChildValueModified(child, newValue) {
		value = newValue;
		invalidateValue();
	}

	/**------------------------------
	 * 描画
	 ------------------------------*/
	function onDrawContents() {
		textInput.lockStyleModification();
		slider.lockStyleModification();

		textInput.id = widgetStyle.textInputId;
		slider.id = widgetStyle.sliderId;

		if (unitLabel !== void) {
			unitLabel.id = widgetStyle.unitLabelId;
			unitLabel.setSize(0, 0);
		}

		var w = widgetStyle.width !== void ? widgetStyle.width : getOption("width", SLIDER_ADAPTIVE_WIDTH);
		var h = widgetStyle.height !== void ? widgetStyle.height : getOption("height", void);
		if (h === void) {
			textInput.unlockStyleModification();
			h = textInput.height;
		}

		var fontHeight = textInput.fontStyle.fontHeight;

		textInput.overwriteStyle(%[ width: int(fontHeight * 3.5), height: h ]);
		var textAreaWidth = textInput.width;
		if (unitLabel !== void) 
			textAreaWidth += spaceHorizontal + unitLabel.width;
		if (w == SLIDER_ADAPTIVE_WIDTH) {
			slider.overwriteStyle(%[ width: w, height: h ]);
			slider.unlockStyleModification();
			w = slider.minWidth + spaceHorizontal + textAreaWidth;
		}
		slider.overwriteStyle(%[ width: w - spaceHorizontal - textAreaWidth, height: h, variable: widgetStyle.variable ]);

		textInput.unlockStyleModification();
		slider.unlockStyleModification();

		if (! widgetStyle.variable) 
			setFixedSize(w + slider.innerMargin.width, h);
		else {
			setMinMaxSize(w + slider.innerMargin.width, h, K_WIDGET_MAX_POSSIBLE_WIDTH, h);
			slider.setSize(width - textAreaWidth - spaceHorizontal, slider.height);
		}

		if (! widgetStyle.placeTextOnRightsideOfSlider) {
			textInput.setPos(0, (h - textInput.height) / 2);
			slider.setPos(textAreaWidth + spaceHorizontal, (h - slider.height) / 2);
		} else {
			textInput.setPos(slider.width + spaceHorizontal, (h - textInput.height) / 2);
			slider.setPos(0, (h - slider.height) / 2);
		}
		if (unitLabel !== void) 
			unitLabel.setPos(textInput.left + textInput.width + spaceHorizontal, (h - unitLabel.height) / 2);
	}

	/*------------------------------
	 * レガシー
	 ------------------------------*/
	property leftValue {
		getter {
			return slider.leftValue;
		}
	}

	property rightValue {
		getter {
			return slider.rightValue;
		}
	}

	property minValue {
		getter {
			return slider.minValue;
		}
	}

	property maxValue {
		getter {
			return slider.maxValue;
		}
	}

	property step {
		getter {
			return slider.step;
		}
	}

	function updateRange {
		slider.updateRange(...);
	}

};
