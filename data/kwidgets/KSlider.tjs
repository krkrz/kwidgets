//
// $Id: KSlider.tjs,v 1.5 2007/09/04 19:02:38 cvs Exp $
//

global.SLIDER_ADAPTIVE_WIDTH = 0;
global.SLIDER_SLIDER_WIDTH = 8;
global.SLIDER_FRAME_SIZE = 3;


global.KSliderArgsFormat =
	[
			%[ key: "width", defaultValue: SLIDER_ADAPTIVE_WIDTH ],
			%[ key: "height", defaultValue: 20 ],
			%[ key: "left", defaultValue: 0 ],
			%[ key: "right", defaultValue: 100 ],
			%[ key: "stride", defaultValue: 1 ],
			%[ key: "name", defaultValue: "" ]
	];

global.KSliderWidgetStyleDefinition =
	[
		[ "width", "width", void ],
		[ "height", "height", void ],
		[ "knobWidth", "knobWidth", void ],
		[ "variable", "variable", false ]
	];


class KSlider extends KRangePointer2D
{
	/**------------------------------
	 * コンストラクタ
	 *
	 * スライダーを作成します。
	 * widthに定数SLIDER_ADAPTIVE_WIDTHを指定すると、スライダーは最小値から最大値まで
	 * 全ての値をスライドで指定できるのにじゅうぶんな最小の幅を自動的に計算して指定します。
	 *
	 * @param winndow ウィンドウ
	 * options
	 name 名前
	 width: スライダーの幅
	 height(20): スライダーの高さ
	 left: スライダーの左端の値
	 right: スライダーの右端の値
	 stride: スライダーの刻み幅
	 ------------------------------*/
	var leftIconRange, rightIconRange;
	var leftIconHint, rightIconHint;
	var leftIconName, rightIconName;
	var leftIcon, rightIcon;

	function KSlider(window, *) {
		var opts = parseOldStyleWidgetArgs(KSliderArgsFormat, *);

		opts.hLeft = getOption("left", 0, opts);
		opts.hRight = getOption("right", 100, opts);
		opts.hKnobSize = 0;
		opts.hKnobBlockStride = opts.hKnobStride = getOption("stride", 1, opts);
		opts.hKnobPixelSize = SLIDER_SLIDER_WIDTH;
		opts.hValue = getOption("value", opts.hLeft, opts);
		opts.interpolation = getOption("interpolation", false, opts);

		this.step = opts.hKnobStride;
		this.leftValue = int(opts.hLeft / step);
		this.rightValue = int(opts.hRight / step);
		this.minValue = int(Math.min(this.leftValue, this.rightValue));
		this.maxValue = int(Math.max(this.leftValue, this.rightValue));

		super.KRangePointer2D(window, opts);

		focusable = getOption("focusable", window.defaultFocusable);

		leftIconName = getOption("leftIcon", "");
		leftIconHint = getOption("leftIconHint", "");

		rightIconName = getOption("rightIcon", "");
		rightIconHint = getOption("rightIconHint", "");
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KSliderWidgetStyleDefinition);
		}
	}

	property value {
		getter {
			return pointerValue.h;
		}
		setter(v) {
			pointerValue = %[ h: v, v: 0 ];
		}
	}

	property completedValue {
		getter {
			return _completedValue.h;
		}
	}

	function interpolate(value) {
		var pv = pointerValue;
		pv.h = value;
		super._interpolate(pv);
	}

	property adaptiveWidth {
		getter {
			return maxValue - minValue + knobFixedWidth + 1;
		}
	}

	function updateRange(left, right, stride) {
		updateLogicalRange("h", left, right, 0, stride);
		this.step = hParams.knobLogicalStride;
		this.leftValue = int(left / step);
		this.rightValue = int(right / step);
		this.minValue = int(Math.min(this.leftValue, this.rightValue));
		this.maxValue = int(Math.max(this.leftValue, this.rightValue));
	}

	function onDrawContents() {
		if (widgetStyle.knobWidth !== void)
			knobFixedWidth = widgetStyle.knobWidth;

		leftIcon = leftIconName != "" ? findIcon(leftIconName) : void;
		rightIcon = rightIconName != "" ? findIcon(rightIconName) : void;

		if (leftIcon !== void)
			innerMargin.left = leftIcon.width + spaceHorizontal;
		if (rightIcon !== void) 
			innerMargin.right = rightIcon.width + spaceHorizontal;

		var w = widgetStyle.width ? widgetStyle.width : getOption("width", SLIDER_ADAPTIVE_WIDTH);
		var h = widgetStyle.height ? widgetStyle.height : getOption("height", 20);

		if (w == SLIDER_ADAPTIVE_WIDTH)
			w = adaptiveWidth;

		if (! widgetStyle.variable)
			setFixedSize(w + innerMargin.left + innerMargin.right, h);
		else
			setMinMaxSize(w + innerMargin.left + innerMargin.right, h, K_WIDGET_MAX_POSSIBLE_WIDTH, h);
		fillRect(0, 0, width, height, 0);

		super.onDrawContents();

		if (leftIcon !== void) {
			var y;
			if (innerBg !== void) 
				y = innerBg.top + innerBg.height / 2;
			else
				y = height / 2;
			leftIconRange = new KRect(0, y - leftIcon.height / 2, leftIcon.width, leftIcon.height);
			operateRect(leftIconRange.left, leftIconRange.top, leftIcon, 0, 0, leftIcon.width, leftIcon.height);
		}

		if (rightIcon !== void) {
			var y;
			if (innerBg !== void) 
				y = innerBg.top + innerBg.height / 2;
			else
				y = height / 2;
			rightIconRange = new KRect(width - rightIcon.width, y - rightIcon.height / 2, rightIcon.width, rightIcon.height);
			operateRect(rightIconRange.left, rightIconRange.top, rightIcon, 0, 0, rightIcon.width, rightIcon.height);
		}
	}

	function onMouseMove(x, y, shift) {
		super.onMouseMove(...);
		if (leftIcon !== void
			&& leftIconRange.contains(x, y)
			&& leftIconHint != "")
			hint = leftIconHint;
		else if (rightIcon !== void
				 && rightIconRange.contains(x, y)
				 && rightIconHint != "")
			hint = rightIconHint;
		else
			hint = getOption("hint", "");
	}
}

