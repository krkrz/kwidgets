global.COMBO_STYLE_DROPDOWN = 0;
global.COMBO_STYLE_SIMPLE = 1;			//未対応
global.COMBO_STYLE_DROPDOWNLIST = 2;


global.KComboBoxArgsFormat =
	[
			%[ key: "width" ],
			%[ key: "height" ],
			%[ key: "type", defaultValue: COMBO_STYLE_DROPDOWNLIST ],
			%[ key: "name", defaultValue: "" ]
	];

global.KComboBoxWidgetStyleDefinition =
	[
		[ "dropdownButtonId", "dropdownButtonId" ],
		[ "placeButtonInsideBorder", "placeButtonInsideBorder" ],
		[ "dropdownInterval", "dropdownInterval" ],
		[ "dispCount", "dispCount", 10 ],
		[ "isVariableWidth", "isVariableWidth", false ]
	];

class KComboBox extends KValueEntity
{
	var _selected = -1;
	var _values;
	var _captions;
	var _type;
	var dropdownButton;
	var _primaryHint;
	var _dropdownTimer;
	var _dispCount = 10;
	var _inputValue = void;
	var _textinput;

	function KComboBox(window, *) {
		var options = parseOldStyleWidgetArgs(KComboBoxArgsFormat, *);

		super.KValueEntity(window, options);

		focusable = getOption("focusable", window.defaultFocusable);
		_type = getOption("type", COMBO_STYLE_DROPDOWNLIST);
		_values = getOption("values", []);
		_captions = getOption("captions", []);
		var items = getOption("items", []);
		for (var i = 0; i < items.count; i += 2) {
			_captions.add(items[i    ]);
			_values.add  (items[i + 1]);
		}

		if (_values.count)
			_selected = 0;

		var h = getOption("height");
		dropdownButton = new KImageButton(window, %[ focusable: false, name: "_dropdownButton", style: %[ isVariableWidth: false ] ]);
		dropdownButton.parent = this;

		_dropdownTimer = new Timer(openDropdownList, "");
		_dropdownTimer.enabled = false;
	}

	function finalize {
		invalidate _dropdownTimer;
		super.finalize();
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KComboBoxWidgetStyleDefinition);
		}
	}

	property hint {
		getter {
			return super.hint;
		}
		setter(v) {
			_primaryHint = v;
			redrawContents();
		}
	}

	property count {
		getter {
			return _values.count;
		}
	}

	property empty {
		getter {
			return _values.count == 0;
		}
	}

	property dispCount {
		getter {
			return widgetStyle.dispCount;
		}
		setter(v) {
			overwriteStyle(%[ dispCount: v ]);
		}
	}

	property acceptInputValue {
		getter {
			return _type == COMBO_STYLE_DROPDOWN;
		}
	}

	property selected {
		getter {
			return _selected;
		}
		setter(v) {
			_selected = v;
			_inputValue = void;
			redrawContents();
		}
	}

	property value {
		getter {
			if (_inputValue !== void)
				return _inputValue;
			if (_selected >= 0 && _selected < _values.count)
				return _values[_selected];
			return void;
		}
		setter(v) {
			_inputValue = void;
			_selected = _values.find(v);
			if (_selected < 0
				&& acceptInputValue)
				_inputValue = v;
			redrawContents();
		}
	}

	property values {
		getter {
			return _values;
		}
		setter(v) {
			_values = v;
			redrawContents();
		}
	}

	property caption {
		getter {
			if (_inputValue !== void)
				return _inputValue;
			if (_selected >= 0 && _selected < _captions.count)
				return _captions[_selected];
			return void;
		}
		setter(v) {
			_selected = _captions.find(v);
			redrawContents();
		}
	}

	property captions {
		getter {
			return _captions;
		}
		setter(v) {
			_captions = v;
			redrawContents();
		}
	}

	property items {
		getter {
			var result = [];
		}
	}

	function clear() {
		_values = [];
		_captions = [];
		_selected = -1;
		_inputValue = void;
		redrawContents();
	}
	function add(cap, val) {
		if (_values.count == 0) {
			_inputValue = void;
			_selected = 0;
		}
		_captions.add(cap);
		_values.add(val);
		redrawContents();
	}

	function insert(idx, cap, val) {
		if (_values.count == 0) {
			_inputValue = void;
			_selected = 0;
		}
		_captions.insert(idx, cap);
		_values.insert(idx, val);
		if (_selected >= idx)
			_selected++;
		redrawContents();
	}

	function erase(idx) {
		var v = value;
		_values.erase(idx);
		_captions.erase(idx);
		value = v;
	}

	function addHead(cap, val) {
		insert(0, cap, val);
	}

	function delAt(idx) {
		erase(idx);
	}

	function delByValue(val) {
		var idx = _values.find(val);
		if (idx >= 0)
			erase(idx);
	}

	function delByCaption(cap) {
		var idx = _captions.find(cap);
		if (idx >= 0)
			erase(idx);
	}

	property type {
		getter {
			return _type;
		}
		setter(v) {
			_type = v;
			if (! acceptInputValue)
				_inputValue = void;
			redrawContents();
		}
	}

	property comboStyle {
		getter {
			return type;
		}
		setter(v) {
			type = v;
		}
	}

	function forwardItems() {
		if (empty)
			return;
		updateValue(values[(selected + 1) % count]);
	}

	function backwardItems() {
		if (empty)
			return;
		updateValue(values[(selected - 1 + count) % count]);
	}

	property curFontStyle {
		getter {
			var style = duplicateStruct(fontStyle);
			style.fontHeight = height - borderPaddingHeight;
			return style;
		}
	}

	function validate() {
		if (_values.count != _captions.count)
			throw new Exception("items/captions size mismatch.");
	}

	function onDrawContents() {
		validate();

		_dropdownTimer.interval = widgetStyle.dropdownInterval;

		var w = getOption("width");
		var h = getOption("height", fontStyle.fontHeight + borderPaddingHeight);

		if (! widgetStyle.isVariableWidth)
			setFixedSize(w, h);
		else
			setMinMaxSize(w, h, K_WIDGET_MAX_POSSIBLE_WIDTH, h);

		fillRect(0, 0, width, height, 0);

		dropdownButton.id = widgetStyle.dropdownButtonId;

		if (widgetStyle.placeButtonInsideBorder) {
			var buttonSize = h - borderPaddingHeight;
			dropdownButton.overwriteStyle(%[ width: buttonSize, height: buttonSize]);
			dropdownButton.setPos(width - borderPaddingRight - buttonSize, borderPaddingTop);
			drawBorder(borderStyle, 0, 0, width, height);
		} else {
			var buttonSize = h;
			dropdownButton.overwriteStyle(%[ width: buttonSize, height: buttonSize]);
			dropdownButton.setPos(width - buttonSize, 0);
			drawBorder(borderStyle, 0, 0, width - buttonSize, height);
		}
		var textFieldWidth = width - dropdownButton.width - borderPaddingWidth;
		var text = caption;
		var drawResult =
			drawUITextInRange(curFontStyle, borderPaddingLeft, borderPaddingTop, textFieldWidth, text, ALIGN_LEFT);
		super.hint = drawResult.inRange ? _primaryHint : text;
	}

	function onChildValueModified(child, newValue) {
		switch (child.name) {
		case "_dropdownButton":
			focus();
			openDropdownList();
		}
	}

	function onMouseDown() {
		super.onMouseDown(...);
		focus();
		switch (type) {
		case COMBO_STYLE_DROPDOWN:
			onMouseDownDropdown();
			break;
		case COMBO_STYLE_DROPDOWNLIST:
			onMouseDownDropdownList();
			break;
		}
	}

	function onMouseUp() {
		super.onMouseUp(...);
		focus();
		switch (type) {
		case COMBO_STYLE_DROPDOWN:
			onMouseUpDropdown();
			break;
		case COMBO_STYLE_DROPDOWNLIST:
			onMouseUpDropdownList();
			break;
		}
	}

	function onMouseDownDropdown() {
	}

	function onMouseUpDropdown() {
		openTextInput();
	}

	function onMouseDownDropdownList() {
		_dropdownTimer.enabled = true;
	}

	function onMouseUpDropdownList() {
		if (_dropdownTimer.enabled) {
			_dropdownTimer.enabled = false;
			forwardItems();
		}
	}

	function onKeyDown(key, shift) {
		if (key == VK_UP)
			backwardItems();
		else if (key == VK_DOWN)
			forwardItems();
		else if (key == VK_RETURN)
			openDropdownList();
		else
			super.onKeyDown(...);
	}

	function openDropdownList() {
		closeTextInput();
		_dropdownTimer.enabled = false;
		var dropdown = new KComboDropdownWindow(this);
	}

	function openTextInput() {
		closeTextInput();
		_textinput = new KComboTextInput(this);
	}

	function closeTextInput() {
		if (! (this isvalid))
			return;
		invalidate _textinput;
		_textinput = void;
	}
}

class KComboTextInput extends KTextInput
{
	var owner;

	function KComboTextInput(owner) {
		this.owner = owner;
		var style = %[ borderStyle: BORDER_STYLE_NONE,
					   borderWidth: 0,
					   padding: 0,
					   backgroundColor: owner.borderStyle.backgroundColor ];
		style = unionDictionary(style, owner.curFontStyle);
		super.KTextInput(owner.window, %[ width: owner.width - owner.borderPaddingWidth - owner.dropdownButton.width,
										  height: owner.height - owner.borderPaddingHeight,
										  type: TEXT_ANY,
										  style: style ]);
		value = owner.caption;
		parent = owner;
		setPos(owner.borderPaddingLeft, owner.borderPaddingTop);
		text.onWindowDeactivate = onWindowDeactivate;
		text.focus();
		text.deselect();
		text.setPointerPos(text.cursorX, text.cursorY);
	}

	// フォーカスが外れたらキャンセル扱い
	function onChildBlur {
		super.onChildBlur(...);
		text.cancelValue();
	}

	function onWindowDeactivate {
		text.cancelValue();
	}

	function onEnter() {
		owner.updateValue(value);
		removeSelf();
	}

	function onCancel() {
		removeSelf();
	}

	function removeSelf() {
		asyncCaller.call(owner.closeTextInput);
	}
}

class KComboDropdownWindow extends KWindow
{
	var owner;

	function KComboDropdownWindow(owner) {
		super.KWindow();
		borderStyle = bsNone;
		stayOnTop = true;
		focusable = false;

		var fontStyle = owner.curFontStyle;
		var scrollRequired = owner.count > owner.dispCount;
		var textRange;

		if (! scrollRequired) {
			primaryWidget.add(new KFrameLayout(this,
											   %[ id: "combobox_dropdown_frame",
												  name: "frame" ]));
			textRange = owner.width - owner.borderPaddingWidth;
		} else {
			primaryWidget.add(new KScrollLayout(this,
												%[ id: "combobox_dropdown_scroll",
												   name: "frame",
												   vertical: true,
												   horizontal: false ]));
			textRange = owner.width - owner.borderPaddingWidth - frame.verticalBar.buttonWidth;
		}
		frame.overwriteStyle(%[ paddingLeft: owner.borderPaddingLeft - frame.borderStyle.borderWidthLeft ]);

		frame.add(new KList(this,
							%[ id: "combobox_dropdown_list",
							   name: "list",
							   style: fontStyle ]));

		var captions = owner.captions;
		var values = owner.values;
		for (var i = 0; i < captions.count; i++)  {
			var text = captions[i];
			var hint = "";
			var textInfo = owner.getUITextInRange(fontStyle, textRange, text);
			if (! textInfo.inRange) {
				hint = text;
				text = textInfo.text;
			}
			list.add(new KComboBoxDropdownListItem(owner, text, values[i], hint));
		}
		var scale = owner.window.zoomNumer / owner.window.zoomDenom;
		setPos(owner.getScreenLeft(0), owner.getScreenTop(owner.height));
		setZoom(owner.window.zoomNumer, owner.window.zoomDenom);

		if (! scrollRequired) {
			setSize(owner.width * scale, minHeight);
		} else {
			setSize(owner.width * scale, (frame.borderPaddingHeight + (list.fontHeight + list.spaceVertical) * owner.dispCount) * scale);
		}

		if (owner.selected >= 0) {
			var selectedItem = list.childAt(owner.selected);
			selectedItem.focus();
			list.seeFocusedItem();
		}

		visible = true;
	}

	function onPopupHide() {
		closeSelf();
	}

	function closeSelf() {
		visible = false;
		asyncCaller.call(function(item){invalidate item;}, this);
	}
}


class KComboBoxDropdownListItem extends KListItem
{
	var owner;
	var value;

	function KComboBoxDropdownListItem(owner, caption, value, hint) {
		this.owner = owner;
		this.value = value;
		super.KListItem(%[ label: caption, hint: hint ]);
	}

	function onMouseUp() {
		owner.updateValue(value);
		window.closeSelf();
	}
}



