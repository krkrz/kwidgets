global.K_WIDGET_DEFAULT_FRAME_TYPE_BORDER_STYLES =
	[
		// FRANE_FLATTEN
			%[
				borderColor: 0xffacacac,
				borderStyle: BORDER_STYLE_SOLID,
				borderWidth: 1,
				paddingInset: 1,
			],
		// FRAME_SUNKEN
			%[
				borderColorLeft: 0xffacacac,
				borderStyleLeft: BORDER_STYLE_RIDGE,
				borderColorTop: 0xffacacac,
				borderStyleTop: BORDER_STYLE_RIDGE,
				borderColorRight: 0xffffffff,
				borderStyleRight: BORDER_STYLE_GROOVE,
				borderColorBottom: 0xffffffff,
				borderStyleBottom: BORDER_STYLE_GROOVE,
				borderWidth: 2,
				paddingInset: 0,
			],
		// FRAME_RAISED
			%[
				borderColorRight: 0xffacacac,
				borderStyleRight: BORDER_STYLE_RIDGE,
				borderColorBottom: 0xffacacac,
				borderStyleBottom: BORDER_STYLE_RIDGE,
				borderColorLeft: 0xffffffff,
				borderStyleLeft: BORDER_STYLE_RIDGE,
				borderColorTop: 0xffffffff,
				borderStyleTop: BORDER_STYLE_RIDGE,
				borderWidth: 2,
				paddingInset: 0,
			],
	];

class KStyleObject
{
	// 実装する必要のあるインターフェース
	// property styleParent スタイル上の親クラス
	// 
 
	function initStyleObject() {
		this._styleFragCache = %[];
		this._styleComp = %[];
	}

	function clearStyleFragCache() {
		_styleFragCache = %[];
	}

	function mergeFrags(frags) {
		frags.remove(void);
		if (frags.count == 0)
			return void;
		var result = frags[0];
		for (var i = 0; i < frags.count; i++) 
			result = unionDictionary(result, frags[i], true);
		return result;
	}

	function getStyleFragForId(definitionsSet, uniqKey, state = void) {
		var id = this.id;
		if (id == "")
			return void;
		var key = className + "#" + uniqKey + "#id#" + id;
		if (state !== void)
			key += "#" + state;
		return styleParent.findStyleFragForId(key, id, definitionsSet, state);
	}

	function findStyleFragForId(key, id, definitionsSet, state) {
		if (id == "")
			return void;
		if (typeof(_styleFragCache[key]) != K_UNDEFINED)
			return _styleFragCache[key];
		var aboveFrag = styleParent.findStyleFragForId(...);
		var frag;
		if (typeof(_style.isId) == K_UNDEFINED
			|| typeof(_style.isId[id]) == K_UNDEFINED)
			frag = aboveFrag;
		else {
			frag = mergeFrags([ aboveFrag, extractStyleFrag(_style.isId[id], definitionsSet, state) ]);
		}
		_styleFragCache[key] = frag;
		return frag;
	}

	function getStyleFragForClass(definitionsSet, uniqKey, state = void) {
		var classes = classTrees;
		var key = className + "#" + uniqKey + "#class";
		if (state !== void)
			key += "#" + state;
		return styleParent.findStyleFragForClass(key, classes, definitionsSet, state);
	}

	function findStyleFragForClass(key, classes, definitionsSet, state) {
		if (typeof(_styleFragCache[key]) != K_UNDEFINED)
			return _styleFragCache[key];
		var aboveFrag = styleParent.findStyleFragForClass(...);
		var frags = [ aboveFrag ];
		if (typeof(_style.isClass) != K_UNDEFINED)
			for (var i = 0; i < classes.count; i++) {
				var klass = classes[i];
				if (typeof(_style.isClass[klass]) != K_UNDEFINED) 
					frags.insert(1, extractStyleFrag(_style.isClass[klass], definitionsSet, state));
			}
		var frag = mergeFrags(frags);
		_styleFragCache[key] = frag;
		return frag;
	}

	function getStyleFragForClassWeak(definitionsSet, uniqKey, state = void) {
		var classes = classTrees;
		var key = className + "#" + uniqKey + "#classweak";
		if (state !== void)
			key += "#" + state;
		return styleParent.findStyleFragForClassWeak(key, classes, definitionsSet, state);
	}

	function findStyleFragForClassWeak(key, classes, definitionsSet, state) {
		if (typeof(_styleFragCache[key]) != K_UNDEFINED)
			return _styleFragCache[key];
		var aboveFrag = styleParent.findStyleFragForClassWeak(...);
		var frags = [ aboveFrag ];
		if (typeof(_style.isClassWeak) != K_UNDEFINED)
			for (var i = 0; i < classes.count; i++) {
				var klass = classes[i];
				if (typeof(_style.isClassWeak[klass]) != K_UNDEFINED)
					frags.insert(1, extractStyleFrag(_style.isClassWeak[klass], definitionsSet, state));
			}
		var frag = mergeFrags(frags);
		_styleFragCache[key] = frag;
		return frag;
	}

	function extractStyleFrag(style, definitionsSet, state) {
		if (state !== void) {
			if (typeof(style[state]) == K_UNDEFINED)
				return void;
			style = style[state];
		}

		var result = %[];
		var modified = false;

		for (var i = 0; i < definitionsSet.count; i++) {
			var defs = definitionsSet[i];
			for (var j = 0; j < defs.count; j++) {
				var def = defs[j];
				var propKey = def[0];
				var searchKey = def[1];
				if (searchKey instanceof "Array") {
					for (var k = 0; k < searchKey.count; k++) {
						var key = searchKey[k];
						if (typeof(style[key]) != K_UNDEFINED) {
							modified = true;
							result[propKey] = style[key];
							break;
						}
					}
				} else {
					var key = searchKey;
					if (typeof(style[key]) != K_UNDEFINED) {
						modified = true;
						result[propKey] = style[key];
					}
				}
			}
		}

		if (modified)
			return result;
		else
			return void;
	}

	function updateStyleComp(defsSet = styleRepository.getDefaultDefinitions(this), uniqKey = "default") {
		var frags = [];
		for (var i = 0; i < styleStates.count; i++) {
			var state = styleStates[i];
			frags.add(extractStyleFrag(_style, defsSet, state));
			frags.add(getStyleFragForId(defsSet, uniqKey, state));
			frags.add(getStyleFragForClass(defsSet, uniqKey, state));
			frags.add(getStyleFragForClassWeak(defsSet, uniqKey, state));
		}
		frags.add(extractStyleFrag(_style, defsSet));
		frags.add(getStyleFragForId(defsSet, uniqKey));
		frags.add(getStyleFragForClass(defsSet, uniqKey));
		frags.add(getStyleFragForClassWeak(defsSet, uniqKey));
		frags.reverse();
		_styleComp = mergeFrags(frags);
		if (_styleComp === void)
			_styleComp = %[];
	}

	function extractStyle(definition) {
		var style = %[];
		for (var i = 0; i < definition.count; i++) {
			var def = definition[i];
			var key = def[0];
			if (typeof(_styleComp[key]) != K_UNDEFINED) 
				style[key] = _styleComp[key];
			else
				style[key] = def[2];
		}
		applyAdditionalFunction(style, definition);

		return style;
	}

	function applyAdditionalFunction(style, definition) {
		global.applyAdditionalFunction(this, style, definition);
		return;

		// BEGIN  reference implementation.
		// This code is actually optimized and executed in C++.
		for (var i = 0; i < definition.count; i++) {
			var def = definition[i];
			var memberKey = def[0];
			if (style[memberKey] === void) {
				var initialProperty = def[4];
				if (initialProperty !== void)
					style[memberKey] = this[initialProperty];
			}
			var resolveFunction = def[3];
			if (resolveFunction !== void) {
				var memberKey = def[0];
				style[memberKey] = this[resolveFunction](style[memberKey], style);
			}
		}
		// END  reference implementation.
	}

@if (0)
	// These commented out codes are reference implementations
	//  showing the algorithm before optimization.
	function updateStyleKeys() {
		if (typeof(_style.isId) == K_UNDEFINED)
			_idStyleKeys = [];
		else
			_idStyleKeys = dictionaryKeys(_style.isId);

		if (typeof(_style.isClass) == K_UNDEFINED)
			_classStyleKeys = [];
		else
			_classStyleKeys = dictionaryKeys(_style.isClass);

		if (typeof(_style.isClassWeak) == K_UNDEFINED)
			_classWeakStyleKeys = [];
		else
			_classWeakStyleKeys = dictionaryKeys(_style.isClassWeak);
	}

	function extractStyleChain(includeSelfToChain = false, classes = classTrees) {
		return global.extractStyleChain(this, includeSelfToChain, classes);

		// BEGIN  reference implementation.
		// This code is actually optimized and executed in C++.

		var result =  [];
		if (! includeSelfToChain)
			result.add(_style);

		var list;
		if (isAttachedToWindow) {
			list = ancestors;
			list.reverse();
			list.add(window);
			list.add(styleRepository);
		} else {
			list = [ styleRepository ];
		}

		if (includeSelfToChain)
			list.insert(0, this);

		var idInsertionIndex, classInsertionIndex, classWeakInsertionIndex;
		idInsertionIndex = classInsertionIndex = classWeakInsertionIndex = result.count;

		for (var i = 0; i < list.count; i++) {
			var widget = list[i];
			if (! includeSelfToChain) {
				if (widget._idStyleKeys.find(id) >= 0) {
					result.insert(idInsertionIndex, widget._style.isId[_id]);
					idInsertionIndex++;
					classInsertionIndex++;
					classWeakInsertionIndex++;
				}
			}
			if (intersectionSet(widget._classStyleKeys, classes).count > 0)
				for (var j = 0; j < classes.count; j++) {
					var klass = classes[j];
					if (typeof(widget._style.isClass[klass]) != K_UNDEFINED) {
						result.insert(classInsertionIndex, widget._style.isClass[klass]);
						classInsertionIndex++;
						classWeakInsertionIndex++;
					}
				}
			if (intersectionSet(widget._classWeakStyleKeys, classes).count > 0)
				for (var j = 0; j < classes.count; j++) {
					var klass = classes[j];
					if (typeof(widget._style.isClassWeak[klass]) != K_UNDEFINED) {
						result.insert(classWeakInsertionIndex, widget._style.isClassWeak[klass]);
						classWeakInsertionIndex++;
					}
				}
		}
		return result;

		// END  reference implementation.
	}

	function updateStyleChain() {
		_styleChain = extractStyleChain();
	}

	function extractStyle(definition) {
		return extractStyleWithChain(_styleChain, styleStates, definition);
	}

	function extractStyleWithChain(chain, states, definition) {
		var style = global.extractStyleWithChain(...);
		applyAdditionalFunction(style, definition);
		return style;

		// BEGIN  reference implementation.
		// This code is actually optimized and executed in C++.
		var style = %[];
		for (var i = 0; i < definition.count; i++) {
			var def = definition[i];
			var memberKey = def[0];
			var styleKey = def[1];
			var defaultValue = def[2];
			style[memberKey] = styleRepository.getPropertyFromStyleChain(chain, states, styleKey, defaultValue);
		}
		applyAdditionalFunction(style, definition);
		return style;
		// END  reference implementation.
	}

@endif
}

//----------------------------------------------------------------------
// スタイルレポジトリ
class KStyleRepository
{
	var classStyleMap = %[];
	var classWeakStyleMap = %[];
	var idStyleMap = %[];
	var _style;
	var className = "KStyleRepository";
	var themeMap = %[];
	var aliasMap = %[];
	var styleNotficationLockCount = 0;
	var styleModified = false;
	var readStorageFiles = [];
	var styleParent = %[ styleParent: void,
						 findStyleFragForId: function { return void; },
						 findStyleFragForClass: function { return void; },
						 findStyleFragForClassWeak: function { return void; } ];
	var classTreeCache = %[];
	var widgetStyleDefinitionCache = %[];
	var defaultDefinitionsCache = %[];
	
	function KStyleRepository() {
		_style = %[ isId: idStyleMap,
					isClass: classStyleMap,
					isClassWeak: classWeakStyleMap,
				  ];
		initStyleObject();
	}

	function clear() {
		idStyleMap = %[];
		classStyleMap = %[];
		classWeakStyleMap = %[];
		themeMap = %[];
		aliasMap = %[];
		_style = %[ isId: idStyleMap,
					isClass: classStyleMap,
					isClassWeak: classWeakStyleMap,
				  ];
	}

	function getWidgetStyleDefinition(widget) {
		var key = widget.className;
		if (typeof(widgetStyleDefinitionCache[key]) == K_UNDEFINED)
			widgetStyleDefinitionCache[key] = [ widget.widgetStyleDefinition ];
		return widgetStyleDefinitionCache[key];
	}

	function getDefaultDefinitions(widget) {
		var key = widget.className;
		if (typeof(defaultDefinitionsCache[key]) == K_UNDEFINED)
			defaultDefinitionsCache[key] = widget.defaultDefinitions;
		return defaultDefinitionsCache[key];
	}

	function registerClassStyle(className, style) {
		classStyleMap[className] = normalizeStyle(style);
		invalidateStyles();
	}

	function overwriteClassStyle(className, style) {
		if (typeof(classStyleMap[className]) === K_UNDEFINED)
			registerClassStyle(...);
		else
			(Dictionary.assign incontextof classStyleMap[className])(normalizeStyle(style), false);
		invalidateStyles();
	}

	function registerClassWeakStyle(className, style) {
		classWeakStyleMap[className] = normalizeStyle(style);
		invalidateStyles();
	}

	function overwriteClassWeakStyle(className, style) {
		if (typeof(classWeakStyleMap[className]) === K_UNDEFINED)
			registerClassWeakStyle(...);
		else
			(Dictionary.assign incontextof classWeakStyleMap[className])(normalizeStyle(style), false);
		invalidateStyles();
	}

	function registerIdStyle(idName, style) {
		idStyleMap[idName] = normalizeStyle(style);
		invalidateStyles();
	}

	function overwriteIdStyle(idName, style) {
		if (typeof(idStyleMap[idName]) === K_UNDEFINED)
			registerIdStyle(...);
		else
			(Dictionary.assign incontextof idStyleMap[idMame])(normalizeStyle(style), false);
		invalidateStyles();
	}

	function registerTheme(themeName, style) {
		themeMap[themeName] = normalizeStyle(style);
		invalidateStyles(true);
	}

	function overwriteTheme(themeName, style) {
		if (typeof(themeMap[themeName]) == K_UNDEFINED)
			registerTheme(...);
		else
			(Dictionary.assign incontextof themeMap[themeMame])(normalizeStyle(style), false);
		invalidateStyles(true);
	}

	function findTheme(themeName) {
		if (themeName instanceof "Array") {
			var result = %[];
			for (var i = 0; i < themeName.count; i++) 
				result = unionDictionary(result, findTheme(themeName[i]), true);
			return result;
		} else if (themeName != ""
				   && typeof(themeMap[themeName]) != K_UNDEFINED)
			return themeMap[themeName];
		else
			return %[];
	}

	function registerAlias(category, map) {
		aliasMap[category] = map;
		invalidateStyles(true);
	}

	function overwriteAlias(category, map) {
		if (typeof(aliasMap[category]) == K_UNDEFINED)
			registerAlias(...);
		else
			(Dictionary.assign incontextof aliasMap[category])(map, false);
		invalidateStyles(true);
	}

	function resolveAlias(category, key) {
		while(true) {
			if (! key instanceof "String"
				|| typeof(aliasMap[category]) == K_UNDEFINED
				|| typeof(aliasMap[category][key]) == K_UNDEFINED)
				return key;
			key = aliasMap[category][key];
		}
	}

	function lockStyleNotification() {
		styleNotficationLockCount++;
	}

	function unlockStyleNotification(fullUpdate) {
		if (--styleNotficationLockCount == 0) {
			if (styleModified) {
				styleModified = false;
				readStorageFiles = [];
				clearStyleFragCache();
				invalidateStyles(fullUpdate);
			}
		}
	}

	function invalidateStyles(fullUpdate = false) {
		if (styleNotficationLockCount) {
			styleModified = true;
			return;
		}
		for (var i = 0; i < _existentWindowList.count; i++) {
			var window = _existentWindowList[i];
			window.invalidateStylesToDescendants(fullUpdate);
		}
	}

	function normalizeStyle(style) {
		style = duplicateStruct(style);
		var defines = %[ frameType: K_WIDGET_DEFAULT_FRAME_TYPE_BORDER_STYLES ];
		var defineKeys = dictionaryKeys(defines);
		extractDefinedProperties(style, defines, defineKeys);
		return style;
	}

	function getPropertyFromStyle(style, key, result) {
		// BEGIN  reference implementation.
		// This code is actually optimized and executed in C++.
		if (key instanceof "String") {
			if (key != ""
				&& typeof(style[key]) != K_UNDEFINED) {
				result[0] = style[key];
				return true;
			}
		} else {
			var keys = key;
			for (var i = 0; i < keys.count; i++) {
				key = keys[i];
				if (key != ""
					&& typeof(style[key]) != K_UNDEFINED) {
					result[0] = style[key];
					return true;
				}
			}
		}
		return false;
		// END  reference implementation.
	}

	function getPropertyFromStyleChain(styleChain, states, key, defaultValue) {
		// BEGIN  reference implementation.
		// This code is actually optimized and executed in C++.
		var result = [];
		if (states !== void) {
			for (var i = 0; i < states.count; i++) {
				var state = states[i];
				for (var j = 0; j < styleChain.count; j++) {
					var style = styleChain[j];
					if (typeof(style[state]) != K_UNDEFINED) {
						if (getPropertyFromStyle(style[state], key, result))
							return result[0];
					}
				}
			}
		}
		for (var i = 0; i < styleChain.count; i++) {
			var style = styleChain[i];
			if (getPropertyFromStyle(style, key, result))
				return result[0];
		}
		return defaultValue;
		// END  reference implementation.
	}

	function loadStyles(defs) {
		lockStyleNotification();

		for (var i = 0; i < defs.count; i++) {
			var def = defs[i];

			if (typeof(def.alias) != K_UNDEFINED) {
				if (typeof(def.map) == K_UNDEFINED)
					throw new Exception("no effective map found in alias definition.");
				registerAlias(def.alias, def.map);
				continue;
			}

			if (typeof(def.include) != K_UNDEFINED) {
				loadStylesStorage(def.include);
				continue;
			}

			var style;
			if (typeof(def.styleOfKlass) != K_UNDEFINED)
				style = classStyleMap[def.styleOfKlass];
			else if (typeof(def.styleOfClass) != K_UNDEFINED)
				style = classStyleMap[def.styleOfClass];
			else if (typeof(def.styleOfId) != K_UNDEFINED)
				style = idStyleMap[def.styleOfId];
			if (typeof(def.style) != K_UNDEFINED) {
				if (style === void)
					style = %[];
				style = unionDictionary(style, def.style, true);
			}

			if (style === void)
				throw new Exception("no effective style found in style definition.");

			if (typeof(def.klass) != K_UNDEFINED)
				registerClassStyle(def.klass, style);
			else if (typeof(def["class"]) != K_UNDEFINED)
				registerClassStyle(def["class"], style);
			else if (typeof(def.klassWeak) != K_UNDEFINED)
				registerClassStyle(def.klassWeak, style);
			else if (typeof(def["classWeak"]) != K_UNDEFINED)
				registerClassStyle(def["classWeak"], style);
			else if (typeof(def.id) != K_UNDEFINED)
				registerIdStyle(def.id, style);
			else if (typeof(def.theme) != K_UNDEFINED)
				registerTheme(def.theme, style);
			else
				throw new Exception("no effective identifier found in style definition.");
		}

		unlockStyleNotification(true);
	}

	function loadStylesStorage(filename) {
		if (readStorageFiles.find(filename) >= 0)
			reutrn;
		readStorageFiles.add(filename);

		loadStyles(Scripts.evalStorage(filename));
	}

	function initStyles(defs) {
		clear();
		loadStyles(defs);
	}

	function initStylesStorage(filename) {
		clear();
		loadStylesStorage(filename);
	}
};

mixin(KStyleRepository, KStyleObject);

global.styleRepository = new KStyleRepository();

