//
// $Id: KFrameLayout.tjs,v 1.4 2007/09/11 15:40:56 m2 Exp $
//



/**----------------------------------------------------------------------
 * フレームレイアウト
 ----------------------------------------------------------------------*/
global.KFrameLayoutArgsFormat =
	[
			%[ key: "type", defaultValue: FRAME_FLATTEN ],
			%[ key: "label", defaultValue: "" ],
			%[ key: "name", defaultValue: "" ]
	];

class KFrameLayout extends KLayout
{
	var child;
	var _type;
	var _label;
	var _helpText = "";
	var labelBounds;
	var helpBounds;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * options:
	 name: 名前
	 label: テキストラベル
	 type: フレームタイプ (省略して、スタイルで詳細指定してもよい)
	 style:
	 textAlign (ALIGN_CENTER) : テキストアライメント
	 ------------------------------*/
	function KFrameLayout(win, *) {
		var opts = parseOldStyleWidgetArgs(KFrameLayoutArgsFormat, *);

		super.KLayout(win, opts);

		_type = getOption("type", void);
		_label = getOption("label", "");
		_helpText = getOption("helpText", "");
		overwriteStyle(%[ frameType: _type ]);
	}

	function onExtractWidgetStyle(widgetStyle) {
		widgetStyle.textAlign = getStyleProperty("textAlign", ALIGN_CENTER);
	}

	/**------------------------------
	 * フレームタイプ
	 *
	 * @param v フレームタイプ
	 * @return フレームタイプ
	 ------------------------------*/
	property type {
		getter {
			return _type;
		}
		setter(v) {
			if (_type == v)
				return;
			_type = v;
			overwriteStyle(%[ frameType: _type ]);
		}
	}

	/**------------------------------
	 * ラベル
	 *
	 * @param v ラベル
	 * @return ラベル
	 ------------------------------*/
	property label {
		getter {
			return _label;
		}
		setter(v) {
			if (_label == v)
				return;
			_label = v;
			redrawContents();
		}
	}

	/**------------------------------
	 * ヘルプテキスト
	 *
	 * @param v テキスト
	 * @return テキスト
	 ------------------------------*/
	property helpText {
		getter {
			return _helpText;
		}
		setter(v) {
			if (_helpText == v)
				return;
			_helpText = v;
			redrawContents();
			return v;
		}
	}

	/**------------------------------
	 * 子ウィジェットを配置する
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		this.child = child;
		child.parent = this;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを削除する
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		this.child = void;
		child.parent = widgetDepot;
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/*------------------------------
	 * レイアウトを計算する
	 ------------------------------*/
	function onCalculateLayout() {
		var minW, maxW, minH, maxH;
			minW = maxW = borderPaddingWidth;
			minH = maxH = borderPaddingHeight;

		if (child !== void) {
			minW += child.minWidth + child.marginHorizontal;
			maxW += child.maxWidth + child.marginHorizontal;
			minH += child.minHeight + child.marginVertical;
			maxH += child.maxHeight + child.marginVertical;
		}

		if (label != "") {
			minH += fontStyle.fontHeight;
			maxH += fontStyle.fontHeight;
		}

		setMinMaxSize(minW, minH, maxW, maxH);
	}

	/*------------------------------
	 * ウィジェットを再配置する
	 ------------------------------*/
	function onLocateLayout {
		var contentTop = 0;
		if (label != "")
			contentTop = fontStyle.fontHeight;

		fillRect(0, 0, width, height, borderStyle.backgroundColor);
		drawBorder(borderStyle, 0, contentTop / 2, width, height - contentTop / 2);

		labelBounds = void;
		helpBounds = void;

		if (label != "") {
			applyFontStyle(font, fontStyle);
			var lx = fontStyle.fontHeight / 2;
			var ly = 0;
			var lw = width - fontStyle.fontHeight;
			if (helpText != "")
				lw -= findIcon("k_help").width;
			var result = drawUITextInRange(fontStyle,
										   fontStyle.fontHeight / 2, 0, lw,
										   label, widgetStyle.textAlign, true);
			if (! result.inRange)
				labelBounds = new KRect(result.x, result.y, result.w, fontStyle.fontHeight);
			if (helpText != "") {
				var helpIcon = findIcon("k_help");
				var hx = int(result.x + result.w);
				var hy = int(result.y + (fontStyle.fontHeight - helpIcon.height) / 2);
				operateRect(hx, hy, helpIcon, 0, 0, helpIcon.width, helpIcon.height, omAuto, appearanceStyle.opacity);
				helpBounds = new KRect(hx, hy, helpIcon.width, helpIcon.height);
			}
		}
		if (child !== void) {
			child.setSize(width - borderPaddingWidth - child.marginHorizontal,
						  height - borderPaddingHeight - child.marginVertical - contentTop);
			child.setPos(borderPaddingLeft + child.marginLeft,
						 borderPaddingTop + child.marginTop + contentTop);
		}
	}

	// マウス位置に応じてヘルプテキストを表示
	function onMouseMove(x, y) {
		super.onMouseMove(...);
		if (labelBounds !== void
			&& labelBounds.contains(x, y))
			hint = label;
		else if (helpBounds !== void
				 && helpBounds.contains(x, y))
			hint = helpText;
		else
			hint = "";
	}
}
