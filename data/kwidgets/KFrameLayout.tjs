//
// $Id: KFrameLayout.tjs,v 1.4 2007/09/11 15:40:56 m2 Exp $
//



/**----------------------------------------------------------------------
 * フレームレイアウト
 ----------------------------------------------------------------------*/
global.KFrameLayoutArgsFormat =
	[
			%[ key: "type", defaultValue: FRAME_FLATTEN ],
			%[ key: "label", defaultValue: "" ],
			%[ key: "name", defaultValue: "" ]
	];

global.KFrameLayoutWidgetStyleDefinition =
	[
		[ "textAlign", "textAlign", ALIGN_CENTER ],
		[ "checkIcon", "checkIcon", "" ],
		[ "helpIcon", "helpIcon", "" ]
	];

class KFrameLayout extends KLayout
{
	var child;
	var _type;
	var _label;
	var _helpText = "";
	var _checkable;
	var _checked = true;
	var labelBounds;
	var helpBounds;
	var checkBounds;
	var checkButtonPress = false;
	var labelFieldHeight = 0;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * options:
	 name: 名前
	 label: テキストラベル
	 type: フレームタイプ (省略して、スタイルで詳細指定してもよい)
	 style:
	 textAlign (ALIGN_CENTER) : テキストアライメント
	 ------------------------------*/
	function KFrameLayout(win, *) {
		var opts = parseOldStyleWidgetArgs(KFrameLayoutArgsFormat, *);

		super.KLayout(win, opts);

		_type = getOption("type", void);
		_label = getOption("label", "");
		_helpText = getOption("helpText", "");
		_checkable = getOption("checkable", false);
		_checked = getOption("cheecked", true);
		focusable = getOption("focusable", window.defaultFocusable);
		overwriteStyle(%[ frameType: _type ]);
		addCustomStyleState("checked");
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KFrameLayoutWidgetStyleDefinition);
		}
	}

	function onUnserialize(dict, key) {
		if (_checkable)
			checked = dict.init(key + "_checked", true);
	}

	function onSerialize(dict, key) {
		if (_checkable)
			dict.set(key + "_checked", checked);
	}

	/**------------------------------
	 * フレームタイプ
	 *
	 * @param v フレームタイプ
	 * @return フレームタイプ
	 ------------------------------*/
	property type {
		getter {
			return _type;
		}
		setter(v) {
			if (_type == v)
				return;
			_type = v;
			overwriteStyle(%[ frameType: _type ]);
		}
	}

	/**------------------------------
	 * ラベル
	 *
	 * @param v ラベル
	 * @return ラベル
	 ------------------------------*/
	property label {
		getter {
			return _label;
		}
		setter(v) {
			if (_label == v)
				return;
			_label = v;
			redrawContents();
		}
	}

	/**------------------------------
	 * ヘルプテキスト
	 *
	 * @param v テキスト
	 * @return テキスト
	 ------------------------------*/
	property helpText {
		getter {
			return _helpText;
		}
		setter(v) {
			if (_helpText == v)
				return;
			_helpText = v;
			redrawContents();
			return v;
		}
	}

	/*------------------------------
	 * チェック
	 ------------------------------*/
	property checked {
		getter {
			return _checked;
		}
		setter(v) {
			if (_checked == v)
				return;
			_checked = v;
			if (child !== void)
				child.enabled = v;
			if (v)
				addCustomStyleState("checked");
			else
				removeCustomStyleState("checked");
		}
	}

	/**------------------------------
	 * 子ウィジェットを配置する
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		this.child = child;
		child.parent = this;
		child.enabled = _checked;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを削除する
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		this.child = void;
		child.parent = widgetDepot;
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/*------------------------------
	 * レイアウトを計算する
	 ------------------------------*/
	function onCalculateLayout() {
		var minW, maxW, minH, maxH;
			minW = maxW = borderPaddingWidth;
			minH = maxH = borderPaddingHeight;

		if (child !== void) {
			minW += child.minWidth + child.marginHorizontal;
			maxW += child.maxWidth + child.marginHorizontal;
			minH += child.minHeight + child.marginVertical;
			maxH += child.maxHeight + child.marginVertical;
		}


		if (label != "") {
			labelFieldHeight = fontStyle.fontHeight;
			if (_checkable)
				labelFieldHeight = Math.max(labelFieldHeight, findIcon(widgetStyle.checkIcon).height);
			if (helpText != "")
				labelFieldHeight = Math.max(labelFieldHeight, findIcon(widgetStyle.helpIcon).height);
			minH += labelFieldHeight;
			maxH += labelFieldHeight;
		}

		setMinMaxSize(minW, minH, maxW, maxH);
	}

	/*------------------------------
	 * ウィジェットを再配置する
	 ------------------------------*/
	function onLocateLayout {
		var contentTop = 0;
		if (label != "")
			contentTop = labelFieldHeight;

		fillRect(0, 0, width, height, 0);
		drawBorder(borderStyle, 0, contentTop / 2, width, height - contentTop / 2);

		labelBounds = void;
		helpBounds = void;

		if (label != "") {
			applyFontStyle(font, fontStyle);
			var lx = fontStyle.fontHeight;
			var ly = 0;
			var lw = width - fontStyle.fontHeight * 2;
			if (_checkable) {
				var checkIcon = findIcon(widgetStyle.checkIcon);
				lw -= checkIcon.width + spaceHorizontal;
				lx += checkIcon.width + spaceHorizontal;
			}
			if (helpText != "")
				lw -= findIcon(widgetStyle.helpIcon).width + spaceHorizontal;
			var result = drawUITextInRange(fontStyle,
										   lx, (labelFieldHeight - fontStyle.fontHeight) / 2, lw,
										   label, widgetStyle.textAlign,
										   function(x, y, w, h, color) { fillRect(x, y, w, h, 0); fillRect(x, y + h / 2, w, h / 2, color); } incontextof this);
			if (! result.inRange)
				labelBounds = new KRect(result.x, result.y, result.w, fontStyle.fontHeight);
			if (_checkable) {
				var checkIcon = findIcon(widgetStyle.checkIcon);
				var cx = int(result.x - checkIcon.width - spaceHorizontal);
				var cy = int((labelFieldHeight - checkIcon.height) / 2);
				operateRect(cx, cy, checkIcon, 0, 0, checkIcon.width, checkIcon.height, omAuto, appearanceStyle.opacity);
				checkBounds = new KRect(cx, cy, checkIcon.width, checkIcon.height);
				checkBounds.unionWith(new KRect(result.x, result.y, result.w, fontStyle.fontHeight));
			}
			if (helpText != "") {
				var helpIcon = findIcon(widgetStyle.helpIcon);
				var hx = int(result.x + result.w + spaceHorizontal);
				var hy = int((labelFieldHeight - helpIcon.height) / 2);
				operateRect(hx, hy, helpIcon, 0, 0, helpIcon.width, helpIcon.height, omAuto, appearanceStyle.opacity);
				helpBounds = new KRect(hx, hy, helpIcon.width, helpIcon.height);
			}
		}
		if (child !== void) {
			child.setSize(width - borderPaddingWidth - child.marginHorizontal,
						  height - borderPaddingHeight - child.marginVertical - contentTop);
			child.setPos(borderPaddingLeft + child.marginLeft,
						 borderPaddingTop + child.marginTop + contentTop);
		}
	}

	// マウス位置に応じてヘルプテキストを表示
	function onMouseMove(x, y) {
		super.onMouseMove(...);
		if (labelBounds !== void
			&& labelBounds.contains(x, y))
			hint = label;
		else if (helpBounds !== void
				 && helpBounds.contains(x, y))
			hint = helpText;
		else
			hint = "";
	}

	function onMouseDown(x, y) {
		super.onMouseDown(...);
		if (_checkable
			&& checkBounds.contains(x, y))	{
			focus();
			checkButtonPress = true;
		}
	}

	function onMouseUp(x, y) {
		super.onMouseUp(...);
		if (checkButtonPress) {
			checkButtonPress = false;
			if (checkBounds.contains(x, y))
				checked = ! checked;
		}
	}

	function onKeyDown(key, shift) {
		if (key == VK_SPACE || key == VK_RETURN) {
			checked = ! checked;
		} else {
			super.onKeyDown(...);
		}
	}
}
