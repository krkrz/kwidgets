//
// シンプルなダイアログ。
// 格納するウィジェットリストを定義式で与えて作成する。
//
// ex) 
//   var def = %[ 
//       name: "test_dialog",
//       response: DIALOG_RESPONSE_OK | DIALOG_RESPONSE_CANCEL,
//       caption: "Test Dialog",
//       widgetList: [ %[ name: "check", label: "チェックボックス", type: UI_TYPE_CHECKBOX,  defaultValue: true ],
//                     %[ name: "int",   label: "整数入力",         type: UI_TYPE_TEXTINPUT, textType: TEXT_DIGIT ],
//                     %[ name: "real",  label: "小数入力",         type: UI_TYPE_TEXTINPUT, textType: TEXT_REAL, defaultValue: 0.5 ],
//                     %[ name: "str",   label: "文字入力",         type: UI_TYPE_TEXTINPUT, textType: TEXT_ANY ],
//                     %[ name: "text",  label: "テキスト",         type: UI_TYPE_TEXTBOX,   defaultValue: "ほげ\nもげ" ],
//                     %[ name: "list",  label: "リスト":           type: UI_TYPE_DROPDOWNLIST, listItems: [ "項目1", [ "項目2", 2 ], [ "項目3", 3 ] ], defaultValue: 2]
//                     ]
//   ];


global.K_CUSTOM_UI_DEFAULT_WIDGET_MIN_WIDTH = 200;

class KCustomUIGenerator
{
	var generatorMap = %[];
	var mdPat = /^\[md\]\s*(.*)/;

	function KCustomUIGenerator() {
		initDefaultGenerators();
	}

	function getValue(def, key, defaultValue) {
		if (typeof(def[key]) != "undefined")
			return def[key];
		else
			return defaultValue;
	}

	function hasLabel(def) {
		return typeof(def.label) != K_UNDEFINED;
	}

	function generateLabel(window, def) {
		if (! hasLabel(def))
			return void;
		var labelText = getValue(def, "label", "");
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		if (mdPat.test(labelText)) {
			return new KMarkdownLabel(window, %[ label: mdPat.matches[1], hint: hint, status: status ]);
		} else {
			return new KTextLabel(window, %[ label: labelText, hint: hint, status: status ]);
		}
	}

	function initDefaultGenerators() {
		var defs = global.K_CUSTOM_UI_DEFAULT_GENERATOR = [
				%[ type: UI_TYPE_TEXTBUTTON,   func: generateTextButton ],
				%[ type: UI_TYPE_MARKDOWNBUTTON,   func: generateMarkdownButton ],
				%[ type: UI_TYPE_CHECKBOX,     func: generateCheckBox ],
				%[ type: UI_TYPE_SLIDER,       func: generateSlider ],
				%[ type: UI_TYPE_TEXTINPUT,    func: generateTextInput ],
				%[ type: UI_TYPE_TEXTLABEL,    func: generateTextLabel ],
				%[ type: UI_TYPE_TEXTAREA,     func: generateTextArea ],
				%[ type: UI_TYPE_TABLE,        func: generateTable ],
				%[ type: UI_TYPE_DROPDOWNLIST, func: generateDropdownList ],
				%[ type: UI_TYPE_SEPARATOR,    func: generateSeparator ],
				%[ type: UI_TYPE_PLACEHOLDER,  func: generatePlaceHolder ]
		];
		for (var i = 0; i < defs.count; i++) {
			var def = defs[i];
			addGenerator(def.type, def.func);
		}
	}

	function addGenerator(type, func) {
		generatorMap[type] = func incontextof this;
	}

	function generateTextButton(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var klass = global[getValue(def, "klass", "KTextButton")];
		var button = new klass(grid.window, %[ name: uiName, label: getValue(def, "label", ""), hint: hint, status: status, value: getValue(def, "value", false), style: %[ textAlign: ALIGN_CENTER ]  ]);
		return %[ label: button ];
	}

	function generateMarkdownButton(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var klass = global[getValue(def, "klass", "KMarkdownButton")];
		var button = new klass(grid.window, %[ name: uiName, label: getValue(def, "label", ""), hint: hint, status: status, value: getValue(def, "value", false), style: %[ textAlign: ALIGN_CENTER ]  ]);
		return %[ label: button ];
	}

	function generateCheckBox(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var klass = global[getValue(def, "klass", "KCheckBox")];
		var widget = new klass(grid.window, %[ name: uiName, label: getValue(def, "label", ""), hint: hint, status: status, value: getValue(def, "value", false) ]);
		return %[ widget: widget ];
	}

	function generateSlider(grid, insertionY, uiName, def, globalOptions) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = generateLabel(grid.window, def);
		var klass = global[getValue(def, "klass", "KTextInputSlider")];
		var icon = getValue(def, "icon", "");
		var leftIcon = icon != "" ? icon + "_left" : getValue(def, "leftIcon", "");
		var rightIcon = icon != "" ? icon + "_right" : getValue(def, "rightIcon", "");
		var widget = new klass(grid.window, %[ name: uiName, hint: hint, status: status,
											   width: getValue(globalOptions, "widgetMinWidth", K_CUSTOM_UI_DEFAULT_WIDGET_MIN_WIDTH),
											   left: getValue(def, "left", 0), leftIcon: leftIcon, leftIconHint: getValue(def, "leftIconHint", ""),
											   right: getValue(def, "right", 100), rightIcon: rightIcon, rightIconHint: getValue(def, "rightIconHint", ""),
											   stride: getValue(def, "stride", 1),
											   value: getValue(def, "value", getValue(def, "left", 0)) ]);
		return %[ widget: widget, label: label ];
	}

	function generateTextInput(grid, insertionY, uiName, def, globalOptions) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = ! hasLabel(def) ? void : new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status ]);
		var textType = getValue(def, "textType", TEXT_ANY);
		var value;
		switch (textType) {
		case TEXT_ANY:
			value = getValue(def, "value", ""); break;
		case TEXT_DIGIT:
		case TEXT_REAL:
			value = getValue(def, "value", 0); break;
		}
		var klass = global[getValue(def, "klass", "KTextInput")];
		var widget = new klass(grid.window, %[ width: getValue(globalOptions, "widgetMinWidth", K_CUSTOM_UI_DEFAULT_WIDGET_MIN_WIDTH), type: textType, name: uiName, hint: hint, status: status, value: value  ]);
		return %[ widget: widget, label: label ];
	}

	function generateSeparator(grid, insertionY, uiName, def) {
		var klass = global[getValue(def, "klass", "KVerticalSeparator")];
		var separator = new klass(grid.window);
		return %[ label: separator ];
	}

	function generateTextLabel(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var klass = global[getValue(def, "klass", "KTextLabel")];
		var label = new klass(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: hint  ]);
		return %[ label: label ];
	}

	function generateTextArea(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = ! hasLabel(def) ? void : new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status, style: %[ alignVertical: ALIGN_TOP ] ]);
		var scroll = new KScrollLayout(grid.window, %[ horizontal: false, vertical: true, id: "focusable_frame", hint: hint, status: status ]);
		var klass = global[getValue(def, "klass", "KTextEdit")];
		var textarea = new klass(grid.window, %[ name: uiName, value: getValue(def, "value", ""), hint: hint, status: status ]);
		scroll.setMarginalFixedSize(getValue(def, "marginalWidth", 100), getValue(def, "marginalHeight",60));
		scroll.add(textarea);
		textarea._marginalHeight = 100;
		return %[ bounds: scroll, widget: textarea, label: label ];
	}

	function generateTable(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = ! hasLabel(def) ? void : new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status, style: %[ alignVertical: ALIGN_TOP ] ]);
		var klass = global[getValue(def, "klass", "KTable")];
		var table = new klass(grid.window, %[ name: uiName, hint: hint, status: status,
											   initWithMinimumSize: getValue(def, "initWithMinimumSize", false),
											   attributes: getValue(def, "attributes", []),
											  showRowTab: getValue(def, "showRowTab", false),
											  respondToValueModification: getValue(def, "respondToValueModification", false),
											  defaultColumnOptions: getValue(def, "defaultColumnOptions", %[])
											 ]);
		table.setMarginalFixedSize(getValue(def, "marginalWidth", 100), getValue(def, "marginalHeight", 100));
		table.value = getValue(def, "value", []);
		var frame = new KFrameLayout(grid.window, %[ id: "focusable_frame" ]);
		frame.add(table);
		return %[ bounds: frame, widget: table, label: label ];
	}

	function generateDropdownList(grid, insertionY, uiName, def, globalOptions) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = ! hasLabel(def) ? void : new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status ]);
		var klass = global[getValue(def, "klass", "KComboBox")];
		var widget = new klass(grid.window, %[ name: uiName, hint: hint, status: status,
												   type: COMBO_STYLE_DROPDOWNLIST,
												   width: getValue(globalOptions, "widgetMinWidth", K_CUSTOM_UI_DEFAULT_WIDGET_MIN_WIDTH),
												   items: getValue(def, "items", []), values: getValue(def, "values", []), captions: getValue(def, "captions", []) ]);
		widget.value = getValue(def, "value", widget.values[0]);
		return %[widget: widget, label: label ];
	}

	function generatePlaceHolder(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = ! hasLabel(def) ? void : new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status ]);
		var klass = global[getValue(def, "klass", "KFrameLayout")];
		var frame = new klass(grid.window, %[ name: uiName, style: %[ borderStlye: BORDER_STYLE_NONE, borderWidth: 0, padding: 0, margin: 0, backgroundColor: 0 ] ]);
		if (label !== void)
			return %[ label: label, widget: frame ];
		else
			return %[ label: frame ];
	}
};

global.customUIGenerator = new KCustomUIGenerator();


class KCustomUI extends KGridLayout
{
	var uiList = [];
	var uiNamePrefix;
	var gridId;
	var mdPat = /^\[md\]\s*(.*)/;

	function KCustomUI(window, options = %[]) {
		options = unionDictionary(%[ style: %[ isClass: %[ KWidget: %[ alignHorizontal: ALIGN_LEFT, alignVertical: ALIGN_CENTER ] ] ] ], options, true);
		super.KGridLayout(window, options);

		id = gridId = getOption("gridId", "widget_grid");

		var uiDefs = getOption("uis", []);
		uiList = [];

		var valueModifiedFunc = getOption("onValueModified", void);
		if (valueModifiedFunc !== void)
			onValueModified = valueModifiedFunc;

		uiNamePrefix = getOption("uiNamePrefix", "");
		var labelStyle = getOption("labelStyle", UI_LABEL_STYLE_LEFT);
		var fixedLabel = getOption("fixedLabel", false);
		var insertLabelToStatus = getOption("insertLabelToStatus", true);

		var insertionY = 0;
		var curGrid = this;
		var gridStack = [];
		var yStack = [];

		var curList = void;
		var listStack = [];

		for (var i = 0; i < uiDefs.count; i++) {
			var uiDef = uiDefs[i];
			var uiKey = getOption("name", "", uiDef);
			var uiName = uiNamePrefix + uiKey;

			if (insertLabelToStatus
				&& getOption("label", "", uiDef) != ""
				&& getOption("status", "", uiDef) != ""
				&& ! mdPat.test(uiDef.label))
				uiDef.status = uiDef.label + ": " + uiDef.status;

			if (typeof(uiDef.label) != K_UNDEFINED)
				uiDef.label = uiDef.label.trim();

			if (uiDef.type == UI_TYPE_BEGIN_FRAME) {
				var frameId = [ "sub1_frame", "sub2_frame", "sub3_frame" ][gridStack.count];
				var frame = new KFrameLayout(window, %[ id: frameId, name: getOption("name", "", uiDef), label: getOption("label", "", uiDef), helpText: getOption("helpText", "", uiDef) ] );
				var subGrid = new global.KGridLayout(window, %[ id: getOption("gridId", gridId, uiDef) ]);
				frame.add(subGrid);
				curGrid.add(0, insertionY++, frame, 2);
				gridStack.push(curGrid);
				yStack.push(insertionY);
				curGrid = subGrid;
				insertionY = 0;
				continue;
			}
			if (uiDef.type == UI_TYPE_END_FRAME) {
				curGrid = gridStack.pop();
				insertionY = yStack.pop();
				continue;
			}

			if (uiDef.type == UI_TYPE_BEGIN_LIST) {
				listStack.push(curList);
				curList = new KList(window, %[ name: getOption("name", "", uiDef), focusable: false, disableNotice: true, singleClickOpenToggle: true, style: %[ backgroundColor: 0 ] ]);
				curGrid.add(0, insertionY++, curList, 2);
				continue;
			}
			if (uiDef.type == UI_TYPE_LIST_LEVEL) {
				if (curList.childCount == 0) {
					gridStack.push(curGrid);
					yStack.push(insertionY);
				}
				var level = new KListItem(%[ name: getOption("name", "", uiDef),
											 label: getOption("label", "", uiDef),
											 opened: getOption("opened", false, uiDef),
											 record: getOption("isRecordOpenedToDictionary", false, uiDef),
											 id: "em_caption" ]);
				curList.add(level);
				var subGrid = new global.KGridLayout(window, %[ id: getOption("gridId", gridId, uiDef) ]);
				level.add(subGrid);
				curGrid = subGrid;
				insertionY = 0;
				continue;
			}
			if (uiDef.type == UI_TYPE_END_LIST) {
				if (curList.childCount != 0) {
					curGrid = gridStack.pop();
					insertionY = yStack.pop();
				}
				curList = listStack.pop();
				continue;
			}
			var result = customUIGenerator.generatorMap[uiDef.type](curGrid, insertionY, uiName, uiDef, options);
			if (result.placed)
				insertionY = result.insertionY;
			else {
				var label = result.label;
				var bounds = result.bounds !== void ? result.bounds : result.widget;

				if (label !== void
					&& fixedLabel)
					label.overwriteStyle(%[ variable: false ]);
				if (label !== void && bounds === void)
					curGrid.add(0, insertionY++, label, 2);
				else if (label === void && bounds !== void)
					curGrid.add(0, insertionY++, bounds, 2);
				else {
					switch (labelStyle) {
					case UI_LABEL_STYLE_LEFT: {
						label.id = "alignright_caption";
						curGrid.add(0, insertionY, label);
						curGrid.add(1, insertionY, bounds);
						insertionY++;
						break;
					}
					case UI_LABEL_STYLE_LEFTTOPCORNER: {
						var subGrid = new global.KGridLayout(window);
						label.id = "em_caption";
						subGrid.add(0, 0, label);
						subGrid.add(0, 1, bounds);
						curGrid.add(0, insertionY, subGrid, 2);
						insertionY++;
						break;
					}
					}
				}
			}
			if (result.widget !== void
				&& typeof(result.widget.value) != K_UNDEFINED) {
				uiList.add(%[ key: uiKey,
							  name: uiName,
							  widget: result.widget ]);

				if (typeof(uiDef.onValueModified) != K_UNDEFINED)
					result.widget.onValueModified = uiDef.onValueModified;
				if (typeof(uiDef.isAvoidDictionaryRegistration) != K_UNDEFINED)
					result.widget.isAvoidDictionaryRegistration = uiDef.isAvoidDictionaryRegistration;
			} else if (result.label !== void) {
				if (typeof(uiDef.onValueModified) != K_UNDEFINED) 
					result.label.onValueModified = uiDef.onValueModified;
			}
		}
	}

	function onValueModified() {
		super.onChildValueModified(...);
	}

	function onChildValueModified {
		onValueModified(...);
	}

	function find(name) {
		if (this.name === name)
			return this;
		var widgetName = uiNamePrefix + name;
		var result = super.find(widgetName);
		if (result !== void)
			return result;
		return super.find(name);
	}

	function callFunc(key, defaultValue, *) {
		var func = getOption(key, void);
		if (func === void)
			return defaultValue;
		else
			return (func incontextof(this))(*);
	}

	property value {
		getter {
			var result = %[];
			for (var i = 0; i < uiList.count; i++) {
				var ui = uiList[i];
				var key = ui.key;
				var uiName = ui.name;
				result[key] = this[uiName].value;
			}
			return result;
		}
		setter(v) {
			for (var i = 0; i < uiList.count; i++) {
				var ui = uiList[i];
				var key = ui.key;
				var uiName = ui.name;
				this[uiName].value = v[key];
				callFunc("onValueSet");
			}
		}
	}
};
