//
// シンプルなダイアログ。
// 格納するウィジェットリストを定義式で与えて作成する。
//
// ex) 
//   var def = %[ 
//       name: "test_dialog",
//       response: DIALOG_RESPONSE_OK | DIALOG_RESPONSE_CANCEL,
//       caption: "Test Dialog",
//       widgetList: [ %[ name: "check", label: "チェックボックス", type: UI_TYPE_CHECKBOX,  defaultValue: true ],
//                     %[ name: "int",   label: "整数入力",         type: UI_TYPE_TEXTINPUT, textType: TEXT_DIGIT ],
//                     %[ name: "real",  label: "小数入力",         type: UI_TYPE_TEXTINPUT, textType: TEXT_REAL, defaultValue: 0.5 ],
//                     %[ name: "str",   label: "文字入力",         type: UI_TYPE_TEXTINPUT, textType: TEXT_ANY ],
//                     %[ name: "text",  label: "テキスト",         type: UI_TYPE_TEXTBOX,   defaultValue: "ほげ\nもげ" ],
//                     %[ name: "list",  label: "リスト":           type: UI_TYPE_DROPDOWNLIST, listItems: [ "項目1", [ "項目2", 2 ], [ "項目3", 3 ] ], defaultValue: 2]
//                     ]
//   ];


class KCustomUIGenerator
{
	var generatorMap = %[];

	function KCustomUIGenerator() {
		initDefaultGenerators();
	}

	function getValue(def, key, defaultValue) {
		if (typeof(def[key]) != "undefined")
			return def[key];
		else
			return defaultValue;
	}

	function initDefaultGenerators() {
		var defs = global.K_CUSTOM_UI_DEFAULT_GENERATOR = [
				%[ type: UI_TYPE_CHECKBOX,     func: generateCheckBox ],
				%[ type: UI_TYPE_SLIDER,       func: generateSlider ],
				%[ type: UI_TYPE_TEXTINPUT,    func: generateTextInput ],
				%[ type: UI_TYPE_TEXTLABEL,    func: generateTextLabel ],
				%[ type: UI_TYPE_TEXTAREA,     func: generateTextArea ],
				%[ type: UI_TYPE_TABLE,        func: generateTable ],
				%[ type: UI_TYPE_DROPDOWNLIST, func: generateDropdownList ]
		];
		for (var i = 0; i < defs.count; i++) {
			var def = defs[i];
			addGenerator(def.type, def.func);
		}
	}

	function addGenerator(type, func) {
		generatorMap[type] = func incontextof this;
	}

	function generateCheckBox(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var widget = new KCheckBox(grid.window, %[ name: uiName, label: getValue(def, "label", ""), hint: hint, status: status, value: getValue(def, "value", false) ]);
		return %[ widget: widget, insertionY: ++insertionY ];
	}

	function generateSlider(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status ]);
		var widget = new KTextInputSlider(grid.window, %[ name: uiName, hint: hint, status: status,
														  width: 150,
														  left: getValue(def, "left", 0), leftIcon: getValue(def, "leftIcon", ""), leftIconHint: getValue(def, "leftIconHint", ""),
														  right: getValue(def, "right", 100), rightIcon: getValue(def, "rightIcon", ""), rightIconHint: getValue(def, "rightIconHint", ""),
														  stride: getValue(def, "stride", 1),
														  value: getValue(def, "value", getValue(def, "left", 0)) ]);
		return %[ widget: widget, label: label, insertionY: ++insertionY ];
	}

	function generateTextInput(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status ]);
		var textType = getValue(def, "textType", TEXT_ANY);
		var value;
		switch (textType) {
		case TEXT_ANY:
			value = getValue(def, "value", ""); break;
		case TEXT_DIGIT:
		case TEXT_REAL:
			value = getValue(def, "value", 0); break;
		}
		var widget = new KTextInput(grid.window, %[ width: 150, type: textType, name: uiName, hint: hint, status: status, value: value  ]);
		return %[ widget: widget, label: label, insertionY: ++insertionY ];
	}

	function generateTextLabel(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: hint  ]);
		return %[ label: label, insertionY: ++insertionY ];
	}

	function generateTextArea(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status, style: %[ alignVertical: ALIGN_TOP ] ]);
		var scroll = new KScrollLayout(grid.window, %[ horizontal: false, vertical: true, id: "focusable_frame", hint: hint, status: status ]);
		var textarea = new KTextEdit(grid.window, %[ name: uiName, value: getValue(def, "value", ""), hint: hint, status: status ]);
		scroll.setMarginalFixedSize(getValue(def, "marginalWidth", 100), getValue(def, "marginalHeight",60));
		scroll.add(textarea);
		textarea._marginalHeight = 100;
		return %[ bounds: scroll, widget: textarea, label: label, insertionY: ++insertionY ];
	}

	function generateTable(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var labelText = getValue(def, "label", "");
		var label = labelText == "" ? void : new KTextLabel(grid.window, %[ label: labelText, hint: hint, status: status, style: %[ alignVertical: ALIGN_TOP ] ]);
		var table = new KTable(grid.window, %[ name: uiName, hint: hint, status: status,
											   initWithMinimumSize: getValue(def, "initWithMinimumSize", false),
											   attributes: getValue(def, "attributes", []),
											   defaultColumnOptions: getValue(def, "defaultColumnOptions", %[])
											 ]);
		table.setMarginalFixedSize(getValue(def, "marginalWidth", 100), getValue(def, "marginalHeight", 100));
		table.value = getValue(def, "value", []);
		var frame = new KFrameLayout(grid.window, %[ id: "focusable_frame" ]);
		frame.add(table);
		return %[ bounds: frame, widget: table, label: label, insertionY: ++insertionY ];
	}

	function generateDropdownList(grid, insertionY, uiName, def) {
		var hint = getValue(def, "hint", "");
		var status = getValue(def, "status", "");
		var label = new KTextLabel(grid.window, %[ label: getValue(def, "label", ""), hint: hint, status: status ]);
		var widget = new KComboBox(grid.window, %[ name: uiName, hint: hint, status: status,
												   width: 150, type: COMBO_STYLE_DROPDOWNLIST,
												   items: getValue(def, "items", []), values: getValue(def, "values", []), captions: getValue(def, "captions", []) ]);
		widget.value = getValue(def, "value", widget.values[0]);
		return %[widget: widget, label: label, insertionY: ++insertionY ];
	}
};

global.customUIGenerator = new KCustomUIGenerator();


class KCustomUI extends KGridLayout
{
	var uiList = [];
	var uiNamePrefix;
	var gridId;

	function KCustomUI(window, options = %[]) {
		options = duplicateStruct(options);
		options.style = %[ isClass: %[ KWidget: %[ alignHorizontal: ALIGN_LEFT, alignVertical: ALIGN_CENTER ],
									   KTextLabel: %[ maxPossibleWidthRatio: 0.25 ]
									 ] ];
		super.KGridLayout(window, options);

		id = gridId = getOption("gridId", "widget_grid");

		var uiDefs = getOption("uis", []);
		uiList = [];

		uiNamePrefix = getOption("uiNamePrefix", "");
		var labelStyle = getOption("labelStyle", UI_LABEL_STYLE_LEFT);
		var fixedLabel = getOption("fixedLabel", false);

		var insertionY = 0;
		var curGrid = this;
		var gridStack = [];
		var yStack = [];

		for (var i = 0; i < uiDefs.count; i++) {
			var uiDef = uiDefs[i];
			var uiKey = getOption("name", "", uiDef);
			var uiName = uiNamePrefix + uiKey;

			if (uiDef.type == UI_TYPE_BEGIN_FRAME) {
				var frameId = [ "sub1_frame", "sub2_frame", "sub3_frame" ][gridStack.count];
				var frame = new KFrameLayout(window, %[ id: frameId, label: getOption("label", "", uiDef) ] );
				var subGrid = new global.KGridLayout(window, %[ id: gridId ]);
				frame.add(subGrid);
				curGrid.add(0, insertionY++, frame, 2);
				gridStack.push(curGrid);
				yStack.push(insertionY);
				curGrid = subGrid;
				insertionY = 0;
				continue;
			}
			if (uiDef.type == UI_TYPE_END_FRAME) {
				curGrid = gridStack.pop();
				insertionY = yStack.pop();
				continue;
			}

			var result = customUIGenerator.generatorMap[uiDef.type](curGrid, insertionY, uiName, uiDef);
			if (result.placed)
				insertionY = result.insertionY;
			var label = result.label;
			var bounds = result.bounds !== void ? result.bounds : result.widget;
			if (label !== void
				&& fixedLabel)
				label.overwriteStyle(%[ isVariableWidth: false ]);
			if (label !== void && bounds === void)
				curGrid.add(0, insertionY++, label, 2);
			else if (label === void && bounds !== void)
				curGrid.add(0, insertionY++, bounds, 2);
			else {
				switch (labelStyle) {
				case UI_LABEL_STYLE_LEFT: {
					curGrid.add(0, insertionY, label);
					curGrid.add(1, insertionY, bounds);
					insertionY++;
					break;
				}
				case UI_LABEL_STYLE_LEFTTOPCORNER: {
					var subGrid = new global.KGridLayout(window);
					label.id = "em_caption";
					subGrid.add(0, 0, label);
					subGrid.add(0, 1, bounds);
					curGrid.add(0, insertionY, subGrid, 2);
					insertionY++;
					break;
				}
				}
			}
			if (result.widget !== void) {
				uiList.add(%[ key: uiKey,
							  name: uiName,
							  widget: result.widget ]);

				if (typeof(uiDef[onValueModified]) != K_UNDEFINED)
					result.widget.onValueModified = uiDef[onValueModified];
				if (uiDef["isAvoidDictionaryRegistration"] != K_UNDEFINED)
					result.widget.isAvoidDictionaryRegistration = uiDef["isAvoidDictionaryRegistration"];
			}
		}
	}

	function find(name) {
		if (this.name === name)
			return this;
		var widgetName = uiNamePrefix + name;
		var result = super.find(widgetName);
		if (result !== void)
			return result;
		return super.find(name);
	}
};

