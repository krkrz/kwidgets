//
// $Id: KScrollLayout.tjs,v 1.12 2007/09/04 10:29:44 m2 Exp $
//


//------------------------------
// 定数
global.SCROLL_BAR_MIN_WIDTH = 50;
global.SCROLL_LAYOUT_MIN_WIDTH = 100;
global.SCROLL_HANDLE_MIN_SIZE = 10;

//----------------------------------------------------------------------
// スクロールバー
global.KScrollBarWidgetStyleDefinition =
	[
		[ "backwardButtonId", "backwardButtonId" ],
		[ "forwardButtonId", "forwardButtonId" ],
		[ "rangepointerId", "rangepointerId" ],
		[ "buttonStride", "buttonStride" ]
	];

class KScrollBar extends KEntity
{
	var widgetTouched = false;
	var backwardButton;
	var forwardButton;
	var rangePointer;
	var targetRealSize, targetWindowSize;

	// コンストラクタ
	function KScrollBar(window, opts) {
		super.KEntity(window, opts);

		// レイヤパラメータ設定
		hasImage = false;
		hitThreshold = 0;

		initWidgets();
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KScrollBarWidgetStyleDefinition);
		}
	}

	// ボタン作成
	function initWidgets() {
		// 上ボタン
		backwardButton = new KImageButton(window, %[ // label: widgetStyle.backwardButtonLabel,
			dispatchOnMouseDown: true,
													 autoDispatchStartInterval: 200,
													 autoDispatchRepeatInterval: 16,
//													 // id: widgetStyle.buttonId,
			name: "_backward",
													 focusable: false ]);
		backwardButton.parent = this;
		// 下ボタン
		forwardButton = new KImageButton(window, %[ // label: widgetStyle.forwardButtonLabel,
													dispatchOnMouseDown: true,
													autoDispatchStartInterval: 200,
													autoDispatchRepeatInterval: 16,
//													id: widgetStyle.buttonId,
													name: "_forward",
													focusable: false ]);
		forwardButton.parent = this;
		// レンジポインタ
		rangePointer = new KRangePointer2D(window,
										   %[ hKnobStride: 1,
											  vKnobStride: 1,
											  name: "_pointer",
											  interpolation: true,
											  focusable: false ]);
		rangePointer.parent = this;
	}

	// ターゲット位置更新
	property targetPos {
		getter {
			return rangePointer.value[direction];
		}
		setter (pos) {
			var pointerValue = rangePointer.value;
			pointerValue[direction] = pos;
			rangePointer.value = pointerValue;
			validateWidget();
		}
	}

	function offsetTargetPos(offset) {
		var pointerValue = rangePointer.completedValue;
		pointerValue[direction] += offset;
		rangePointer.interpolate(pointerValue);
	}

	// ターゲットサイズ更新
	function setTargetSize(realSize, windowSize, targetPos) {
		targetRealSize = realSize;
		targetWindowSize = windowSize;
		rangePointer.updateLogicalRange(direction, 0, realSize, windowSize);
		this.targetPos = targetPos;
		validateWidget();
	}

	function validateWidget() {
		backwardButton.enabled = targetPos > 0;
		forwardButton.enabled = targetPos < targetRealSize - targetWindowSize;
		enabled = targetRealSize != targetWindowSize;
	}

	function dispatch() {
		onValueModified(targetPos);
	}

	// 上ボタンが押されたら10ドット上へ
	function onPressBackward {
		offsetTargetPos(-widgetStyle.buttonStride);
	}

	// 下ボタンが押されたら10ドット下へ
	function onPressForward {
		offsetTargetPos(widgetStyle.buttonStride);
	}

	// ボタンが押された事を検知
	function onChildValueModified(child, value) {
		switch (child.name) {
		case "_backward":
			onPressBackward();
			break;
		case "_forward":
			onPressForward();
			break;
		case "_pointer":
			validateWidget();
			dispatch();
			break;
		}
	}

	function onDrawContents() {
		backwardButton.id = widgetStyle.backwardButtonId;
		forwardButton.id = widgetStyle.forwardButtonId;
		rangePointer.id = widgetStyle.rangepointerId;
		locateButton();
	}
};

//----------------------------------------------------------------------
// 垂直スクロールバー
class KVerticalScrollBar extends KScrollBar
{
	var direction = "v";

	// コンストラクタ
	function KVerticalScrollBar {
		super.KScrollBar(...);
	}

	property buttonWidth {
		getter {
			return backwardButton.width;
		}
	}

	// ボタンを再配置
	function locateButton {
		backwardButton.setPos(0, 0);
		forwardButton.setPos(0, height - forwardButton.height);
		rangePointer.setPos(0, backwardButton.height);
		rangePointer.setFixedSize(width, Math.max(0, height - backwardButton.height - forwardButton.height));
	}
}


//----------------------------------------------------------------------
// 水平スクロールバー
class KHorizontalScrollBar extends KScrollBar
{
	var direction = "h";

	// コンストラクタ
	function KHorizontalScrollBar {
		super.KScrollBar(...);
	}

	property buttonWidth {
		getter {
			return backwardButton.height;
		}
	}

	// ボタンを再配置
	function locateButton {
		backwardButton.setPos(0, 0);
		forwardButton.setPos(width - forwardButton.width, 0);
		rangePointer.setPos(backwardButton.width, 0);
		rangePointer.setFixedSize(Math.max(0, width - backwardButton.width - forwardButton.width), height);
	}
}


/*----------------------------------------------------------------------
 * スクロールフレーム(実際にchildを格納する枠)
 ----------------------------------------------------------------------*/
class KScrollFrame extends KEntity
{
	function KScrollFrame {
		super.KEntity(...);
		hasImage = false;
		isVirtualWidgetWindowedParent = true;
	}

	function notifyObservers {
		window.scrollObservers.each(this, function(observer, self) {
			if (observer.nodeEnabled
				&& observer.isDescendantOf(self))
				observer.onNotifyScroll();
		});
	}

	// アライメントに従って、スクロール範囲に収まるようにchildの座標を設定する
	function setChildPos(l, t) {
		if (children.count == 0)
			return;

		if (! isAttachedToWindow
			|| ! respondToStyleModification)
			return;

		var child = children[0];
		var childMinLeft, childMaxLeft, childMinTop, childMaxTop;
		childMinLeft = width - child.width;
		childMaxLeft = 0;
		childMinTop = height - child.height;
		childMaxTop = 0;
		var newLeft = int(Math.max(childMinLeft, Math.min(childMaxLeft, l)));
		var newTop = int(Math.max(childMinTop, Math.min(childMaxTop, t)));

		if (child.width < width) {
			switch (child.alignHorizontal) {
			case ALIGN_LEFT:   newLeft = 0; break;
			case ALIGN_CENTER: newLeft = int((width - child.width) / 2); break;
			case ALIGN_RIGHT:  newLeft = (width - child.width); break;
			}
		}

		if (child.height < height) {
			switch (child.alignVertical) {
			case ALIGN_TOP:    newTop = 0; break;
			case ALIGN_CENTER: newTop = int((height - child.height) / 2); break;
			case ALIGN_BOTTOM: newTop = (height - child.height); break;
			}
		}

		child.setPos(newLeft, newTop);
		child.onViewModified(int(Math.max(0, -newLeft)),
							 int(Math.max(0, -newTop)),
							 int(Math.min(child.width, width)),
							 int(Math.min(child.height, height)));

		notifyObservers();
	}

	// サイズ更新、アライメントに従って、childを再配置
	function onSizeModified(newWidth, newHeight, oldWidth, oldHeight) {
		if (children.count == 0)
			return;

		var child = children[0];
		child.setSize(newWidth, newHeight);

		var childMinLeft, childMaxLeft, childMinTop, childMaxTop;
		var originX, originY;
		var l, t;

		childMinLeft = width - child.width;
		childMaxLeft = 0;
		childMinTop = height - child.height;
		childMaxTop = 0;

		switch (child.alignHorizontal) {
		case ALIGN_LEFT: {
			l = child.left;
			break;
		}
		case ALIGN_CENTER: {
			originX = - child.left + int(oldWidth / 2);
			l = - originX + int(newWidth / 2);
			break;
		}
		case ALIGN_RIGHT: {
			originX = - child.left + oldWidth;
			l = - originX + newWidth;
			break;
		}
		}

		switch (child.alignVertical) {
		case ALIGN_TOP: {
			t = child.top;
			break;
		}
		case ALIGN_CENTER: {      originY = - child.top + int(oldHeight / 2);
							t = - originY + int(newHeight / 2);
							break;
						   }
		case ALIGN_BOTTOM: {
			originY = - child.top + oldHeight;
			t = - originY - newHeight;
			break;
		}
		}

		setChildPos(l, t);
	}

	function onChildMinMaxSizeModified() {
		redrawContents();
	}

	function onChildLocateStyleModified() {
		redrawContents();
	}

	function onChildVisibleModified {
		redrawContents();
	}

	function onAttachedToWindow() {
		redrawContents();
	}

	function onDrawContents() {
		parent.redrawContents();
	}

	// childの矩形ノティファイをparentに通知
	function onChildNoticeRect {
		parent.onChildNoticeRect(...);
	}
}


/*----------------------------------------------------------------------
 * スクロールレイアウト
 ----------------------------------------------------------------------*/
global.KScrollLayoutArgsFormat =
	[
			%[ key: "horizontal", defaultValue: true ],
			%[ key: "vertical", defaultValue: true ],
			%[ key: "name", defaultValue: "" ]
	];

global.KScrollLayoutWidgetStyleDefinition =
	[
		[ "mouseWheelFactor", "mouseWheelFactor", 0.25 ],
		[ "accelMouseWheelFactor", "accelMouseWheelFactor", 1 ]
	];

class KScrollLayout extends KLayout
{
	// 横方向スクロールバー
	var horizontalBar;
	// 縦方向スクロールバー
	var verticalBar;
	// スクロールフレーム
	var frame;
	// リサイズハンドル
	//  var _resizeHandle;
	var _resize;
	// child
	var child;
	// レイアウト
	var frameMinW, frameMinH, frameMaxW, frameMaxH;
	var boxMinW, boxMinH, boxMaxW, boxMaxH;
	var horizontalBarMinW, horizontalBarMinH, horizontalBarMaxW, horizontalBarMaxH;
	var verticalBarMinW, verticalBarMinH, verticalBarMaxW, verticalBarMaxH;
	var minW, minH, maxW, maxH;
	var _hideHorizontalBar, _hideVerticalBar;
	// カーソルによるスクロール
	var _cursorToScroll = false;
	var lastCursorX, lastCursorY;

	/**------------------------------
	 * コンストラクタ
	 *
	 * ウィジェットを、スクロールバーの中に配置します。
	 *
	 * @param win ウィンドウ
	 * @param horizontal 横方向スクロールバーを表示するかどうか
	 * @param vertical 縦方向スクロールバーを表示するかどうか
	 * @param name 名前
	 ------------------------------*/
	function KScrollLayout(win, *) {
		var options = parseOldStyleWidgetArgs(KScrollLayoutArgsFormat, *);
		options = unionDictionary(%[ marginalMinWidth: SCROLL_LAYOUT_MIN_WIDTH,
									 marginalMinHeight: SCROLL_LAYOUT_MIN_WIDTH,
									 marginalMaxWidth: SCROLL_LAYOUT_MIN_WIDTH,
									 marginalMaxHeight: SCROLL_LAYOUT_MIN_WIDTH ],
								  options,
								  true);

		super.KLayout(win, options);

		// パラメータ設定
		var horizontal = getOption("horizontal", true);
		var vertical = getOption("vertical", true);

		// 水平バー
		horizontalBar = new KHorizontalScrollBar(win, %[ name: "_horizontal"]);
		horizontalBar.parent = this;
		horizontalBar.visible = horizontal;
		_hideHorizontalBar = getOption("hideHorizontalBar", false);

		// 垂直バー
		verticalBar = new KVerticalScrollBar(win, %[ name: "_vertical" ]);
		verticalBar.parent = this;
		verticalBar.visible = vertical;
		_hideVerticalBar = getOption("hideVerticalBar", false);

		// 子ウィジェットを格納するフレーム
		frame = new KScrollFrame(window);
		frame.parent = this;
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KScrollLayoutWidgetStyleDefinition);
		}
	}

	/**------------------------------
	 * 子ウィジェットを配置する
	 *
	 * 子ウィジェットをスクロールバーの中に配置します。
	 * KScrollLayoutには一度に1つのウィジェットしか add できません。
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		this.child = child;
		child.parent = frame;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを開放する
	 *
	 * 子ウィジェットをスクロールバーから開放します
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		this.child = void;
		child.parent = widgetDepot;
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/**------------------------------
	 * 水平スクロールを有効にするかどうか
	 *
	 * @param v 有効/無効
	 * @return 有効/無効
	 ------------------------------*/
	property horizontal {
		getter {
			return horizontalBar.visible;
		}
		setter(v) {
			// パラメータ更新
			horizontalBar.visible = v;
			// 再レイアウト
			redrawContents();
		}
	}

	/**------------------------------
	 * 垂直スクロールを有効にするかどうか
	 *
	 * @param v 有効/無効
	 * @return 有効/無効
	 ------------------------------*/
	property vertical {
		getter {
			return verticalBar.visible;
		}
		setter(v) {
			// パラメータ更新
			verticalBar.visible = v;
			// 再レイアウト
			redrawContents();
		}
	}

	/**------------------------------
	 * 水平スクロールバーを画面に表示するかどうか
	 *
	 * @param v 表示/非表示
	 * @return 表示/非表示
	 ------------------------------*/
	property hideHorizontalBar {
		getter {
			return _hideHorizontalBar;
		}
		setter (v) {
			_hideHorizontalBar = v;
			redrawContents();
		}
	}

	/**------------------------------
	 * 垂直スクロールバーを画面に表示するかどうか
	 *
	 * @param v 表示/非表示
	 * @return 表示/非表示
	 ------------------------------*/
	property hideVerticalBar {
		getter {
			return _hideVerticalBar;
		}
		setter (v) {
			_hideVerticalBar = v;
			redrawContents();
		}
	}

	@if(0)
	/**------------------------------
	 * リサイズハンドルを表示するかどうか
	 *
	 * @param v 表示/非表示
	 * @return 表示/非表示
	 ------------------------------*/
	property resize {
		getter {
			return _resize;
		}
		setter(v) {
			// パラメータ更新
			_resize = v;
			// 再レイアウト
			redrawContents();
		}
	}
	@endif

	/**------------------------------
	 * childの表示幅
	 ------------------------------*/
	property childViewWidth {
		getter {
			return frame.width;
		}
	}
	/**------------------------------
	 * childの表示高さ
	 ------------------------------*/
	property childViewHeight {
		getter {
			return frame.height;
		}
	}
	/**------------------------------
	 * childの表示X座標
	 ------------------------------*/
	property childViewLeft {
		getter {
			return -child.left;
		}
		setter(l) {
			horizontalBar.targetPos = l;
			frame.setChildPos(-horizontalBar.targetPos, -verticalBar.targetPos);
		}
	}
	/**------------------------------
	 * childの表示Y座標
	 ------------------------------*/
	property childViewTop {
		getter {
			return -child.top;
		}
		setter(t) {
			verticalBar.targetPos = t;
			frame.setChildPos(-horizontalBar.targetPos, -verticalBar.targetPos);
		}
	}
	/**------------------------------
	 * childの実幅
	 ------------------------------*/
	property childWidth {
		getter {
			return child.width;
		}
	}
	/**------------------------------
	 * childの実高さ
	 ------------------------------*/
	property childHeight {
		getter {
			return child.height;
		}
	}

	/**------------------------------
	 * child view
------------------------------*/
	property childView {
		getter {
			return %[ vleft :childViewLeft,
					  vtop: childViewTop,
					  vwidth: childViewWidth,
					  vheight: childViewHeight,
					  width: childWidth,
					  height: childHeight ];
		}
	}

	/**------------------------------
	 * childの位置を設定する
	 ------------------------------*/
	function setChildViewPos(l, t) {
		horizontalBar.targetPos = l;
		verticalBar.targetPos = t;
		frame.setChildPos(-horizontalBar.targetPos, -verticalBar.targetPos);
	}

	/*------------------------------
	 * 再レイアウト
	 ------------------------------*/
	function onCalculateLayout() {
		if (! child)
			return;

		// ボックス(フレーム格納領域)のレンジを計算
		if (horizontal) {
			boxMinW = 0;
			boxMaxW = child.maxWidth + child.marginHorizontal;
			boxMaxW = int(Math.max(boxMinW, boxMaxW));
		} else {
			boxMinW = child.minWidth + child.marginHorizontal;
			boxMaxW = child.maxWidth + child.marginHorizontal;
		}

		if (vertical) {
			boxMinH = 0;
			boxMaxH = child.maxHeight + child.marginVertical;
			boxMaxH = int(Math.max(boxMinH, boxMaxH));
		} else {
			boxMinH = child.minHeight + child.marginVertical;
			boxMaxH = child.maxHeight + child.marginVertical;
		}

		boxMinW += borderPaddingWidth;
		boxMaxW += borderPaddingWidth;
		boxMinH += borderPaddingHeight;
		boxMaxH += borderPaddingHeight;

		// フレームのレンジを計算
		frameMinW = boxMinW - child.marginHorizontal - borderPaddingWidth;
		frameMinH = boxMinH - child.marginVertical - borderPaddingHeight;
		frameMaxW = boxMaxW - child.marginHorizontal - borderPaddingWidth;
		frameMaxH = boxMaxH - child.marginVertical - borderPaddingHeight;

		// 水平バーのレンジを計算
		horizontalBarMinW = boxMinW;
		horizontalBarMinH = horizontalBar.buttonWidth;
		horizontalBarMaxW = boxMaxW;
		horizontalBarMaxH = horizontalBar.buttonWidth;

		// 垂直バーのレンジを計算
		verticalBarMinW = verticalBar.buttonWidth;
		verticalBarMinH = boxMinH;
		verticalBarMaxW = verticalBar.buttonWidth;
		verticalBarMaxH = boxMaxH;

		// 全体のレンジを計算
		minW = boxMinW + (vertical ? verticalBar.buttonWidth : 0);
		minH = boxMinH + (horizontal ? horizontalBar.buttonWidth : 0);
		maxW = boxMaxW + (vertical ? verticalBar.buttonWidth : 0);
		maxH = boxMaxH + (horizontal ? horizontalBar.buttonWidth : 0);

		// フレームのレンジを設定
		frame.setMinMaxSize(frameMinW,
							frameMinH,
							frameMaxW,
							frameMaxH);
		// 水平バーのレンジを設定
		if (horizontal)
			horizontalBar.setMinMaxSize(horizontalBarMinW,
										horizontalBarMinH,
										horizontalBarMaxW,
										horizontalBarMaxH);
		// 垂直バーのレンジを設定
		if (vertical)
			verticalBar.setMinMaxSize(verticalBarMinW,
									  verticalBarMinH,
									  verticalBarMaxW,
									  verticalBarMaxH);

		if (horizontal
			&& hideHorizontalBar) {
			minH -= horizontalBar.height;
			maxH -= horizontalBar.height;
		}

		if (vertical
			&& hideVerticalBar) {
			maxW -= verticalBar.width;
			minW -= verticalBar.width;
		}

		setMinMaxSize(minW, minH, maxW, maxH);
	}

	/*------------------------------
	 * サイズ更新。
	 *
	 * スクロールバーを再描画する。
	 ------------------------------*/
	function onLocateLayout {
		if (! child)
			return;

		fillRect(0, 0, width, height, borderStyle.backgroundColor);

		// ボックスサイズ計算
		var boxW, boxH;
		boxW = width - ((vertical && ! hideVerticalBar) ? verticalBar.width : 0);
		boxH = height - ((horizontal && ! hideHorizontalBar) ? horizontalBar.height : 0);
		// box描画
		drawBorder(borderStyle, 0, 0, width, height);
		// フレーム再配置
		var frameW, frameH;
		frameW = boxW - child.marginHorizontal - borderPaddingWidth;
		frameH = boxH - child.marginVertical - borderPaddingHeight;
		if (frameW == frame.width
			&& frameH == frame.height)
			frame.onSizeModified(frameW, frameH, frameW, frameH);
		else
			frame.setSize(frameW, frameH);
		frame.setPos(child.marginLeft + borderPaddingLeft, child.marginTop + borderPaddingTop);

		// 水平バー再配置
		if (horizontal) {
			horizontalBar.setSize(frameW, horizontalBar.buttonWidth);
			horizontalBar.setPos(borderPaddingLeft, height - borderPaddingBottom - horizontalBar.height);
			horizontalBar.setTargetSize(child.width,
										int(Math.min(child.width, frame.width)),
										- child.left);
		}
		// 垂直バー再配置
		if (vertical) {
			verticalBar.setSize(verticalBar.buttonWidth, frameH);
			verticalBar.setTargetSize(child.height,
									  int(Math.min(child.height, frame.height)),
									  - child.top);
			verticalBar.setPos(width - borderPaddingRight - verticalBar.width, borderPaddingTop);
		}

		onChildViewModified(childViewLeft, childViewTop, childViewWidth, childViewHeight, childWidth, childHeight);
	}

	/*------------------------------
	 * スクロールバーの値更新を検出、
	 * 子ウィジェットをスクロールさせる
	 ------------------------------*/
	function onChildValueModified(child, value) {
		switch (child.name) {
			// その他の通知はそのまま上位ウィジェットへ転送する
		default:
			super.onChildValueModified(...);
			break;
			// 水平バー反映
		case "_horizontal":
			frame.setChildPos(- value, this.child.top);
			onChildViewModified(childViewLeft, childViewTop, childViewWidth, childViewHeight, childWidth, childHeight);
			break;
			// 垂直バー反映
		case "_vertical":
			frame.setChildPos(this.child.left, - value);
			onChildViewModified(childViewLeft, childViewTop, childViewWidth, childViewHeight, childWidth, childHeight);
			break;
		}
	}

	function onHoverMouseWheel(shift, delta, x, y) {
		var increment;
		if (! (shift & ssCtrl))
			increment = - delta * widgetStyle.mouseWheelFactor;
		else
			increment = - delta * widgetStyle.accelMouseWheelFactor;
		var props;
		if (! (shift & ssShift))
			props = [ "vertical", "horizontal" ];
		else
			props = [ "horizontal", "vertical" ];
		var processed = false;
		for (var i = 0; i < props.count; i++) {
			var prop = props[i];
			if (this[prop]) {
				var bar = this[prop + "Bar" ];
				if (bar.enabled) {
					bar.offsetTargetPos(increment);
					processed = true;
					break;
				}
			}
		}
		if (! processed) {
			super.onHoverMouseWheel(shift, delta, x, y);
		}
	}

	function onChildNoticeRect(child, l, t, w, h) {
		var prevChildView = childView;

		var targetLeft, targetTop;
		if (horizontalBar) {
			targetLeft = horizontalBar.targetPos;
			if (targetLeft + frame.width < l + w)
				targetLeft = l + w - frame.width;
			if (l < targetLeft)
				targetLeft = l;
			horizontalBar.targetPos = targetLeft;
		}
		if (verticalBar) {
			targetTop = verticalBar.targetPos;
			if (targetTop + frame.height < t + h)
				targetTop = t + h - frame.height;
			if (t < targetTop)
				targetTop = t;
			verticalBar.targetPos = targetTop;
		}
		frame.setChildPos(- horizontalBar.targetPos, - verticalBar.targetPos);

		if (! equalStruct(prevChildView, childView))
			onChildViewModified(childViewLeft, childViewTop, childViewWidth, childViewHeight, childWidth, childHeight);
	}

	function onChildViewModified(childViewLeft, childViewTop, childViewWidth, childViewHeight, childWidth, childHeight) {
	}

	property clickBlankToPageScroll
	{
		getter { return verticalBar.clickBlankToPageScroll; }
		setter(v) { verticalBar.clickBlankToPageScroll = horizontalBar.clickBlankToPageScroll = +v; }
	}

	property cursorToScroll
	{
		getter { return _cursorToScroll; }
		setter(v) {
			if(+v)
			{
				var chgHitThreshold = function(p, ht, func) {
					p.hitThreshold = ht;
					for(var i=0; i<p.children.count; i++)
						func(p.children[i], ht, func);
				};
				chgHitThreshold(frame, 256, chgHitThreshold); // frame 以下のレイヤーを全てカーソルイベント透過にしてしまう
			}
			_cursorToScroll = +v;
		}
	}

	function onMouseDown(x, y, button, shift) {
		if(cursorToScroll && button == mbLeft) {
			lastCursorX = x;
			lastCursorY = y;
		}
	}

	function onMouseMove(x, y) {
		if(lastCursorX !== void) {
			var mv = x - lastCursorX;
			childViewLeft -= mv;
			lastCursorX += mv;
			mv = y - lastCursorY;
			childViewTop -= mv;
			lastCursorY += mv;
		}
	}

	function onMouseUp(x, y, button, shift) {
		if(button == mbLeft) {
			lastCursorX = lastCursorY = void;
		}
	}
};
