//
// $Id: KSpliterLayout.tjs,v 1.2 2007/09/11 15:40:56 m2 Exp $
//


/*----------------------------------------------------------------------
 * スプリッタシャッタートグル
 ----------------------------------------------------------------------*/
class KSpliterShutterToggle extends KImageButton
{
	var _direction = 0;

	function KSpliterShutterToggle {
		super.KImageButton(...);
		cursor = crHandPoint;
		addCustomStyleState("backward");
	}

	property direction {
		getter {
			return _direction;
		}
		setter (v) {
			if (v == _direction)
				return;
			_direction = v;
			if (_direction == 0)
				addRemoveCustomStyleState("backward", "forward");
			else
				addRemoveCustomStyleState("forward", "backward");
		}
	}
};

/*----------------------------------------------------------------------
 * スプリッタハンドル
 ----------------------------------------------------------------------*/
class KSpliterHandle extends KEntity
{
	function KSpliterHandle() {
		super.KEntity(...);
		hitThreshold = 0;
	}

	function onMouseDown(x, y, button, shift) {
		super.onMouseDown(...);
		parent.onHandleMouseDown(x + left, y + top, button, shift);
	}

	function onMouseMove(x, y, shift) {
		super.onMouseMove(...);
		parent.onHandleMouseMove(x + left, y + top, shift);
	}

	function onMouseUp(x, y, button, shift)  {
		super.onMouseUp(...);
		parent.onHandleMouseUp(x + left, y + top, button, shift);
	}

	function onDrawContents() {
		drawBorder(borderStyle, 0, 0, width, height);
	}

}

/**----------------------------------------------------------------------
 * 水平スプリッター
 ----------------------------------------------------------------------*/
global.KSpliterLayoutArgsFormat =
	[
			%[ key: "name", defaultValue: "" ]
	];

global.KSpliterLayoutWidgetStyleDefinition =
	[
		[ "handleSize", "handleSize", 5 ],
		[ "handleId", "handleId", "" ],
		[ "shutterToggleId", "shutterToggleId", "" ]
	];

class KSpliterLayout extends KLayout
{
	var childList;
	var spliterHandle;
	var shutterToggle;
	var redrawn;
	var childMinW, childMinH, childMaxW, childMaxH;
	var _splitRatio = 0.5;
	var _splitAlignment = ALIGN_CENTER;
	var firstSplit;
	var dragging;
	var baseX, curL, curR, curX;
	var dict;
	var _shutterEnabled = false;
	var _shutterOpened = true;
	var _shutterIndex = 0;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KSpliterLayout(window, *) {
		var opts = parseOldStyleWidgetArgs(KSpliterLayoutArgsFormat, *);
		super.KLayout(window, opts);
		childList = [];
		spliterHandle = new KSpliterHandle(window, 0, 0);
		spliterHandle.hitThreshold = 0;
		spliterHandle.cursor = handleCursor;
		spliterHandle.parent = this;
		_splitRatio = getOption("splitRatio", 0.5);
		_splitAlignment = getOption("splitAlignment", ALIGN_CENTER);
		shutterEnabled = getOption("shutterEnabled", false);
		shutterIndex = getOption("shutterIndex", 0);
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KSpliterLayoutWidgetStyleDefinition);
		}
	}
	/*------------------------------
	 * 辞書登録
	 ------------------------------*/
	function onUnserialize(dict, key) {
		splitRatio =    dict.init(key + "_split_ratio", splitRatio);
		shutterOpened = dict.init(key + "_shutter_opened", true);
	}

	function onSerialize(dict, key) {
		dict.set(key + "_split_ratio", splitRatio);
		dict.set(key + "_shutter_opened", shutterOpened);
	}

	/**------------------------------
	 * 分割率
	 *
	 * @param v 分割率(0.0〜1.0)
	 * @return 分割率
	 ------------------------------*/
	property splitRatio {
		getter {
			return _splitRatio;
		}
		setter(v) {
			if (_splitRatio == v)
				return;
			_splitRatio = v;
			firstSplit = true;
			redrawContents();
		}
	}

	/**------------------------------
	 * 分割アライメント
	 *
	 * ウィジェットの拡大縮小時に、どちらのペインをメインに見るか。
	 * ALIGN_LEFT,ALIGN_CENTER,ALIGN_RIGHTのいずれかを指定する。
	 *
	 * @param アライメント
	 * @return アライメント
	 ------------------------------*/
	property splitAlignment {
		getter {
			return _splitAlignment;
		}
		setter(v) {
			if (_splitAlignment == v)
				return;
			_splitAlignment = v;
		}
	}

	/**------------------------------
	 * 子ウィジェットを追加する
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		childList.add(child);
		child.parent = this;
		firstSplit = true;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを解放する
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		childList.remove(child);
		child.parent = widgetDepot;
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}


	property HANDLE_SIZE {
		getter {
			return widgetStyle.handleSize;
		}
	}

	property shutterOpened {
		getter {
			return _shutterOpened;
		}
		setter(v) {
			if (_shutterOpened == v)
				return;
			_shutterOpened = v;
			redrawContents();
	}
	}

	property shutterEnabled {
		getter {
			return _shutterEnabled;
		}
		setter(v) {
			if (_shutterEnabled == v)
				return;
			_shutterEnabled = v;
			if (shutterToggle == void) {
				shutterToggle = new KSpliterShutterToggle(window, %[ name: "_shutterToggle", focusable: false ]);
				shutterToggle.parent = this;
			}
			shutterToggle.visible = v;
			redrawContents();
		}
	}

	property shutterIndex {
		getter {
			return _shutterIndex;
		}
		setter(v) {
			if (_shutterIndex == v)
				return;
			_shutterIndex = v;
			redrawContents();
		}
	}

	property spliterActive {
		getter {
			return shutterOpened;
		}
	}

	function invalidateHandleCursor() {
		if (spliterActive)
			spliterHandle.cursor = handleCursor;
		else
			spliterHandle.cursor = void;
	}

	function setSuitableSplitRatio(w0, w1) {
		var w, l, r;
		w = w0 + w1;
		l = int(Math.max(myChildMinW(0), w - myChildMaxW(1)));
		r = int(Math.min(myChildMaxW(0), w - myChildMinW(1)));
		splitRatio = (w0 - l) / (r - l);
	}

	function onChildValueModified(child, newValue, oldValue) {
		switch (child.name) {
		default:
			super.onChildValueModified(...);
			break;
		case "_shutterToggle":
			shutterOpened = ! shutterOpened;
			break;
		}
	}

	// 子の配置
	function embedChild(x, y, w, h, child) {
		if (child instanceof "KSpliterLayout") {
			child.setSize(w - child.marginHorizontal, h - child.marginVertical);
			locateChild(x, y, w, h, child);
		} else {
			super.embedChild(...);
		}
	}

	// レイアウトのやり直し
	function onCalculateLayout {
		if (childList.count < 2)
			return;

		childMinW = [];
		childMinH = [];
		childMaxW = [];
		childMaxH = [];

		for (var i = 0; i < 2; i++) {
			var child = childList[i];
			if (! shutterOpened
				&& i == shutterIndex) {
				childMinW[i] = 0;
				childMinH[i] = 0;
				childMaxW[i] = 0;
				childMaxH[i] = 0;
			} else {
				childMinW[i] = child.minWidth + child.marginHorizontal;
				childMinH[i] = child.minHeight + child.marginVertical;
				childMaxW[i] = child.maxWidth + child.marginHorizontal;
				childMaxH[i] = child.maxHeight + child.marginVertical;
				if (child instanceof "KSpliterLayout") {
					childMinW[i] += borderPaddingWidth;
					childMinH[i] += borderPaddingWidth;
					childMaxW[i] += borderPaddingHeight;
					childMaxH[i] += borderPaddingHeight;
				}
			}
		}
		setMinMaxSize(calcMinMaxSize()*);
	}

	// 再描画
	function onLocateLayout {
		if (childList.count < 2)
			return;

		var w, l, r;
		w = myWidth() - HANDLE_SIZE;
		l = int(Math.max(myChildMinW(0), w - myChildMaxW(1)));
		r = int(Math.min(myChildMaxW(0), w - myChildMinW(1)));

		var w0 = l + int((r - l) * _splitRatio);
		var w1 = w - w0;

		for (var i = 0; i < 2; i++) {
			childList[i].visible = shutterOpened || (i != shutterIndex);
		}

		spliterHandle.id = widgetStyle.handleId;
		spliterHandle.hitThreshold = spliterActive ? 0 : 256;
		invalidateHandleCursor();

		locate(w0, w1);

		if (shutterEnabled) {
			shutterToggle.id = widgetStyle.shutterToggleId;
			shutterToggle.direction = shutterOpened ^ (shutterIndex == 0);
			shutterToggle.bringToFront();
			shutterToggle.setPos(spliterHandle.left + (spliterHandle.width - shutterToggle.width) / 2,
								 spliterHandle.top + (spliterHandle.height - shutterToggle.height) / 2);
		}
	}

	// サイズが変わった時の呼び出し
	function onSizeModified(newWidth, newHeight, oldWidth, oldHeight) {
		if (childList.count < 2)
			return;

		// アライメントに応じて、スプリッターの位置を補正
		if (firstSplit) {
			firstSplit = false;
		} else if (shutterOpened) {
			switch (_splitAlignment) {
			case ALIGN_LEFT: {
				var w, l, r;
				w = myWidth() - HANDLE_SIZE;
				l = int(Math.max(myChildMinW(0), w - myChildMaxW(1)));
				r = int(Math.min(myChildMaxW(0), w - myChildMinW(1)));
				if (r != l) {
					_splitRatio = (myChildWidth(0) - l) / (r - l);
					_splitRatio = Math.max(0, Math.min(1, _splitRatio));
				}
				break;
			}
			case ALIGN_RIGHT: {
				var w, l, r;
				w = myWidth() - HANDLE_SIZE;
				l = int(Math.max(myChildMinW(0), w - myChildMaxW(1)));
				r = int(Math.min(myChildMaxW(0), w - myChildMinW(1)));
				if (r != l) {
					_splitRatio = (w - myChildWidth(1) - l) / (r - l);
					_splitRatio = Math.max(0, Math.min(1, _splitRatio));
				}
				break;
			}
			}
		}
		onLocateLayout();
	}


	// マウスダウンでドラッグ開始
	function onHandleMouseDown(x, y, button) {
		if (childList.count < 2)
			return;

		if (! spliterActive)
			return;

		if (button != mbLeft)
			return;

		var w = myWidth() - HANDLE_SIZE;
		curL = int(Math.max(myChildMinW(0), w - myChildMaxW(1)));
		curR = int(Math.min(myChildMaxW(0), w - myChildMinW(1)));
		if (curL == curR)
			return;
		baseX = x;
		curX = myChildWidth(0) - curL;
		dragging = true;
	}

	// ドラッグしてスプリッタを移動
	function onHandleMouseMove(x, y) {
		if (! dragging)
			return;

		var diff = x - baseX;
		_splitRatio = (curX + (x - baseX)) / (curR - curL);
		_splitRatio = Math.max(0, Math.min(1, _splitRatio));
		onLocateLayout();
	}

	// ドラッグ終了
	function onHandleMouseUp {
		dragging = false;
	}
}


/**----------------------------------------------------------------------
 * 水平スプリッター
 ----------------------------------------------------------------------*/
class KHorizontalSpliterLayout extends KSpliterLayout
{
	function KHorizontalSpliterLayout() {
		super.KSpliterLayout(...);
	}

	function calcMinMaxSize {
		var result = [];
		result[0] = childMinW[0] + HANDLE_SIZE + childMinW[1];
		result[1] = int(Math.max(childMinH[0], childMinH[1]));
		result[2] = childMaxW[0] + HANDLE_SIZE + childMaxW[1];
		result[3] = int(Math.max(childMaxH[0], childMaxH[1]));
		return result;
	}

	function myWidth {
		return width;
	}

	function myChildMinW(index) {
		return childMinW[index];
	}

	function myChildMaxW(index) {
		return childMaxW[index];
	}

	function myChildWidth(index) {
		return childList[index].width;
	}

	function locate(w0, w1) {
		if (childList[0].visible) {
			embedChild(0, 0, w0, height, childList[0]);
		}
		spliterHandle.setFixedSize(HANDLE_SIZE, height);
		spliterHandle.setPos(w0, 0);
		if (childList[1].visible) {
			embedChild(w0 + HANDLE_SIZE, 0, w1, height, childList[1]);
		}
	}

	property handleCursor {
		getter {
			return crHSplit;
		}
	}

};

/**----------------------------------------------------------------------
 * 垂直スプリッター
 ----------------------------------------------------------------------*/
class KVerticalSpliterLayout extends KSpliterLayout
{
	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KVerticalSpliterLayout() {
		super.KSpliterLayout(...);
	}

	function calcMinMaxSize {
		var result = [];
		result[0] = int(Math.max(childMinW[0], childMinW[1]));
		result[1] = childMinH[0] + HANDLE_SIZE + childMinH[1];
		result[2] = int(Math.max(childMaxW[0], childMaxW[1]));
		result[3] = childMaxH[0] + HANDLE_SIZE + childMaxH[1];
		return result;
	}

	function myWidth {
		return height;
	}

	function myChildMinW(index) {
		return childMinH[index];
	}

	function myChildMaxW(index) {
		return childMaxH[index];
	}

	function myChildWidth(index) {
		return childList[index].height;
	}

	function locate(w0, w1) {
		if (childList[0].visible) {
			embedChild(0, 0, width, w0, childList[0]);
		}
		spliterHandle.setFixedSize(width, HANDLE_SIZE);
		spliterHandle.setPos(0, w0);
		if (childList[1].visible) {
			embedChild(0, w0 + HANDLE_SIZE, width, w1, childList[1]);
		}
	}

	property handleCursor {
		getter {
			return crVSplit;
		}
	}

	function onHandleMouseDown(x, y) {
		super.onHandleMouseDown(y, x);
	}

	function onHandleMouseMove(x, y) {
		super.onHandleMouseMove(y, x);
	}

	function onHandleMouseUp(x, y) {
		super.onHandleMouseUp(y, x);
	}
}
