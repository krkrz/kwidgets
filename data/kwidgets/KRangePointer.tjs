//
//
//

//----------------------------------------------------------------------
// 2Dレンジポインタ
global.KRangePointer2DWidgetStyleDefinition =
	[
		[ "knobId", "knobId" ],
		[ "innerBgId", "innerBgId", "" ],
		[ "innerKnobId", "innerKnobId", "" ]
	];
class KRangePointer2D extends KValueEntity
{
	var hParams, vParams;
	var paramsPair;
	var knob;
	var knobDragging = false;
	var dragBeganPos;
	var dragBeganValue;
	var autoDispatchStartInterval = void;
	var autoDispatchRepeatInterval = void;
	var autoDispatchTimer = void;
	var interp;
	var innerBg;
	var innerKnob;
	var innerMargin = %[ left: 0, right: 0, top: 0, bottom: 0 ];

	//------------------------------
	// コンストラクタ
	//------------------------------
	function KRangePointer2D(window, opts = %[]) {
		super.KValueEntity(window, opts);

		earlyUpdateWidgetStyle();

		hitThreshold = 0;

		hParams = %[];
		vParams = %[];
		paramsPair = [ hParams, vParams ];
		var prefixes = [ "h", "v" ];

		for (var i = 0; i < paramsPair.count; i++) {
			var params = paramsPair[i];
			var prefix = prefixes[i];
			params.baseLogicalLeft = getOption(prefix + "Left", 0);
			params.baseLogicalRight = getOption(prefix + "Right", 1);
			params.baseLogicalMin = Math.min(params.baseLogicalLeft, params.baseLogicalRight);
			params.baseLogicalMax = Math.max(params.baseLogicalLeft, params.baseLogicalRight);
			params.baseLogicalSize = params.baseLogicalMax - params.baseLogicalMin;
			params.baseLogicalSign = (params.baseLogicalRight - params.baseLogicalLeft) / params.baseLogicalSize;

			params.knobLogicalSize = getOption(prefix + "KnobSize", params.baseLogicalSize);
			params.knobLogicalStride = getOption(prefix + "KnobStride", 0);
			params.knobLogicalBlockStride = getOption(prefix + "KnobBlockStride", int((params.knobLogicalSize * 0.9) / params.knobLogicalStride) * params.knobLogicalStride);
			params.knobFixedPixelSize = getOption(prefix + "KnobPixelSize", void);

			params.knobLogicalLeft = params.baseLogicalLeft;
			params.knobLogicalRight = params.baseLogicalLeft + params.baseLogicalSign * (params.baseLogicalSize - params.knobLogicalSize);
			params.knobLogicalMin = Math.min(params.knobLogicalLeft, params.knobLogicalRight);
			params.knobLogicalMax = Math.max(params.knobLogicalLeft, params.knobLogicalRight);
			params.isIntValue
				= int(params.baseLogicalMin) == params.baseLogicalMin
				&& int(params.baseLogicalMax) == params.baseLogicalMax
				&& int(params.knobLogicalStride) == params.knobLogicalStride;
			params.pointerValue = params.baseLogicalLeft;
		}

		autoDispatchStartInterval = getOption("autoDispatchStartInterval", 200);
		autoDispatchRepeatInterval = getOption("autoDispatchRepeatInterval", 16);

		if (autoDispatchStartInterval !== void
			&& autoDispatchRepeatInterval !== void) {
			autoDispatchTimer = new Timer(this, "dispatchMouseDownEvent");
			autoDispatchTimer.capcaity = 1;
		}

		var knobId = getOption("knobId", "range_pointer_2d_knob");
		knob = new KSpacer(window, %[ name: "_knob",
									  id: widgetStyle.knobId,
									  lockStyleModificationOnAttach: true,
									]);
		knob.hitThreshold = 0;
		knob.parent = this;
		knob.onSpacerMouseUp = onKnobMouseUp;
		knob.onSpacerMouseMove = onKnobMouseMove;
		knob.onSpacerMouseDown = onKnobMouseDown;

		if (getOption("interpolation", false)) {
			interp = new KInterpolateDispatcher(this, %[ valueName: "_value",
														 lerpFunction: function(a, b, t) { return %[ h: a.h + (b.h - a.h) * t, v: a.v + (b.v - a.v) * t ]; } ]);
			interp.onStart = _onStartInterpolation;
			interp.onStop = _onStopInterpolation;
		}
	}

	function finalize {
		invalidate autoDispatchTimer;
		invalidate interp;
		super.finalize();
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KRangePointer2DWidgetStyleDefinition);
		}
	}

	property pointerValue {
		getter {
			return %[ h: hParams.pointerValue, v: vParams.pointerValue ];
		}
		setter (val) {
			hParams.newPointerValue = val.h;
			vParams.newPointerValue = val.v;
			standarizeNewPointerValue(hParams);
			standarizeNewPointerValue(vParams);
			val = %[ h: hParams.newPointerValue, v: vParams.newPointerValue ];
			if (equalStructNumericLoose(pointerValue, val))
				return;
			hParams.pointerValue = val.h;
			vParams.pointerValue = val.v;
			redrawContents();
		}
	}

	property _value {
		getter {
			return pointerValue;
		}
		setter(v) {
			pointerValue = v;
		}
	}

	property value {
		getter {
			return _value;
		}
		setter (v) {
			_value = v;
		}
	}

	function _interpolate(value) {
		interp.interpolate(value);
	}

	function interpolate(value) {
		_interpolate(value);
	}

	property _completedValue {
		getter {
			return interp.completedValue;
		}
	}

	property completedValue {
		getter {
			return _completedValue;
		}
	}

	function _onStartInterpolation() {
		onStartInterpolation();
	}

	function _onStopInterpolation() {
		onStopInterpolation();
	}

	function onStartInterpolation() {
	}

	function onStopInterpolation() {
	}

	//------------------------------
	// レンジの更新
	//------------------------------
	function updateLogicalRange(prefix, baseLeft, baseRight, knobSize) {
		var params;
		switch (prefix) {
		case "h": params = hParams; break;
		case "v": params = vParams; break;
		}
		params.baseLogicalLeft = baseLeft;
		params.baseLogicalRight = baseRight;
		params.knobLogicalSize = knobSize;
		params.baseLogicalMin = Math.min(params.baseLogicalLeft, params.baseLogicalRight);
		params.baseLogicalMax = Math.max(params.baseLogicalLeft, params.baseLogicalRight);
		params.baseLogicalSize = params.baseLogicalMax - params.baseLogicalMin;
		params.baseLogicalSign = (params.baseLogicalRight - params.baseLogicalLeft) / params.baseLogicalSize;
		params.knobLogicalLeft = params.baseLogicalLeft;
		params.knobLogicalRight = params.baseLogicalLeft + params.baseLogicalSign * (params.baseLogicalSize - params.knobLogicalSize);
		params.knobLogicalMin = Math.min(params.knobLogicalLeft, params.knobLogicalRight);
		params.knobLogicalMax = Math.max(params.knobLogicalLeft, params.knobLogicalRight);
		params.knobLogicalBlockStride = getOption(prefix + "KnobBlockStride", int((params.knobLogicalSize * 0.9) / params.knobLogicalStride) * params.knobLogicalStride);
		params.isIntValue
			= int(params.baseLogicalMin) == params.baseLogicalMin
			&& int(params.baseLogicalMax) == params.baseLogicalMax
			&& int(params.knobLogicalStride) == params.knobLogicalStride;

		params.newPointerValue = params.pointerValue;
		standarizeNewPointerValue(params);
		params.pointerValue = params.newPointerValue;

		redrawContents();
	}

	//---------------------------------------
	// パラメータ丸め込み
	//---------------------------------------
	function standarizeNewPointerValue(params) {
		var newValue = params.newPointerValue;
		newValue = Math.max(params.knobLogicalMin, Math.min(params.knobLogicalMax, newValue));
		newValue = Math.round(newValue / params.knobLogicalStride) * params.knobLogicalStride;
		if (params.isIntValue)
			newValue = int(newValue);
		params.newPointerValue = newValue;
	}
	
	//------------------------------
	// ノブサイズを更新
	//------------------------------
	property knobFixedWidth {
		getter {
			return hParams.knobFixedPixelSize;
		}
		setter(v) {
			hParams.knobFixedPixelSize = v;
		}
	}

	property knobFixedHeight {
		getter {
			return vParams.knobFixedPixelSize;
		}
		setter(v) {
			vParams.knobFixedPixelSize = v;
		}
	}

	//------------------------------
	// 描画
	//------------------------------
	function onDrawContents() {
		if (widgetStyle.knobWidth !== void)
			hParams.knobFixedPixelSize = widgetStyle.knobWidth;
		if (widgetStyle.knobHeight !== void)
			vParams.knobFixedPixelSize = widgetStyle.knobHeight;

		knob.id = widgetStyle.knobId;

		innerMargin.width = innerMargin.left + innerMargin.right;
		innerMargin.height = innerMargin.top + innerMargin.bottom;

		drawBorder(borderStyle, innerMargin.left, innerMargin.top, width - innerMargin.width, height - innerMargin.height);

		hParams.rangePixelMin = borderPaddingLeft + innerMargin.left;
		hParams.rangePixelSize = width - (borderPaddingWidth + innerMargin.width);
		vParams.rangePixelMin = borderPaddingTop + innerMargin.top;
		vParams.rangePixelSize = height - (borderPaddingHeight + innerMargin.height);

		for (var i = 0; i < paramsPair.count; i++) {
			var params = paramsPair[i];
			
			params.knobPixelSize = (params.knobFixedPixelSize !== void)
				? params.knobFixedPixelSize
				: int(params.rangePixelSize * params.knobLogicalSize / params.baseLogicalSize);

			params.knobPixelOperationAreaSize = params.rangePixelSize - params.knobPixelSize;

			params.knobPixelPos = params.rangePixelMin;
			if (params.knobPixelOperationAreaSize > 0) {
				params.knobPixelPos +=
					params.knobPixelOperationAreaSize  
					* (params.pointerValue - params.knobLogicalLeft)
					/ (params.knobLogicalRight - params.knobLogicalLeft);
			}
		}

		knob.setPos(hParams.knobPixelPos, vParams.knobPixelPos);
		knob.setFixedSize(hParams.knobPixelSize, vParams.knobPixelSize);
		knob.unlockStyleModification();
		
		if (widgetStyle.innerBgId == "") {
			if (innerBg !== void)
				innerBg.visible = false;
		} else {
			if (innerBg === void){
				innerBg = new KSpacer(window, %[ id: widgetStyle.innerBgId, name: "_innerBg", lockStyleModificationOnAttach: true ]);
				innerBg.lockStyleModification();
				innerBg.setMinMaxSize(0, 0, K_WIDGET_MAX_POSSIBLE_WIDTH, K_WIDGET_MAX_POSSIBLE_WIDTH);
				innerBg.hitThreshold = 256;
				innerBg.parent = this;
				innerBg.absolute = -1;
			} else {
				innerBg.lockStyleModification();
			}
			innerBg.id = widgetStyle.innerBgId;
			innerBg.visible = true;
			embedChild(innerMargin.left, innerMargin.top, width - innerMargin.width, height - innerMargin.height, innerBg);
			innerBg.unlockStyleModification();
		}

		if (widgetStyle.innerKnobId == "") {
			if (innerKnob !== void)
				innerKnob.visible = false;
		}else {
			if (innerKnob === void) {
				innerKnob = new KImageLabel(window, %[ id: widgetStyle.innerKnobId, name: "_innerKnob", lockStyleModificationOnAttach: true ]);
				innerKnob.lockStyleModification();
				innerKnob.hitThreshold = 256;
				innerKnob.parent = this;
				innerKnob.absolute = 2;
			} else
				innerKnob.lockStyleModification();
			innerKnob.id = widgetStyle.innerKnobId;
			innerKnob.visible = true;
			innerKnob.setPos(knob.left + knob.width / 2 - innerKnob.width / 2,
							 knob.top + knob.height / 2 - innerKnob.height / 2);
			innerKnob.unlockStyleModification();
		}
	}

	//------------------------------
	// オートディスパッチを処理する
	// ------------------------------
	function fireAutoDispatch() {
		if (autoDispatchTimer !== void) {
			if (! autoDispatchTimer.enabled) {
				autoDispatchTimer.interval = autoDispatchStartInterval;
				autoDispatchTimer.enabled = true;
			} else {
				autoDispatchTimer.interval = autoDispatchRepeatInterval;
			}
		}
	}

	function stopAutoDispatch() {
		if (autoDispatchTimer !== void)
			autoDispatchTimer.enabled = false;
	}    

	//------------------------------
	// マウスイベント
	//------------------------------
	function onKnobMouseUp(x, y) {
		if (! knobDragging)
			return;
		knobDragging = false;
	}

	function onMouseDown(x, y) {
		super.onMouseDown(...);

		focus();
		dispatchMouseDownEvent();
	}

	function onMouseUp() {
		super.onMouseUp(...);
		stopAutoDispatch();
	}

	//------------------------------
	// マウス押下イベントを発火する
	//------------------------------
	function dispatchMouseDownEvent() {
		fireAutoDispatch();

		hParams.cursor = cursorX;
		vParams.cursor = cursorY;

		if (interp === void) {
			hParams.newPointerValue = hParams.pointerValue;
			vParams.newPointerValue = vParams.pointerValue;
		} else {
			var comp = _completedValue;
			hParams.newPointerValue = comp.h;
			vParams.newPointerValue = comp.v;
		}

		for (var i = 0; i < paramsPair.count; i++) {
			var params = paramsPair[i];
			if (params.knobPixelOperationAreaSize > 0) {
				if (params.cursor < params.knobPixelPos) 
					params.newPointerValue -= params.baseLogicalSign * params.knobLogicalBlockStride;
				else if (params.cursor >= params.knobPixelPos + params.knobPixelSize)
					params.newPointerValue += params.baseLogicalSign * params.knobLogicalBlockStride;
				standarizeNewPointerValue(params);
			} 
		}

		var newPointerValue = %[ h: hParams.newPointerValue, v: vParams.newPointerValue ];

		if (equalStructNumericLoose(newPointerValue, pointerValue)) {
			stopAutoDispatch();
			return;
		}

		if (interp === void) {
			pointerValue = newPointerValue;
			dispatch();
		} else {
			_interpolate(newPointerValue);
		}
	}

	//------------------------------
	// ノブのマウスイベント
	//------------------------------
	function onKnobMouseDown(x, y) {
		focus();
		knobDragging = true;
		hParams.dragBeganCursor = x + knob.left;
		vParams.dragBeganCursor = y + knob.top;
		dragBeganValue = pointerValue;
	}

	function onKnobMouseMove(x, y) {
		if (! knobDragging)
			return;

		hParams.cursor = x + knob.left;
		vParams.cursor = y + knob.top;

		hParams.newPointerValue = dragBeganValue.h;
		vParams.newPointerValue = dragBeganValue.v;

		for (var i = 0; i < paramsPair.count; i++) {
			var params = paramsPair[i];

			if (params.knobPixelOperationAreaSize > 0) {
				var ofst = params.cursor - params.dragBeganCursor;
				params.newPointerValue += params.baseLogicalSign * (ofst / params.knobPixelOperationAreaSize) * (params.baseLogicalSize - params.knobLogicalSize);
				standarizeNewPointerValue(params);
			}
		}

		pointerValue = %[ h: hParams.newPointerValue, v: vParams.newPointerValue ];
		dispatch();
	}

	//------------------------------
	// キーダウンイベント
	//------------------------------
	function onKeyDown(key, shift) {
		var operations = [
				%[ key: VK_LEFT,  params: hParams, dir: -1 ],
				%[ key: VK_RIGHT, params: hParams, dir: +1 ],
				%[ key: VK_UP,    params: vParams, dir: -1 ],
				%[ key: VK_DOWN,  params: vParams, dir: +1 ]
		];

		for (var i = 0; i < operations.count; i++) {
			var operation = operations[i];
			var params = operation.params;
			if (key == operation.key
				&& params.knobPixelOperationAreaSize > 0) {
				params.newPointerValue = params.pointerValue + operation.dir * params.baseLogicalSign * params.knobLogicalStride;
				standarizeNewPointerValue(params);
				if (params.pointerValue != params.newPointerValue) {
					params.pointerValue = params.newPointerValue;
					redrawContents();
					dispatch();
				}
				return;
			}
		}

		super.onKeyDown(...);
	}

	//------------------------------
	// フォーカスイベント
	//------------------------------
	function onFocus() {
		super.onFocus();
		if (innerBg !== void)
			innerBg.addCustomStyleState("focus");
	}

	function onBlur() {
		super.onBlur();
		if (innerBg !== void)
			innerBg.removeCustomStyleState("focus");
	}

};
