//
// $Id$
//

/*----------------------------------------------------------------------
 * XYセレクタ
 ----------------------------------------------------------------------*/
class KColorPickerXYSelecter extends KValueWidget
{
	var cursorLayer;
	var dragging;
	var value;
	var hasAlpha;
	var cache;

	function KColorPickerXYSelecter(window, name, hasAlpha) {
		super.KValueWidget(window, name);
		this.hasAlpha = hasAlpha;
		setFixedSize(256, 256);
		cursorLayer = new global.Layer(window, this);
		cursorLayer.visible = true;
		cursorLayer.hitThreshold = 256;
		cursor = crCross;
		fillChecker(8);
	}

	function getLuminance(x, y, cs, c0, c1, c2, c3) {
		cs |= csNonCyclic;
		c0 = ColorSpace.convertColorTuple(csRGB, cs, c0);
		c1 = ColorSpace.convertColorTuple(csRGB, cs, c1);
		c2 = ColorSpace.convertColorTuple(csRGB, cs, c2);
		c3 = ColorSpace.convertColorTuple(csRGB, cs, c3);
		var c01 = ColorSpace.lerpColorTuple(cs, c0, c1, x);
		var c23 = ColorSpace.lerpColorTuple(cs, c2, c3, x);
		var color = ColorSpace.lerpColorTuple(cs, c01, c23, y);
		var hsc = ColorSpace.convertColorTuple(cs, csHCL, color);
		return hsc[2];
	}

	function draw(x, y, cs, c0, c1, c2, c3) {
		fillChecker(8);
		colorGradientRectCorners(0, 0, width, height, c0, c1, c2, c3, cs | csNonCyclic);
		drawCursor(x, y, getLuminance(x, y, cs, c0, c1, c2, c3));
	}

	function drawCursor(x, y, l) {
		x = int(x * (width - 1));
		y = int((1 - y) * (height - 1));
		if (l < 75)
			cursorLayer.loadImages("k_color_picker_xy_cursor_white");
		else
			cursorLayer.loadImages("k_color_picker_xy_cursor_black");
		cursorLayer.setSizeToImageSize();
		cursorLayer.setPos(x - int(cursorLayer.width / 2),
						   y - int(cursorLayer.height / 2));
	}

	function onMouseDown(x, y, button) {
		super.onMouseDown(...);
		if (button == mbLeft) {
			dragging = true;
			applyValue(x, y);
		}
	}

	function onMouseMove(x, y) {
		super.onMouseMove(...);
		if (dragging) {
			applyValue(x, y);
		}
	}

	function onMouseUp(x, y, button) {
		super.onMouseUp(...);
		if (dragging 
			&& button == mbLeft) {
			dragging = false;
		}
	}

	function applyValue(x, y) {
		value = [ Math.min(1, Math.max(0, x / (width - 1))),
				  Math.min(1, Math.max(0, 1 - y / (height - 1))) ];
		invalidateValue();
	}
}

/*----------------------------------------------------------------------
 * Zセレクタ
 ----------------------------------------------------------------------*/
class KColorPickerZSelecter extends KValueWidget
{
	var cursorLayer;
	var dragging;
	var value;
	var hasAlpha;
	var cache;

	function KColorPickerZSelecter(window, name, hasAlpha) {
		super.KWidget(window, name);
		setFixedSize(16, 256);
		this.hasAlpha = hasAlpha;
		cursorLayer = new global.Layer(window, this);
		cursorLayer.visible = true;
		cursorLayer.hitThreshold = 256;
		cursorLayer.loadImages("k_color_picker_z_cursor");
		cursorLayer.setSizeToImageSize();
		fillChecker(8);
	}

	function draw(y, cs, c0, c1) {
		fillChecker(8);
		colorGradientRectUD(0, 0, width, height, c0, c1, cs | csNonCyclic);
		drawCursor(y);
	}

	function drawCursor(y) {
		y = int((1 - y) * (height - 1));
		cursorLayer.setPos(0, y -  int(cursorLayer.height / 2));
	}

	function onMouseDown(x, y, button) {
		super.onMouseDown(...);
		if (button == mbLeft) {
			dragging = true;
			applyValue(y);
		}
	}

	function onMouseMove(x, y) {
		super.onMouseMove(...);
		if (dragging) {
			applyValue(y);
		}
	}

	function onMouseUp(x, y, button) {
		super.onMouseUp(...);
		if (dragging 
			&& button == mbLeft) {
			dragging = false;
		}
	}

	function applyValue(y) {
		value = Math.min(1, Math.max(0, 1 - y / (height - 1)));
		invalidateValue();
	}
}

/*----------------------------------------------------------------------
 * αセレクタ
 ----------------------------------------------------------------------*/
class KColorPickerAlphaSelecter extends KValueWidget
{
	var cursorLayer;
	var dragging;
	var value;
	var cache;

	function KColorPickerAlphaSelecter(window, name) {
		super.KWidget(window, name);
		setFixedSize(16, 256);
		cursorLayer = new global.Layer(window, this);
		cursorLayer.visible = true;
		cursorLayer.hitThreshold = 256;
		cursorLayer.loadImages("k_color_picker_z_cursor");
		cursorLayer.setSizeToImageSize();
		fillChecker(8);
	}

	function draw(y, cs, c0, c1) {
		fillChecker(8);
		colorGradientRectUD(0, 0, width, height, c0, c1, cs | csNonCyclic);
		drawCursor(y);
	}

	function drawCursor(y) {
		y = int((1 - y) * (height - 1));
		cursorLayer.setPos(0, y -  int(cursorLayer.height / 2));
	}

	function onMouseDown(x, y, button) {
		super.onMouseDown(...);
		if (button == mbLeft) {
			dragging = true;
			applyValue(y);
		}
	}

	function onMouseMove(x, y) {
		super.onMouseMove(...);
		if (dragging) {
			applyValue(y);
		}
	}

	function onMouseUp(x, y, button) {
		super.onMouseUp(...);
		if (dragging 
			&& button == mbLeft) {
			dragging = false;
		}
	}

	function applyValue(y) {
		value = Math.min(1, Math.max(0, 1 - y / (height - 1)));
		invalidateValue();
	}
}

/*----------------------------------------------------------------------
 * カラーボックス
 ----------------------------------------------------------------------*/
class KColorPickerColorBox extends KColorBox
{
	function KColorPickerColorBox(window, w, h, name) {
		super.KColorBox(...);
	}

	function onMouseDown(x, y, key) {
		if (key == mbLeft)
			invalidateValue();
	}
}

/**----------------------------------------------------------------------
 * カラーピッカー
 ----------------------------------------------------------------------*/
class KColorPickerDialog extends KWindow
{
	var canceled = true;
	var color, prevColor;
	var hasAlpha;
	var dict;
	var mode;
	var alpha;
	var notifyFunc;
	var primaryColorSpace = %[ cs: csRGB, components: [ %[ label: "R", postfix: "" ], %[ label: "G", postfix: "" ], %[ label: "B", postfix: "" ] ] ];
	var secondaryColorSpace;
	var secondaryColorSpaces = [
		%[ cs: csHSV, components: [ %[ label: "H", postfix: "°" ], %[ label: "S", postfix: "％" ], %[ label: "V", postfix: "％" ] ] ],
		%[ cs: csHSL, components: [ %[ label: "H", postfix: "°" ], %[ label: "S", postfix: "％" ], %[ label: "L", postfix: "％" ] ] ],
		%[ cs: csHCL, components: [ %[ label: "H", postfix: "°" ], %[ label: "C", postfix: "％" ], %[ label: "L", postfix: "％" ] ] ]
	];

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param color カラー
	 * @param hasAlpha アルファを持っているか？
	 * @param dict カラーピッカーの位置を保存する辞書
	 ------------------------------*/
	function KColorPickerDialog(color, hasAlpha = false, dict = void, notifyFunc = function() {}, name = "colorPicker") {
		super.KWindow(%[ theme: "dialog", name: name ]);

		caption = getOption("caption", "カラーピッカー");
		borderStyle = bsDialog;

		this.color = prevColor = color;
		this.hasAlpha = hasAlpha;
		this.dict = dict;
		this.notifyFunc = notifyFunc;
		mode = "s0";

		completeColorSpaces();
		secondaryColorSpace = secondaryColorSpaces[0];

		primaryLayer.add(new KGridLayout(this, %[ name: "rootGrid", id: "widget_grid" ]));
		rootGrid.add(0, 0, new KGridLayout(this, %[ name: "selecterGrid", id: "widget_grid", style: %[ align: ALIGN_CENTER ] ]), 1, 2);
		selecterGrid.add(0, 0, new KFrameLayout(this, %[ name: "xyFrame" ]), 1, 2);
		xyFrame.add(new KColorPickerXYSelecter(this, "xySelecter", hasAlpha));
		selecterGrid.add(1, 0, new KFrameLayout(this, %[ name: "zFrame" ]), 1, 2);
		zFrame.add(new KColorPickerZSelecter(this, "zSelecter", hasAlpha));
		if (hasAlpha) {
			selecterGrid.add(2, 0, new KFrameLayout(this, %[ name: "alphaFrame" ]), 1, 2);
			alphaFrame.add(new KColorPickerAlphaSelecter(this, "alphaSelecter"));
		}
		rootGrid.add(1, 0, new KGridLayout(this, %[ name: "colorOuterGrid" ]));
		colorOuterGrid.add(0, 0, new KTextLabel(this, %[ label: "新しい色", style: %[ align: ALIGN_CENTER ] ]));
		colorOuterGrid.add(0, 1, new KFrameLayout(this, %[ name: "colorFrame" ]));
		colorOuterGrid.add(0, 2, new KTextLabel(this, %[ label: "現在の色", style: %[ align: ALIGN_CENTER  ] ]));
		colorFrame.add(new KGridLayout(this, %[ name: "colorGrid" ]));
		colorGrid.add(0, 0, new KColorPickerColorBox(this, 64, 32, "newColor"));
		colorGrid.add(0, 1, new KColorPickerColorBox(this, 64, 32, "oldColor"));
 
		rootGrid.add(1, 1, new KGridLayout(this, %[ name: "paramGrid", id: "widget_grid_narrow" ]));
		defaultAlignVertical = ALIGN_CENTER;
		paramGrid.add(0, 0, new KComboBox(this, %[ name: "colorSpaceSelect", width: 80, items: [ "HSV-RGB", 0, "HSL-RGB", 1, "HCL-RGB", 2 ], value: 0 ]), 3);
		paramGrid.add(0, 1, new KRadioButton(this, %[ label: "H:", name: "s0Select" ]));
		paramGrid.add(1, 1, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "s0Input" ]));
		paramGrid.add(2, 1, new KTextLabel(this, %[ label: "°", name: "s0Postfix"] ));
		paramGrid.add(0, 2, new KRadioButton(this, %[ label: "S:", name: "s1Select" ]));
		paramGrid.add(1, 2, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "s1Input" ]));
		paramGrid.add(2, 2, new KTextLabel(this, %[ label: "％", name: "s1Postfix" ]));
		paramGrid.add(0, 3, new KRadioButton(this, %[ label: "V:", name: "s2Select" ]));
		paramGrid.add(1, 3, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "s2Input"]));
		paramGrid.add(2, 3, new KTextLabel(this, %[ label: "％", name: "s2Postfix" ]));

		paramGrid.add(0, 5, new KRadioButton(this, %[ label: "R:", name: "p0Select" ]));
		paramGrid.add(1, 5, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "p0Input" ]));
		paramGrid.add(0, 6, new KRadioButton(this, %[ label: "G:", name: "p1Select" ]));
		paramGrid.add(1, 6, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "p1Input" ]));
		paramGrid.add(0, 7, new KRadioButton(this, %[ label: "B:", name: "p2Select" ]));
		paramGrid.add(1, 7, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "p2Input" ]));

		var textRow;
		if (hasAlpha) {
			paramGrid.add(0, 8, new KTextLabel(this, "A:", "aSelect"));
			paramGrid.add(1, 8, new KTextInput(this, %[ width: 30, type: TEXT_DIGIT, name: "aInput" ]));
			aSelect.alignHorizontal = ALIGN_RIGHT;
			textRow = 10;
		} else 
			textRow = 9;

		paramGrid.add(0, textRow, new KTextLabel(this, "#", "labelSharp"));
		labelSharp.alignHorizontal = ALIGN_RIGHT;
		paramGrid.add(1, textRow, new KTextInput(this, %[ width: 60, type: TEXT_ANY, name: "textInput" ]), 2, 1);

		s0Select.focusable = false;
		s1Select.focusable = false;
		s2Select.focusable = false;
		p0Select.focusable = false;
		p1Select.focusable = false;
		p2Select.focusable = false;

		s0Input.respondToValueModification = true;
		s1Input.respondToValueModification = true;
		s2Input.respondToValueModification = true;
		p0Input.respondToValueModification = true;
		p1Input.respondToValueModification = true;
		p2Input.respondToValueModification = true;
		if (hasAlpha)
			aInput.respondToValueModification = true;
		textInput.respondToValueModification = true;

		rootGrid.add(0, 2, new KGridLayout(this, %[ name: "buttonGrid", id: "button_grid" ]), 2, 1);
		buttonGrid.alignHorizontal = ALIGN_RIGHT;
		buttonGrid.add(0, 0, new KTextButton(this, %[ label: getOption("okLabel", "OK"), name: "okButton", id: "primary_button" ]));
		buttonGrid.add(1, 0, new KTextButton(this, getOption("cancelLabel", "キャンセル"), "cancelButton"));

		newColor.hasAlpha = oldColor.hasAlpha = hasAlpha;
		newColor.value = oldColor.value = color;

		primaryLayer.isAvoidDictionaryRegistration = true;

		if (dict)
			bindPersistentDictionary(dict);

		s0Select.value = true;
		alpha = hasAlpha ? (color >> 24) & 0xff : 0xff;
		if (hasAlpha)
			aInput.value = string(alpha);

		applyRGB((color >> 16) & 0xff,
				 (color >> 8) & 0xff,
				 (color) & 0xff);
		updateSelecter();

		invalidateLayout();
	}

	function bindPersistentDictionary(dict) {
		super.bindPersistentDictionary(dict);
		colorSpaceSelect.value = dict.init(name + "_colorspace", 0);
		applyColorSpace(colorSpaceSelect.value);
	}

	function finalize {
		dict.set(name + "_colorspace", colorSpaceSelect.value);
		super.finalize();
	}

	property primaryColorARGB {
		getter {
			return (p0Input.value << 16) | (p1Input.value << 8) | p2Input.value | ((hasAlpha ? aInput.value : 0) << 24);
		}
	}

	property primaryColorRGB {
		getter {
			return (p0Input.value << 16) | (p1Input.value << 8) | p2Input.value;
		}
	}

	property primaryColorTuple {
		getter {
			return [ p0Input.value, p1Input.value, p2Input.value, hasAlpha ? aInput.value : 255 ];
		}
	}

	property secondaryColorTuple {
		getter {
			return [ s0Input.value, s1Input.value, s2Input.value, hasAlpha ? aInput.value : 255 ];
		}
	}

	function completeColorSpaces() {
		completeColorSpace(primaryColorSpace, "p");
		for (var i = 0; i < secondaryColorSpaces.count; i++) 
			completeColorSpace(secondaryColorSpaces[i], "s");
	}

	function completeColorSpace(colorSpace, prefix) {
		var ranges = ColorSpace.getComponentRanges(colorSpace.cs);
		for (var i = 0; i < colorSpace.components.count; i++) {
			var component = colorSpace.components[i];
			var range = ranges[i];
			component.index = i;
			component.min = range.min;
			component.max = range.max;
			component.cyclic = range.cyclic;
			component.inputName = format("{prefix}{index}Input", %[ prefix: prefix, index: i ]);
		}
	}

	function onKeyDown(key) {
		switch (key) {
		case VK_RETURN:
			pressOK();
			break;
		case VK_ESCAPE:
			pressCancel();
			break;
		default:
			super.onKeyDown(...);
			break;
		}
	}

	function pressCancel {
		canceled = true;
		close();
	}

	function pressOK {
		if (prevColor == color)
			canceled = true;
		else
			canceled = false;
		close();
	}

	function applyRGB(r, g, b) {
		p0Input.value = r;
		p1Input.value = g;
		p2Input.value = b;
		var sc = ColorSpace.convertColorTuple(primaryColorSpace.cs, secondaryColorSpace.cs, primaryColorTuple);
		s0Input.value = int(sc[0]);
		s1Input.value = int(sc[1]);
		s2Input.value = int(sc[2]);
		color = (r << 16) | (g << 8) | b | (hasAlpha ? (alpha << 24) : 0);
		textInput.value = convertColorToText(color, hasAlpha);
	}

	function applyPrimary() {
		applyRGB(...);
	}

	function applySecondary(s0, s1, s2) {
		s0Input.value = s0;
		s1Input.value = s1;
		s2Input.value = s2;
		var pc = ColorSpace.convertColorTuple(secondaryColorSpace.cs, primaryColorSpace.cs, secondaryColorTuple);
		p0Input.value = int(pc[0]);
		p1Input.value = int(pc[1]);
		p2Input.value = int(pc[2]);
		color = (pc[0] << 16) | (pc[1] << 8) | pc[2] | (hasAlpha ? (alpha << 24) : 0);
		textInput.value = convertColorToText(color, hasAlpha);
	}

	function applyCurrentPrimary() {
		applyPrimary(p0Input.value, p1Input.value, p2Input.value);
	}

	function applyCurrentSecondary() {
		applySecondary(s0Input.value, s1Input.value, s2Input.value);
	}

	function applyCurrent() {
		switch (mode) {
		case "p0": case "p1": case "p2": applyCurrentPrimary(); break;
		case "s0": case "s1": case "s2": applyCurrentSecondary(); break;
		}
	}

	function applyColorSpace(index) {
		secondaryColorSpace = secondaryColorSpaces[index];
		for (var i = 0; i < secondaryColorSpace.components.count; i++) {
			var component = secondaryColorSpace.components[i];
			this[format("s{0}Select", i)].label = component.label;
			this[format("s{0}Postfix", i)].label = component.postfix;
		}
	}

	function getActiveComponentInfo {
		var colorSpace;
		var mainComponentIndex;
		var colorTuple;
		switch (mode) {
		case "s0": colorSpace = secondaryColorSpace; mainComponentIndex = 0; colorTuple = secondaryColorTuple; break;
		case "s1": colorSpace = secondaryColorSpace; mainComponentIndex = 1; colorTuple = secondaryColorTuple; break;
		case "s2": colorSpace = secondaryColorSpace; mainComponentIndex = 2; colorTuple = secondaryColorTuple; break;
		case "p0": colorSpace = primaryColorSpace; mainComponentIndex = 0; colorTuple = primaryColorTuple; break;
		case "p1": colorSpace = primaryColorSpace; mainComponentIndex = 1; colorTuple = primaryColorTuple; break;
		case "p2": colorSpace = primaryColorSpace; mainComponentIndex = 2; colorTuple = primaryColorTuple; break;
		}

		var subComponentIndices = [ 0, 1, 2 ];
		subComponentIndices.remove(mainComponentIndex);

		var zComponent = colorSpace.components[mainComponentIndex];
		var xComponent = colorSpace.components[subComponentIndices[0]];
		var yComponent = colorSpace.components[subComponentIndices[1]];
		var cs = colorSpace.cs;

		var result = %[ colorSpace: colorSpace,
						mainComponentIndex: mainComponentIndex,
						subComponentIndices: subComponentIndices,
						colorTuple: colorTuple,
						xComponent: xComponent,
						yComponent: yComponent,
						zComponent: zComponent,
						csConstant: colorSpace.cs,
					  ];
		return result;
	}

	function updateSelecter {
		var info = getActiveComponentInfo();
		var alphaMask = (hasAlpha ? +aInput.value : 0xff) << 24;
		var xyColor0 = duplicateStruct(info.colorTuple); xyColor0[info.xComponent.index] = info.xComponent.min; xyColor0[info.yComponent.index] = info.yComponent.max;
		var xyColor1 = duplicateStruct(info.colorTuple); xyColor1[info.xComponent.index] = info.xComponent.max; xyColor1[info.yComponent.index] = info.yComponent.max;
		var xyColor2 = duplicateStruct(info.colorTuple); xyColor2[info.xComponent.index] = info.xComponent.min; xyColor2[info.yComponent.index] = info.yComponent.min;
		var xyColor3 = duplicateStruct(info.colorTuple); xyColor3[info.xComponent.index] = info.xComponent.max; xyColor3[info.yComponent.index] = info.yComponent.min;
		var zColor0 = duplicateStruct(info.colorTuple); zColor0[info.zComponent.index] = info.zComponent.max;
		var zColor1 = duplicateStruct(info.colorTuple); zColor1[info.zComponent.index] = info.zComponent.min;

		var x = (info.colorTuple[info.xComponent.index] - info.xComponent.min) / (info.xComponent.max - info.xComponent.min);
		var y = (info.colorTuple[info.yComponent.index] - info.yComponent.min) / (info.yComponent.max - info.yComponent.min);
		var z = (info.colorTuple[info.zComponent.index] - info.zComponent.min) / (info.zComponent.max - info.zComponent.min);

		xySelecter.draw(x, y, info.csConstant, xyColor0, xyColor1, xyColor2, xyColor3);
		zSelecter.draw(z, info.csConstant, zColor0, zColor1);

		if (hasAlpha) {
			var rgb = primaryColorRGB;
			alphaSelecter.draw(aInput.value / 255, csRGB, rgb | 0xff000000, rgb);
		}
		newColor.value = color;
		notifyFunc(color);
	}

	function applyXYSelecter(x, y) {
		var info = getActiveComponentInfo();

		this[info.xComponent.inputName].value = int(x * (info.xComponent.max - info.xComponent.min) + info.xComponent.min);
		this[info.yComponent.inputName].value = int(y * (info.yComponent.max - info.yComponent.min) + info.yComponent.min);

		applyCurrent();
		updateSelecter();
	}

	function applyZSelecter(z) {
		var info = getActiveComponentInfo();

		this[info.zComponent.inputName].value = int(z * (info.zComponent.max - info.zComponent.min) + info.zComponent.min);

		applyCurrent();
		updateSelecter();
	}

	function applyAlphaSelecter(alpha) {
		this.alpha = alpha;
		aInput.value = alpha;
		textInput.value = convertColorToText(primaryColorARGB, hasAlpha);
		updateSelecter();
	}

	function onChildValueModified(child, value) {
		switch (child.name) {
		case "okButton": pressOK(); break;
		case "cancelButton": pressCancel(); break;
		case "s0Select": case "s1Select": case "s2Select":
		case "p0Select": case "p1Select": case "p2Select": {
			s0Select.value = false;
			s1Select.value = false;
			s2Select.value = false;
			p0Select.value = false;
			p1Select.value = false;
			p2Select.value = false;
			child.value = true;
			mode = child.name.substr(0, 2);
			updateSelecter();
			break;
		}
		case "p0Input": case "p1Input": case "p2Input": {
			var info = getActiveComponentInfo();
			var input = this[info.zComponent.inputName];
			input.value = int(Math.max(info.zComponent.min, Math.min(info.zComponent.max, +value)));
			applyCurrentPrimary();
			updateSelecter();
			break;
		}
		case "s0Input": case "s1Input": case "s2Input": {
			var info = getActiveComponentInfo();
			var input = this[info.zComponent.inputName];
			input.value = int(Math.max(info.zComponent.min, Math.min(info.zComponent.max, +value)));
			applyCurrentSecondary();
			updateSelecter();
			break;
		}
		case "aInput": {
			applyAlphaSelecter(int(Math.max(0, Math.min(255, +value))));
			break;
		}
		case "textInput": {
			value = convertTextToColor(value, hasAlpha);
			// FOLLOW THROUGH
		}
		case "oldColor": {
			if (hasAlpha) 
				alpha = (value >> 24) & 0xFF;
			applyRGB((value >> 16) & 0xff,
					 (value >> 8) & 0xff,
					 (value) & 0xff);
			updateSelecter();
			break;
		}
		case "xySelecter": {
			applyXYSelecter(value[0], value[1]);
			break;
		}
		case "zSelecter": {
			applyZSelecter(value);
			break;
		}
		case "alphaSelecter": {
			applyAlphaSelecter(int(value * 255));
			break;
		}

		case "colorSpaceSelect": {
			applyColorSpace(value);
			applyCurrentPrimary();
			updateSelecter();
			break;
		}
		}
	}
}

/**------------------------------
 * カラーピッカーを呼び出す関数
 *
 * カラーピッカーダイアログを表示して、カラーを編集します。
 * hasAlpha=falseの時は0xRRGGBB形式のカラー値を、
 * hasAlpha=trueの時は0xAARRGGBB形式のカラー値を取り扱います。
 * ダイアログがキャンセルされた時は、返り値にカラーの替わりにvoidを返します。
 *
 * @param color カラー
 * @param hasAlpha アルファを持っているか？
 * @param dict カラーピッカーの位置を保存する辞書
 * @param name カラーピッカーの名前
 * @return 変更されたカラー
 ------------------------------*/
function queryColorPicker(color, hasAlpha = false, dict = void, name = "colorPicker", notifyFunc = function() {})
{
	var win = new KColorPickerDialog(color, hasAlpha, dict, notifyFunc, name);
	win.showModal();
	var result;
	if (win.canceled)
		result = void;
	else
		result = win.color;
	invalidate win;
	return result;
}

