//
// $Id: KSpiralLayout.tjs,v 1.2 2007/09/10 08:37:00 m2 Exp $
//


/**----------------------------------------------------------------------
 * スパイラルレイアウト(左から右、上から下にウィジェットを並べるレイアウト
 ----------------------------------------------------------------------*/
global.KSpiralLayoutArgsFormat =
	[
			%[ key: "name", defaultValue: "" ]
	];

class KSpiralLayout extends KLayout
{
	var childList;
	var layoutRequired;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KSpiralLayout(window, *) {
		var options = parseOldStyleWidgetArgs(KSpiralLayoutArgsFormat, *);
		options.middleButtonDrag = true;
		super.KLayout(window, options);
		childList = [];
		hasImage = false;
		setMarginalMinMaxSize(0, 0, K_WIDGET_MAX_POSSIBLE_WIDTH, K_WIDGET_MAX_POSSIBLE_WIDTH);
		hitThreshold = 0;
	}

	/**------------------------------
	 * 子ウィジェットを追加する
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		child.parent = this;
		childList.add(child);
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを挿入する
	 *
	 * @param index 挿入位置
	 * @param child 子ウィジェット
	 ------------------------------*/
	function insert(index, child) {
		child.parent = this;
		childList.insert(index, child);
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを取り除く
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		child.parent = widgetDepot;
		childList.remove(child);
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/**------------------------------
	 * 子ウィジェットを全て取り除く
	 *
	 * @param doInvalidate 取り除いた子ウィジェットを無効化するか
	 ------------------------------*/
	function removeAll(doInvalidate = true)
	{
		while(childList.count > 0)
		{
			var child = childList[0];
			childList.remove(child);
			if(doInvalidate)
				invalidate child;
			else
				child.parent = widgetDepot;
		}
		redrawContents();
	}

	/**------------------------------
	 * 子アイテムをカウントする
	 * 
	 * @return 子アイテム数
	 ------------------------------*/
	property childCount {
		getter {
			return childList.count;
		}
	}

	/**------------------------------
	 * 子ウィジェットを参照する
	 *
	 * @param index インデックス
	 * @return 子ウィジェット
	 ------------------------------*/
	function childAt(index) {
		return childList[index];
	}

	function onCalculateLayout {
		var minW, minH, maxW, maxH;

		minW = minH = maxW = maxH = 0;

		for (var i = 0; i < childList.count; i++) {
			var childW = childList[i].minWidth + childList[i].marginHorizontal + borderPaddingWidth;
			var childH = childList[i].minHeight + childList[i].marginVertical + borderPaddingHeight;

			minW = int(Math.max(minW, childW));
			minH = int(Math.max(minH, childH));
			maxH += childH;
		}

		maxH += spaceVertical * (childList.count - 1);

		setMinMaxSize(minW, minH, minW, minH);
	}

	/*------------------------------
	 * レイアウトに従ってウィジェットを配置する
	 ------------------------------*/
	function onLocateLayout {
		var x, y, w, h;
		x = y = w = h = 0;
		var rowChildList = [];

		for (var i = 0; i < childList.count; i++) {
			var child;
			var childW, childH;
			child = childList[i];
			childW = child.minWidth + child.marginHorizontal + borderPaddingWidth;
			childH = child.minHeight + child.marginVertical + borderPaddingHeight;

			var drawLine = false;

			if (w + childW > width) {
				drawLine = true;
				i--;
			} else {
				rowChildList.add(child);
				w += childW;
				h = Math.max(h, childH);
				if (i == childList.count - 1)
					drawLine = true;
			}

			if (drawLine) {
				for (var j = 0; j < rowChildList.count; j++) {
					var child;
					var childW, childH;
					child = rowChildList[j];
					childW = child.minWidth + child.marginHorizontal + borderPaddingWidth;
					childH = child.minHeight + child.marginVertical + borderPaddingHeight;
					child.setSize(child.minWidth, child.minHeight);
					locateChild(x + borderPaddingLeft, y + borderPaddingTop, childW - borderPaddingWidth, childH - borderPaddingHeight, child);
					x += childW + spaceHorizontal;
				}
				y += h;
				x = w = h = 0;
				rowChildList = [];
				if (i != childList.count - 1)
					y += spaceVertical;
			}
		}

		setMinMaxSize(minWidth, y, maxWidth, Math.max(y, maxHeight));

		if (! hasDrawableBorder(borderStyle)) {
			hasImage = false;
		} else {
			hasImage = true;
			fillRect(0, 0, width, height, borderStyle.backgroundColor);
			for (var i = 0; i < childList.count; i++) {
				var child = childList[i];
				drawBorder(borderStyle,
						   child.left - borderPaddingLeft,
						   child.top - borderPaddingTop,
						   child.width + borderPaddingWidth,
						   child.height + borderPaddingHeight);
			}
		}
	}
}
