//
// $Id: KSpiralLayout.tjs,v 1.2 2007/09/10 08:37:00 m2 Exp $
//


/**----------------------------------------------------------------------
 * スパイラルレイアウト(左から右、上から下にウィジェットを並べるレイアウト
 ----------------------------------------------------------------------*/
global.KSpiralLayoutArgsFormat =
	[
			%[ key: "name", defaultValue: "" ]
	];

class KSpiralLayout extends KLayout
{
	var childList;
	var layoutRequired;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * @param name 名前
	 ------------------------------*/
	function KSpiralLayout(window, *) {
		var options = parseOldStyleWidgetArgs(KSpiralLayoutArgsFormat, *);
		options = unionDictionary(%[ middleButtonDrag: true,
									 marginalMinWidth: 0,
									 marginalMinHeight: 0,
									 marginalMaxWidth: K_WIDGET_MAX_POSSIBLE_WIDTH,
									 marginalMaxHeight: K_WIDGET_MAX_POSSIBLE_WIDTH ],
								  options,
								  true);
		super.KLayout(window, options);
		childList = [];
		hasImage = false;
		hitThreshold = 0;
	}

	/**------------------------------
	 * 子ウィジェットを追加する
	 *
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(child) {
		child.parent = this;
		childList.add(child);
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを挿入する
	 *
	 * @param index 挿入位置
	 * @param child 子ウィジェット
	 ------------------------------*/
	function insert(index, child) {
		child.parent = this;
		childList.insert(index, child);
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを取り除く
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		child.parent = widgetDepot;
		childList.remove(child);
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/**------------------------------
	 * 子ウィジェットを全て取り除く
	 *
	 * @param doInvalidate 取り除いた子ウィジェットを無効化するか
	 ------------------------------*/
	function removeAll(doInvalidate = true)
	{
		while(childList.count > 0)
		{
			var child = childList[0];
			childList.remove(child);
			if(doInvalidate)
				invalidate child;
			else
				child.parent = widgetDepot;
		}
		redrawContents();
	}

	/**------------------------------
	 * 子アイテムをカウントする
	 * 
	 * @return 子アイテム数
	 ------------------------------*/
	property childCount {
		getter {
			return childList.count;
		}
	}

	/**------------------------------
	 * 子ウィジェットを参照する
	 *
	 * @param index インデックス
	 * @return 子ウィジェット
	 ------------------------------*/
	function childAt(index) {
		return childList[index];
	}

	function onCalculateLayout {
		var minW, minH, maxW, maxH;

		minW = minH = maxW = maxH = 0;

		for (var i = 0; i < childList.count; i++) {
			var childW = childList[i].minWidth + childList[i].marginHorizontal;
			var childH = childList[i].minHeight + childList[i].marginVertical;

			minW = int(Math.max(minW, childW));
			minH = int(Math.max(minH, childH));
			maxH += childH;
		}

		minW += borderPaddingWidth;
		minH += borderPaddingHeight;
		maxH += borderPaddingHeight + spaceVertical * (childList.count - 1);

		setMinMaxSize(minW, minH, minW, minH);
	}

	/*------------------------------
	 * レイアウトに従ってウィジェットを配置する
	 ------------------------------*/
	function onLocateLayout {
		if (! hasDrawableBorder(borderStyle)) {
			hasImage = false;
		} else {
			hasImage = true;
			drawBorder(borderStyle, 0, 0, width, height);
		}

		var x, y, w, h;
		x = borderPaddingLeft;
		y = borderPaddingHeight;
		h = 0;
		var rowChildList = [];


		for (var i = 0; i < childList.count; i++) {
			var child;
			var childW, childH;
			child = childList[i];
			childW = child.minWidth + child.marginHorizontal;
			childH = child.minHeight + child.marginVertical;

			var linefeed = false;

			if (x + childW > width - borderPaddingRight) {
				linefeed = true;
				i--;
			} else {
				rowChildList.add(child);
				x += childW + spaceHorizontal;
				h = Math.max(h, childH);
				if (i == childList.count - 1)
					linefeed = true;
			}

			if (linefeed) {
				x = borderPaddingLeft;
				for (var j = 0; j < rowChildList.count; j++) {
					var child;
					var childW, childH;
					child = rowChildList[j];
					childW = child.minWidth + child.marginHorizontal;
					childH = child.minHeight + child.marginVertical;
					child.setSize(child.minWidth, child.minHeight);
					locateChild(x, y, childW, h, child);
					x += childW + spaceHorizontal;
				}
				y += h;
				x = borderPaddingLeft;
				h = 0;
				rowChildList = [];
				if (i != childList.count - 1)
					y += spaceVertical;
				else
					y += borderPaddingBottom;
			}
		}

		setMinMaxSize(minWidth, y, maxWidth, Math.max(y, maxHeight));
	}
}
