//
// $Id: KTabLayout.tjs,v 1.8 2007/09/17 10:03:45 m2 Exp $
//

global.TAB_STYLE_FIXED = 0;
global.TAB_STYLE_WRAPPING = 1;
global.TAB_STYLE_VARIABLE = 2;
global.TAB_STYLE_SCROLL = 3;

/**----------------------------------------------------------------------
 * タブボタン
 ----------------------------------------------------------------------*/
class KTab extends KEntity
{
	var _label;
	var suitableWidth, suitableHeight;

	/**------------------------------
	 * コンストラクタ
	 *
	 * ユーザーが直接newするクラスでは無い。
	 * KTabLayout で add() した際に内部的に勝手に作られる。
	 * KTabLayout.tabAt() で参照可能。
	 ------------------------------*/
	function KTab(window, label) {
		super.KEntity(window);
		_label = label;
		hitThreshold = 0;
		mouseDragThreshold = 8;
		setMinMaxSize(0, 0, K_UNLIMITED_SIZE, K_UNLIMITED_SIZE);
		omitText = ".";
	}

	/**------------------------------
	 * ラベル
	 *
	 * @param v ラベル
	 * @return ラベル
	 ------------------------------*/
	property label {
		getter {
			return _label;
		}
		setter(v) {
			if (v == _label)
				return;
			_label = v;
			redrawContents();
		}
	}

	/**------------------------------
	 * このタブを選択する
	 ------------------------------*/
	function select {
		parent.tabIndex = this.index;
	}

	property index {
		getter {
			return parent.tabList.find(this);
		}
	}

	property selected {
		getter {
			return parent.tabIndex == this.index;
		}
	}

	function invalidateStyleStates() {
		var states = [];
		if (selected) {
			states.add("selected");
			if (parent.focused)
				states.add("focused");
		} else {
			states.add("notSelected");
		}
		updateCustomStyleStates(states);
	}

	function onDrawContents() {
		applyFontStyle(font, fontStyle);
		suitableWidth = font.getTextWidth(_label) + borderPaddingWidth;
		suitableHeight= fontStyle.fontHeight + borderPaddingHeight;
		var borderStyle = duplicateStruct(this.borderStyle);
		borderStyle.borderWidthBottom = 0;
		borderStyle.borderStyleBottom = BORDER_STYLE_NONE;
		borderStyle.borderRadiusLeftBottom = 0;
		borderStyle.borderRadiusRightBottom = 0;
		drawBorder(borderStyle, 0, 0, width, height);
		var drawResult = drawUITextInRange(fontStyle, borderPaddingLeft, borderPaddingTop, width - borderPaddingWidth, _label, ALIGN_CENTER);
		if (! drawResult.inRange)
			hint = getOption("hint", _label);
		else
			hint = getOption("hint", "");
	}

	function onClick {
		select();
		parent.onTabClick(this.index);
	}

	function onDoubleClick {
		parent.onTabDoubleClick(this.index);
	}

	function onRightClick {
		parent.onTabRightClick(this.index);
	}

	function onDragEnter {
		parent.onTabDragEnter(this.index);
	}

	function onPacketCancel(packet) {
		parent.onTabPacketCancel(this.index, packet);
	}
}


global.KTabLayoutArgsFormat =
	[
			%[ key: "type", defaultValue: FRAME_RAISED ],
			%[ key: "name", defaultValue: "" ]
	];

global.KTabLayoutWidgetStyleDefinition = [
	[ "tabId", "tabId", "" ],
	[ "tabStyle", "tabStyle", void ],
	[ "tabAlign", "tabAlign", ALIGN_LEFT ],
	[ "buttonId", "buttonId", "" ],
	[ "noteIcon", "noteIcon", "" ],
	[ "scrollLeftIcon", "scrollLeftIcon", "" ],
	[ "scrollRightIcon", "scrollRightIcon", "" ]
];

/**----------------------------------------------------------------------
 * タブレイアウト
 ----------------------------------------------------------------------*/
class KTabLayout extends KLayout
{
	var frameLayer;
	var childList;
	var tabList;
	var _tabIndex;
	var _type;
	var tabW, tabH;
	var boxMinW, boxMinH, boxMaxW, boxMaxH;
	var redrawn;
	var _tabStyle;
	var noteButton, scrollLeftButton, scrollRightButton;
	var scrollBegin = 0, scrollEnd;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * @param type フレームタイプ。FRAME_FLATTEN, FRAME_SUNKEN, FRAME_RAISEDのいずれかを選択する。
	 * @param name 名前
	 ------------------------------*/
	function KTabLayout(window, args*) {
		var opts = args.count == 0 ? %[] : parseOldStyleWidgetArgs(KTabLayoutArgsFormat, args*);
		super.KLayout(window, opts);
		//		frameLayer = new global.KWidget(window);
//		frameLayer.parent = this;
		_type = getOption("type", void);
		childList = [];
		tabList = [];
		_tabIndex = -1;
		_tabStyle = getOption("tabStyle", getOption("tabWrapping", false) ? TAB_STYLE_WRAPPING : TAB_STYLE_FIXED);
		focusable = getOption("focusable", window.defaultFocusable);
//		hasImage = false;
		hitThreshold = 0;
		overwriteStyle(%[ frameType: _type ]);
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KTabLayoutWidgetStyleDefinition);
		}
	}

	/**------------------------------
	 * フレームタイプ
	 *
	 * @param v フレームタイプ
	 * @return フレームタイプ
	 ------------------------------*/
	property type {
		getter {
			return _type;
		}
		setter(v) {
			if (_type == v)
				return;
			_type = v;
			overwriteStyle(%[ frameType: _type ]);
			redrawAllTabs();
		}
	}

	/**------------------------------
	 * タブを折り返すかどうか
	 * 
	 * @param v タブを折り返すかどうか
	 * @return タブを折り返すかどうか
	 ------------------------------*/
	property tabWrapping {
		getter {
			return _tabStyle == TAB_STYLE_WRAPPING;
		}
		setter (v) {
			if (_tabStyle == TAB_STYLE_WRAPPING)
				return;
			_tabStyle = TAB_STYLE_WRAPPING;
			redrawContents();
		}
	}

	/**------------------------------
	 * タブスタイル
	 * (読み出し専用。スタイル指定をオプション指定より優先する
	 ------------------------------*/
	property tabStyle {
		getter {
			return (widgetStyle.tabStyle !== void) ? widgetStyle.tabStyle : _tabStyle;
		}
	}

	/**------------------------------
	 * 子ウィジェットを登録する
	 * 
	 * @param tabName タブの名前
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(tabName, child) {
		child.visible = false;
		child.tabName = tabName;
		child.parent = this;
		childList.add(child);
		var tab = new KTab(window, tabName);
		tabList.add(tab);
		tab.parent = this;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを登録する
	 * 
	 * @param index インデックス
	 * @param tabName タブの名前
	 * @param child 子ウィジェット
	 ------------------------------*/
	function insert(index, tabName, child) {
		if (_tabIndex >= index)
			_tabIndex++;
		child.visible = false;
		child.tabName = tabName;
		child.parent = this;
		childList.insert(index, child);
		var tab = new KTab(window, tabName);
		tabList.insert(index, tab);
		tab.parent = this;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを解放する
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var index = childList.find(child);
		if (_tabIndex == index)
			_tabIndex = -1;
		else if (_tabIndex > index)
			_tabIndex--;
		childList.erase(index);
		invalidate tabList[index];
		tabList.erase(index);
		child.parent = widgetDepot;
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/**------------------------------
	 * 子アイテムをカウントする
	 * 
	 * @return 子アイテム数
	 ------------------------------*/
	property childCount {
		getter {
			return childList.count;
		}
	}

	/**------------------------------
	 * 子ウィジェットを参照する
	 *
	 * @param index インデックス
	 * @return 子ウィジェット
	 ------------------------------*/
	function childAt(index) {
		return childList[index];
	}

	/**------------------------------
	 * タブを参照する
	 *
	 * @param index インデックス
	 * @return タブ
	 ------------------------------*/
	function tabAt(index) {
		return tabList[index];
	}

	/**------------------------------
	 * タブインデックス
	 *
	 * @param v  タブインデックス
	 * @return タブインデックス
	 ------------------------------*/
	property tabIndex {
		getter {
			return _tabIndex;
		}
		setter(v) {
			if (v == _tabIndex)
				return;
			_tabIndex = v;
			redrawContents();
			redrawAllTabs();
			onTabSelected(_tabIndex);
		}
	}

	/**------------------------------
	 * タブがクリックされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabClick(index) {
	}

	/**------------------------------
	 * タブがダブルクリックされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabDoubleClick(index) {
	}

	/**------------------------------
	 * タブが右クリックされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabRightClick(index) {
	}

	/**------------------------------
	 * タブがドラッグ開始された時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabDragEnter(index) {
	}

	/**------------------------------
	 * タブのパケットドラッグがキャンセルされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 * @param packet パケット
	 ------------------------------*/
	function onTabPacketCancel(packet) {
	}

	/**------------------------------
	 * タブが選択された時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabSelected(index) {
	}

	// フォーカス時のキー反応。
	// 左右でタブを切り替え
	function onKeyDown(key, shift) {
		switch (key) {
		default:
			super.onKeyDown(...);
			break;
		case  VK_RIGHT: 
			tabIndex = (tabIndex + 1) % tabList.count;
			break;
		case VK_LEFT:
			tabIndex = (tabIndex - 1 + tabList.count) % tabList.count;
			break;
		} 
	}

	function touchScrollButtons() {
		if (noteButton === void) {
			noteButton = new KImageButton(window, %[ name: "_note", focusable: false, marginalMaxHeight: K_UNLIMITED_SIZE, style: %[ isVariableWidth: false ] ]);
			noteButton.parent = this;
			scrollLeftButton = new KImageButton(window, %[ name: "_scrollLeft", focusable: false, marginalMaxHeight: K_UNLIMITED_SIZE, style: %[ isVariableWidth: false ] ]);
			scrollLeftButton.parent = this;
			scrollRightButton = new KImageButton(window, %[ name: "_scrollRight", focusable: false, marginalMaxHeight: K_UNLIMITED_SIZE, style: %[ isVariableWidth: false ] ]);
			scrollRightButton.parent = this;
		}
		noteButton.id = widgetStyle.buttonId;
		noteButton.icon = widgetStyle.noteIcon;
		scrollLeftButton.id = widgetStyle.buttonId;
		scrollLeftButton.icon = widgetStyle.scrollLeftIcon;
		scrollRightButton.id = widgetStyle.buttonId;
		scrollRightButton.icon = widgetStyle.scrollRightIcon;
	}

	// レイアウトのやり直し
	function onCalculateLayout() {
		if (childList.count == 0)
			return;

		boxMinW = boxMinH = boxMaxW = boxMaxH = 0;
		tabW = tabH = 0;
		var tabMinW = 0;

		for (var i = 0; i < tabList.count; i++) {
			var tab = tabList[i];
			tabMinW = Math.max(tabMinW, tab.suitableWidth);
			tabW += tab.suitableWidth;
			tabH = Math.max(tabH, tab.suitableHeight);
		}
		for (var i = 0; i < childList.count; i++) {
			var child = childList[i];
			boxMinW = Math.max(boxMinW, child.minWidth + child.marginHorizontal);
			boxMinH = Math.max(boxMinH, child.minHeight + child.marginVertical);
			boxMaxW = Math.max(boxMaxW, child.maxWidth + child.marginHorizontal);
			boxMaxH = Math.max(boxMaxH, child.maxHeight + child.marginVertical);
		}
		boxMinW += borderPaddingWidth;
		boxMinH += borderPaddingHeight;
		boxMaxW += borderPaddingWidth;
		boxMaxH += borderPaddingHeight;

		var tabMargin = borderStyle.borderRadiusLeftTop + borderStyle.borderRadiusRightTop;
		var minW, minH, maxW, maxH;
		switch (tabStyle) {
		case TAB_STYLE_FIXED:
			minW = int(Math.max(tabW + tabMargin, boxMinW));
			break;
		case TAB_STYLE_WRAPPING:
		case TAB_STYLE_VARIABLE:
			minW = int(Math.max(tabMinW + tabMargin, boxMinW));
			break;
		case TAB_STYLE_SCROLL: {
			touchScrollButtons();
			var myMargin
				= Math.max(borderStyle.borderRadiusLeftTop, noteButton.width)
				+  Math.max(borderStyle.borderRadiusRightTop, scrollLeftButton.width + scrollRightButton.width);
			minW = int(Math.max(tabMinW + myMargin, boxMinW));
			break;
		}
		}
		minH = boxMinH + tabH;
		maxW = int(Math.max(tabW + tabMargin, boxMaxW));
		maxW = Math.max(minW, maxW);
		maxH = boxMaxH + tabH;

		setMinMaxSize(minW, minH, maxW, maxH);
	}

	// タブを全て再描画
	function redrawAllTabs {
		for (var i = 0; i < tabList.count; i++) {
			tabList[i].overwriteStyle(%[ frameType: _type ]);
			tabList[i].invalidateStyleStates();
		}
	}

	// フレームの再描画
	function onLocateLayout() {
		if (childList.count == 0) {
			return;
		}

		if (tabIndex == -1) {
			tabIndex = 0;
		}
		if (tabIndex >= tabList.count) {
			tabIndex = tabList.count - 1;
		}

		var givenWidth = width - (borderStyle.borderRadiusLeftTop + borderStyle.borderRadiusRightTop);

		var sumTabWidth = 0;
		for (var i = 0; i < tabList.count; i++)
			sumTabWidth += tabList[i].suitableWidth;;

		var curTabStyle = tabStyle;
		switch (curTabStyle) {
		case TAB_STYLE_VARIABLE:
			if (sumTabWidth <= givenWidth)
				curTabStyle = TAB_STYLE_FIXED;
			break;

		case TAB_STYLE_SCROLL:
			if (sumTabWidth <= givenWidth) {
				curTabStyle = TAB_STYLE_FIXED;
				noteButton.visible = false;
				scrollLeftButton.visible = false;
				scrollRightButton.visible = false;
				break;
			}
		}

		switch (curTabStyle) {
		case TAB_STYLE_FIXED: {
			var x = borderStyle.borderRadiusLeftTop;
			switch (widgetStyle.tabAlign) {
			case ALIGN_LEFT: break;
			case ALIGN_CENTER: x += int((givenWidth - sumTabWidth) / 2); break;
			case ALIGN_RIGHT: x += givenWidth - sumTabWidth; break;
			}
			for (var i = 0; i < tabList.count; i++) {
				var tab = tabList[i];
				tab.visible = true;
				tab.setSize(tab.suitableWidth, tab.suitableHeight);
				tab.setPos(x, tabH - tab.height);
				x += tab.width;
			}
			break;
		}
		case TAB_STYLE_SCROLL: {
			var tabMarginLeft = Math.max(borderStyle.borderRadiusLeftTop, noteButton.width);
			var tabMarginRight = Math.max(borderStyle.borderRadiusRightTop, scrollLeftButton.width + scrollRightButton.width);
			var tabMargin = tabMarginLeft + tabMarginRight;
			var givenWidth = width - tabMargin;
			noteButton.visible = true;
			scrollLeftButton.visible = true;
			scrollRightButton.visible = true;
			noteButton.height = scrollLeftButton.height = scrollRightButton.height = tabH;
			noteButton.setPos(0, 0);
			scrollLeftButton.setPos(width - tabMarginRight, 0);
			scrollRightButton.setPos(width - scrollRightButton.width, 0);
			var x = tabMarginLeft;
			for (var i = 0; i < tabList.count; i++)
				tabList[i].visible = false;

			scrollBegin = Math.max(0, Math.min(tabList.count - 1, scrollBegin));

			var i;
			for (i = scrollBegin; i < tabList.count; i++) {
				var tab = tabList[i];
				if (x + tab.suitableWidth > width - tabMarginRight)
					break;
				tab.setSize(tab.suitableWidth, tab.suitableHeight);
				tab.setPos(x, tabH - tab.height);
				tab.visible = true;
				x += tab.width;
			}
			scrollEnd = i;
			scrollLeftButton.enabled = scrollBegin > 0;
			scrollRightButton.enabled = scrollEnd < tabList.count;
			break;
		}
		case TAB_STYLE_VARIABLE: {
			var givenWidth = width - (borderStyle.borderRadiusLeftTop + borderStyle.borderRadiusRightTop);
			var requiredWidth = 0;
			for (var i = 0; i < tabList.count; i++)
				requiredWidth += tabList[i].suitableWidth;
			var reduceWidth = Math.max(0, requiredWidth - givenWidth);
			var unitWidth = givenWidth / tabList.count;
			var reduceTabNum = 0;
			var isReduceTab = [];
			for (var i = 0; i < tabList.count; i++) {
				isReduceTab[i] = false;
				if (i != tabIndex
					&& tabList[i].suitableWidth >= unitWidth) {
					isReduceTab[i] = true;
					reduceTabNum++;
				}
			}
			if (reduceTabNum == 0) {
				reduceTabNum = tabList.count;
				for (var i = 0; i < tabList.count; i++)
					isReduceTab[i] = true;
			}

			var reduceTabSumWidth = 0;
			for (var i = 0; i < tabList.count; i++) {
				if (isReduceTab[i])
					reduceTabSumWidth += tabList[i].suitableWidth;
			}

			var d = 0;
			var x = borderStyle.borderRadiusLeftTop;
			for (var i = 0; i < tabList.count; i++) {
				var tab = tabList[i];
				if (! isReduceTab[i]) {
					tab.setSize(tab.suitableWidth, tab.suitableHeight);
				} else {
					var reduce = reduceWidth * tab.suitableWidth / reduceTabSumWidth;
					var v = int(reduce + d + 0.5);
					d += reduce - v;
					tab.setSize(tab.suitableWidth - v, tab.suitableHeight);
				}
				tab.setPos(x, tabH - tab.height);
				x += tab.width;
			}
			break;
		}
		case TAB_STYLE_WRAPPING: {
			var tabRowList;
			var curIndexRowCount;
			var x, y, row;
			var l = borderStyle.borderRadiusLeftTop;
			var r = width - borderStyle.borderRadiusRightTop;
			x = l;
			y = 0;
			tabRowList = [];
			row = 0;
			for (var i = 0; i < tabList.count; i++) {
				var tab = tabList[i];
				tab.setSize(tab.suitableWidth, tab.suitableHeight);
				if (x + tab.width > r) {
					x = l;
					row ++;
					y += tab.suitableHeight;
				}
				tabRowList.add([ x, y, row ]);
				x += tab.width;
				if (i == tabIndex)
					curIndexRowCount = row;
			}
			y += tabAt(0).suitableHeight;

			if (tabH != y) {
				tabH = y;
				var minH, maxH;
				minH = boxMinH + tabH;
				maxH = boxMaxH + tabH;
				setMinMaxSize(minWidth, minH, maxWidth, maxH);
			}

			for (var i = 0; i < tabList.count; i++) {
				var tab = tabList[i];
				var x, y, row;
				x = tabRowList[i][0];
				y = tabRowList[i][1];
				row = tabRowList[i][2];
				tab.setPos(x, y);
				tab.height = tabH - y;
			}
			break;
		}
		}

		fillRect(0, 0, width, height, 0);
		drawBorder(borderStyle, 0, tabH, width, height - tabH);

		var tab = tabAt(tabIndex);
		if (tab.visible) {
			var slitLeft, slitRight;
			slitLeft = tab.left + tab.borderStyle.borderWidthLeft;
			slitRight = tab.left + tab.width - tab.borderStyle.borderWidthRight;
			if (tab.top + tab.suitableHeight != tabH) {
				var lastTab = tabAt(childCount - 1);
				slitLeft = Math.max(slitLeft, lastTab.left + lastTab.width);
			}
			if (slitLeft < slitRight)
				fillRect(slitLeft, tabH, slitRight - slitLeft, borderStyle.borderWidthTop, borderStyle.backgroundColor);
		}

		for (var i = 0; i < childList.count; i++) {
			var child = childList[i];
			if (i != tabIndex) {
				child.visible = false;
				continue;
			}
			child.visible = true;
			child.setSize(width - child.marginHorizontal - borderPaddingWidth,
						  height - tabH - child.marginVertical - borderPaddingHeight);
			locateChild(borderPaddingLeft, tabH + borderPaddingTop, width - borderPaddingWidth, height - tabH - borderPaddingHeight, child);
		}
	}

	function onAttachedToWindow() {
		redrawAllTabs();
		redrawContents();
	}

	// フォーカスを検知
	function onFocus {
		redrawAllTabs();
	}

	// フォーカスロストを検知
	function onBlur {
		redrawAllTabs();
	}

	function onChildValueModified(child, value) {
		switch (child.name) {
		default:
			super.onChildValueModified(...);
			break;
		case "_note":
			selectTabsByMenu();
			break;
		case "_scrollLeft":
			scrollLeft();
			break;
		case "_scrollRight":
			scrollRight();
			break;
		}
	}

	function selectTabsByMenu() {
		var menu = new KContextMenu();
		for (var i = 0; i < tabList.count; i++) {
			var menuItem = menu.addItem(tabList[i].label, "", true, funccall(onSelectTabByMenu, i));
			menuItem.checked = tabIndex == i;
		}
		menu.show();
	}

	function onSelectTabByMenu(index) {
		if (tabIndex == index)
			return;

		var tabMarginLeft = Math.max(borderStyle.borderRadiusLeftTop, noteButton.width);
		var tabMarginRight = Math.max(borderStyle.borderRadiusRightTop, scrollLeftButton.width + scrollRightButton.width);
		var tabMargin = tabMarginLeft + tabMarginRight;
		var givenWidth = width - tabMargin;
		scrollBegin = index;
		for (var i = scrollBegin; i < tabList.count; i++)
			givenWidth -= tabList[i].suitableWidth;
		while (scrollBegin > 0
			   && givenWidth >= tabList[scrollBegin - 1].suitableWidth) {
			scrollBegin--;
			givenWidth -= tabList[scrollBegin].suitableWidth;
		}
		tabIndex = index;
		
	}

	function scrollLeft() {
		scrollBegin--;
		redrawContents();
	}

	function scrollRight() {
		scrollBegin++;
		redrawContents();
	}
}
