//
// $Id: KTabLayout.tjs,v 1.8 2007/09/17 10:03:45 m2 Exp $
//


/**----------------------------------------------------------------------
 * タブボタン
 ----------------------------------------------------------------------*/
class KTab extends KEntity
{
	var _label;

	/**------------------------------
	 * コンストラクタ
	 *
	 * ユーザーが直接newするクラスでは無い。
	 * KTabLayout で add() した際に内部的に勝手に作られる。
	 * KTabLayout.tabAt() で参照可能。
	 ------------------------------*/
	function KTab(window, label) {
		super.KEntity(window);
		_label = label;
		hitThreshold = 0;
		mouseDragThreshold = 8;
	}

	/**------------------------------
	 * ラベル
	 *
	 * @param v ラベル
	 * @return ラベル
	 ------------------------------*/
	property label {
		getter {
			return _label;
		}
		setter(v) {
			if (v == _label)
				return;
			_label = v;
			redrawContents();
		}
	}

	/**------------------------------
	 * このタブを選択する
	 ------------------------------*/
	function select {
		parent.tabIndex = this.index;
	}

	property index {
		getter {
			return parent.tabList.find(this);
		}
	}

	property selected {
		getter {
			return parent.tabIndex == this.index;
		}
	}

	function invalidateStyleStates() {
		var states = [];
		if (selected) {
			states.add("selected");
			if (parent.focused)
				states.add("focused");
		}
		updateCustomStyleStates(states);
	}

	function onDrawContents() {
		applyFontStyle(font, fontStyle);
		var w = font.getTextWidth(_label) + borderPaddingWidth;
		var h = fontStyle.fontHeight + borderPaddingHeight;
		setMinMaxSize(w, h, w, K_WIDGET_MAX_POSSIBLE_WIDTH);
		var borderStyle = duplicateStruct(this.borderStyle);
		borderStyle.borderWidthBottom = 0;
		borderStyle.borderStyleBottom = BORDER_STYLE_NONE;
		borderStyle.borderRadiusLeftBottom = 0;
		borderStyle.borderRadiusRightBottom = 0;
		drawBorder(borderStyle, 0, 0, width, height);
		drawUIText(fontStyle, borderPaddingLeft, borderPaddingTop, _label);
	}

	function onClick {
		select();
		parent.onTabClick(this.index);
	}

	function onDoubleClick {
		parent.onTabDoubleClick(this.index);
	}

	function onRightClick {
		parent.onTabRightClick(this.index);
	}

	function onDragEnter {
		parent.onTabDragEnter(this.index);
	}

	function onPacketCancel(packet) {
		parent.onTabPacketCancel(this.index, packet);
	}
}


global.KTabLayoutArgsFormat =
	[
			%[ key: "type", defaultValue: FRAME_RAISED ],
			%[ key: "name", defaultValue: "" ]
	];

/**----------------------------------------------------------------------
 * タブレイアウト
 ----------------------------------------------------------------------*/
class KTabLayout extends KLayout
{
	var frameLayer;
	var childList;
	var tabList;
	var _tabIndex;
	var _type;
	var tabW, tabH;
	var boxMinW, boxMinH, boxMaxW, boxMaxH;
	var redrawn;
	var _tabWrapping;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param window ウィンドウ
	 * @param type フレームタイプ。FRAME_FLATTEN, FRAME_SUNKEN, FRAME_RAISEDのいずれかを選択する。
	 * @param name 名前
	 ------------------------------*/
	function KTabLayout(window, *) {
		var opts = parseOldStyleWidgetArgs(KTabLayoutArgsFormat, *);
		super.KLayout(window, opts);
//		frameLayer = new global.KWidget(window);
//		frameLayer.parent = this;
		_type = getOption("type", void);
		childList = [];
		tabList = [];
		_tabIndex = -1;
		_tabWrapping = getOption("tabWrapping", false);
		focusable = getOption("focusable", window.defaultFocusable);
//		hasImage = false;
		hitThreshold = 0;
		overwriteStyle(%[ frameType: _type ]);
	}

	function onExtractWidgetStyle(widgetStyle) {
		widgetStyle.tabId = getStyleProperty("tabId", "");
	}

	/**------------------------------
	 * フレームタイプ
	 *
	 * @param v フレームタイプ
	 * @return フレームタイプ
	 ------------------------------*/
	property type {
		getter {
			return _type;
		}
		setter(v) {
			if (_type == v)
				return;
			_type = v;
			overwriteStyle(%[ frameType: _type ]);
			redrawAllTabs();
		}
	}

	/**------------------------------
	 * タブを折り返すかどうか
	 * 
	 * @param v タブを折り返すかどうか
	 * @return タブを折り返すかどうか
	 ------------------------------*/
	property tabWrapping {
		getter {
			return _tabWrapping;
		}
		setter (v) {
			if (_tabWrapping == v)
				return;
			_tabWrapping = v;
			redrawContents();
		}
	}

	/**------------------------------
	 * 子ウィジェットを登録する
	 * 
	 * @param tabName タブの名前
	 * @param child 子ウィジェット
	 ------------------------------*/
	function add(tabName, child) {
		child.tabName = tabName;
		child.parent = this;
		childList.add(child);
		var tab = new KTab(window, tabName);
		tabList.add(tab);
		tab.parent = this;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを登録する
	 * 
	 * @param index インデックス
	 * @param tabName タブの名前
	 * @param child 子ウィジェット
	 ------------------------------*/
	function insert(index, tabName, child) {
		if (_tabIndex >= index)
			_tabIndex++;
		child.tabName = tabName;
		child.parent = this;
		childList.insert(index, child);
		var tab = new KTab(window, tabName);
		tabList.insert(index, tab);
		tab.parent = this;
		redrawContents();
	}

	/**------------------------------
	 * 子ウィジェットを解放する
	 *
	 * @param child 子ウィジェット
	 * @param doInvalidate invalidateするかどうか
	 ------------------------------*/
	function remove(child, doInvalidate = true) {
		var index = childList.find(child);
		if (_tabIndex == index)
			_tabIndex = -1;
		else if (_tabIndex > index)
			_tabIndex--;
		childList.erase(index);
		invalidate tabList[index];
		tabList.erase(index);
		child.parent = widgetDepot;
		redrawContents();
		if (doInvalidate)
			invalidate child;
	}

	/**------------------------------
	 * 子アイテムをカウントする
	 * 
	 * @return 子アイテム数
	 ------------------------------*/
	property childCount {
		getter {
			return childList.count;
		}
	}

	/**------------------------------
	 * 子ウィジェットを参照する
	 *
	 * @param index インデックス
	 * @return 子ウィジェット
	 ------------------------------*/
	function childAt(index) {
		return childList[index];
	}

	/**------------------------------
	 * タブを参照する
	 *
	 * @param index インデックス
	 * @return タブ
	 ------------------------------*/
	function tabAt(index) {
		return tabList[index];
	}

	/**------------------------------
	 * タブインデックス
	 *
	 * @param v  タブインデックス
	 * @return タブインデックス
	 ------------------------------*/
	property tabIndex {
		getter {
			return _tabIndex;
		}
		setter(v) {
			if (v == _tabIndex)
				return;
			_tabIndex = v;
			redrawContents();
			redrawAllTabs();
			onTabSelected(_tabIndex);
		}
	}

	/**------------------------------
	 * タブがクリックされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabClick(index) {
	}

	/**------------------------------
	 * タブがダブルクリックされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabDoubleClick(index) {
	}

	/**------------------------------
	 * タブが右クリックされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabRightClick(index) {
	}

	/**------------------------------
	 * タブがドラッグ開始された時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabDragEnter(index) {
	}

	/**------------------------------
	 * タブのパケットドラッグがキャンセルされた時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 * @param packet パケット
	 ------------------------------*/
	function onTabPacketCancel(packet) {
	}

	/**------------------------------
	 * タブが選択された時に呼ばれるフック関数
	 *
	 * @param index インデックス
	 ------------------------------*/
	function onTabSelected(index) {
	}

	// フォーカス時のキー反応。
	// 左右でタブを切り替え
	function onKeyDown(key, shift) {
		switch (key) {
		default:
			super.onKeyDown(...);
			break;
		case  VK_RIGHT: 
			tabIndex = (tabIndex + 1) % tabList.count;
			break;
		case VK_LEFT:
			tabIndex = (tabIndex - 1 + tabList.count) % tabList.count;
			break;
		} 
	}

	// レイアウトのやり直し
	function onCalculateLayout() {
		if (childList.count == 0)
			return;

		boxMinW = boxMinH = boxMaxW = boxMaxH = 0;
		tabW = tabH = 0;
		var tabMinW = 0;

		for (var i = 0; i < tabList.count; i++) {
			var tab = tabList[i];
			tabMinW = Math.max(tabMinW, tab.minWidth);
			tabW += tab.minWidth;
			tabH = Math.max(tabH, tab.minHeight);
		}
		for (var i = 0; i < childList.count; i++) {
			var child = childList[i];
			boxMinW = Math.max(boxMinW, child.minWidth + child.marginHorizontal);
			boxMinH = Math.max(boxMinH, child.minHeight + child.marginVertical);
			boxMaxW = Math.max(boxMaxW, child.maxWidth + child.marginHorizontal);
			boxMaxH = Math.max(boxMaxH, child.maxHeight + child.marginVertical);
		}
		boxMinW += borderPaddingWidth;
		boxMinH += borderPaddingHeight;
		boxMaxW += borderPaddingWidth;
		boxMaxH += borderPaddingHeight;

		var tabMargin = borderStyle.borderRadiusLeftTop + borderStyle.borderRadiusRightTop;
		var minW, minH, maxW, maxH;
		if (tabWrapping)
			minW = int(Math.max(tabMinW + tabMargin, boxMinW));
		else
			minW = int(Math.max(tabW + tabMargin, boxMinW));
		minH = boxMinH + tabH;
		maxW = int(Math.max(tabW + tabMargin, boxMaxW));
		maxH = boxMaxH + tabH;

		var x = borderStyle.borderRadiusLeftTop;
		for (var i = 0; i < tabList.count; i++) {
			var tab = tabList[i];
			tab.setSize(tab.minWidth, tab.minHeight);
			tab.setPos(x, tabH - tab.height);
			x += tab.width;
		}
		setMinMaxSize(minW, minH, maxW, maxH);
	}

	// タブを全て再描画
	function redrawAllTabs {
		for (var i = 0; i < tabList.count; i++) {
			tabList[i].overwriteStyle(%[ frameType: _type ]);
			tabList[i].invalidateStyleStates();
		}
	}

	// フレームの再描画
	function onLocateLayout() {
		if (childList.count == 0) {
			return;
		}

		if (tabIndex == -1) {
			tabIndex = 0;
		}
		if (tabIndex >= tabList.count) {
			tabIndex = tabList.count - 1;
		}

		if (tabWrapping) {
			var tabRowList;
			var curIndexRowCount;
			var x, y, row;
			var l = borderStyle.borderRadiusLeftTop;
			var r = width - borderStyle.borderRadiusRightTop;
			x = l;
			y = 0;
			tabRowList = [];
			row = 0;
			for (var i = 0; i < tabList.count; i++) {
				var tab = tabList[i];
				if (x + tab.width > r) {
					x = l;
					row ++;
					y += tab.minHeight;
				}
				tabRowList.add([ x, y, row ]);
				x += tab.width;
				if (i == tabIndex)
					curIndexRowCount = row;
			}
			y += tabAt(0).minHeight;

			if (tabH != y) {
				tabH = y;
				var minH, maxH;
				minH = boxMinH + tabH;
				maxH = boxMaxH + tabH;
				setMinMaxSize(minWidth, minH, maxWidth, maxH);
			}

			for (var i = 0; i < tabList.count; i++) {
				var tab = tabList[i];
				var x, y, row;
				x = tabRowList[i][0];
				y = tabRowList[i][1];
				row = tabRowList[i][2];
				tab.setPos(x, y);
				tab.height = tabH - y;
			}
		}

		fillRect(0, 0, width, height, borderStyle.backgroundColor);
		drawBorder(borderStyle, 0, tabH, width, height - tabH);

		var tab = tabAt(tabIndex);
		var slitLeft, slitRight;
		slitLeft = tab.left + tab.borderStyle.borderWidthLeft;
		slitRight = tab.left + tab.width - tab.borderStyle.borderWidthRight;
		if (tab.top + tab.minHeight != tabH) {
			var lastTab = tabAt(childCount - 1);
			slitLeft = Math.max(slitLeft, lastTab.left + lastTab.width);
		}
		if (slitLeft < slitRight) 
			fillRect(slitLeft, tabH, slitRight - slitLeft, borderStyle.borderWidthTop, borderStyle.backgroundColor);

		for (var i = 0; i < childList.count; i++) {
			var child = childList[i];
			if (i != tabIndex) {
				child.visible = false;
				continue;
			}
			child.visible = true;
			child.setSize(width - child.marginHorizontal - borderPaddingWidth,
						  height - tabH - child.marginVertical - borderPaddingHeight);
			locateChild(borderPaddingLeft, tabH + borderPaddingTop, width - borderPaddingWidth, height - tabH - borderPaddingHeight, child);
		}
	}

	// フォーカスを検知
	function onFocus {
		redrawAllTabs();
	}

	// フォーカスロストを検知
	function onBlur {
		redrawAllTabs();
	}
}
