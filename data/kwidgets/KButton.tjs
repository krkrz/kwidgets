/**----------------------------------------------------------------------
 * ボタン
 ----------------------------------------------------------------------*/
global.KButtonArgsFormat =
	[
			%[ key: "label", defaultValue: "" ],
			%[ key: "name", defaultValue: "" ]
	];

global.KButtonWidgetStyleDefinition =
	[
		[ "isVariableWidth", "isVariableWidth", false ],
		[ "width", "width", void ],
		[ "height", "height", void ]
	];

class KButton extends KEntity
{
	// ボタンの値
	var _value = void;
	// ラベル
	var _label;
	//ラベルサイズ
	var labelWidth, labelHeight;
	// マウスダウン時に反応
	var dispatchOnMouseDown = false;
	var autoDispatchStartInterval = void;
	var autoDispatchRepeatInterval = void;
	var autoDispatchTimer = void;

	/**------------------------------
	 * コンストラクタ
	 *
	 * @param win ウィンドウ
	 options:
	 value: 値
	 isVariableWidth: 可変幅
	 ------------------------------*/
	function KButton(win, *) {
		var opts = parseOldStyleWidgetArgs(KButtonArgsFormat, *);

		super.KEntity(win, opts);

		// 値の初期値
		_value = getOption("value", void);
		_label = getInitialLabel();
		dispatchOnMouseDown = getOption("dispatchOnMouseDown", false);
		autoDispatchStartInterval = getOption("autoDispatchStartInterval", void);
		autoDispatchRepeatInterval = getOption("autoDispatchRepeatInterval", void);

		if (dispatchOnMouseDown
			&& autoDispatchStartInterval !== void
			&& autoDispatchRepeatInterval !== void) {
			autoDispatchTimer = new Timer(this, "dispatch");
			autoDispatchTimer.capcaity = 1;
		}

		// デフォルトフォーカス
		focusable = getOption("focusable", win.defaultFocusable);

		// 辺り判定オール受けつけ
		hitThreshold = 0;
	}

	function finalize {
		invalidate autoDispatchTimer;
		super.finalize();
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, concatArray(signWidgetStyleDefinition, KButtonWidgetStyleDefinition));
		}
	}

	/**------------------------------
	 * ラベルの値
	 *
	 * @return ラベルの値
	 * @param v 新規のラベルの値
	 ------------------------------*/
	property label {
		getter {
			return _label;
		}
		setter(v) {
			_label = v;
			redrawContents();
		}
	}

	/*------------------------------
	 * 描画
	 ------------------------------*/
	function onDrawContents() {
		// ラベルサイズを計算
		onCalcLabelSize();

		var minW = widgetStyle.width ? widgetStyle.width : getOption("width", borderPaddingWidth + labelWidth);
		var minH = widgetStyle.height ? widgetStyle.height : getOption("height", borderPaddingHeight + labelHeight);

		if (! widgetStyle.isVariableWidth)
			setFixedSize(minW, minH);
		else
			setMinMaxSize(K_WIDGET_MIN_POSSIBLE_WIDTH, minH, K_WIDGET_MAX_POSSIBLE_WIDTH, minH);

		// ボーダー描画
		drawBorder(borderStyle, 0, 0, width, height);

		onDrawLabel(borderPaddingLeft, borderPaddingTop, width - borderPaddingWidth, height - borderPaddingHeight);
	}

	/**------------------------------
	 * イベントを発生させ強制的に現在の値を通知する。
	 ------------------------------*/
	property value {
		getter {
			return _value;
		}
		setter(v) {
			_value = v;
		}
	}

	/**------------------------------
	 * イベントを発生させ強制的に現在の値を通知する。
	 *
	 * 値trueで onValueModifiedを呼びます。
	 ------------------------------*/
	function dispatch() {
		fireAutoDispatch();

		if (nodeEnabled)
			onValueModified(_value);
	}

	function invalidateValue {
		dispatch();
	}

	/**------------------------------
	 * オートディスパッチを処理する
	 ------------------------------*/
	function fireAutoDispatch() {
		if (autoDispatchTimer !== void) {
			if (! autoDispatchTimer.enabled) {
				autoDispatchTimer.interval = autoDispatchStartInterval;
				autoDispatchTimer.enabled = true;
			} else {
				autoDispatchTimer.interval = autoDispatchRepeatInterval;
			}
		}
	}

	function stopAutoDispatch() {
		if (autoDispatchTimer !== void)
			autoDispatchTimer.enabled = false;
	}

	/*------------------------------
	 * マウスに反応する
	 ------------------------------*/
	function onMouseDown() {
		super.onMouseDown();
		focus();
		if (dispatchOnMouseDown)
			dispatch();
	}

	function onMouseUp {
		super.onMouseUp(...);
		stopAutoDispatch();

		if (! dispatchOnMouseDown)
			dispatch();
	}

	/*------------------------------
	 * キーボードに反応する
	 ------------------------------*/
	function onKeyDown(key, shift) {
		if (key == VK_SPACE || key == VK_RETURN) {
			addCustomStyleState("mouseDown");
			dispatch();
		} else {
			super.onKeyDown(...);
		}
	}

	function onKeyUp() {
		super.onKeyUp(...);
		removeCustomStyleState("mouseDown");
	}
};

/*----------------------------------------------------------------------
 * テキストボタン
 ----------------------------------------------------------------------*/
class KTextButton extends KButton
{
	/*------------------------------
	 * コンストラクタ
	 *
	 * @param win ウィンドウ
	 * @param label ラベル
	 * @param name 名前
	 ------------------------------*/
	function KTextButton(win, *) {
		super.KButton(win, *);
	}
}

mixin(KTextButton, KTextCapability);

/*----------------------------------------------------------------------
 * イメージボタン
 ----------------------------------------------------------------------*/
class KImageButton extends KButton
{
	/*------------------------------
	 * コンストラクタ
	 *
	 * @param win ウィンドウ
	 * @param label イメージファイル名
	 * @param name 名前
	 ------------------------------*/
	function KImageButton(win, *) {
		super.KButton(win, *);
	}

	property icon {
		getter {
			return label;
		}
		setter(v) {
			label = v;
		}
	}
}

mixin(KImageButton, KImageCapability);
