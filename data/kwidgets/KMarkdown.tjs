global.K_MARKDOWN_GLYPH_TYPE_CHAR = 0;
global.K_MARKDOWN_GLYPH_TYPE_SPACE = 1;
global.K_MARKDOWN_GLYPH_TYPE_IMAGE = 2;

class KMarkdownRow
{
	var owner;
	// 座標
	var left, top, width, height;
	var glyphs = [];
	var rowRanges = [];
	var sumWidth, minWidth, maxGlyphWidth, maxGlyphHeight;
	var lastX = 0;
	var requireLayout = true;
	var hintedGlyphs = [];
	var spacingScaleFactor = 1;
	var indent = 0;

	function KMarkdownRow(owner) {
		this.owner = owner;
	}

	property empty {
		getter {
			return glyphs.count == 0;
		}
	}

	property paragraphSpacing {
		getter {
			return int(owner.widgetStyle.paragraphSpacing * spacingScaleFactor);
		}
	}

	property lineSpacing {
		getter {
			return int(owner.widgetStyle.lineSpacing * spacingScaleFactor);
		}
	}

	property firstIndent {
		getter {
			return owner.widgetStyle.firstIndent;
		}
	}

	function setPos(left, top) {
		this.left = left;
		this.top = top;
	}

	function setSize(width, height) {
		this.width = width;
		this.height = height;
	}

	function add(glyph) {
		glyphs.add(glyph);
	}

	function updateFont() {
		for (var i = 0; i < glyphs.count; i++) {
			var glyph = glyphs[i];
			switch (glyph.type) {
			case K_MARKDOWN_GLYPH_TYPE_CHAR:
				glyph.width = owner.getTextWidth(glyph.mi, glyph.char);
				glyph.height = owner.getTextHeight(glyph.mi);
				break;
			}
		}
		calcSize();
	}

	// 最小幅の再計算
	function calcSize {
		maxGlyphWidth = 0;
		maxGlyphHeight = 0;
		sumWidth = 0;

		for (var i = 0; i < glyphs.count; i++) {
			var glyph = glyphs[i];
			maxGlyphWidth = Math.max(glyph.width, maxGlyphWidth);
			maxGlyphHeight = Math.max(glyph.height, maxGlyphHeight);
			sumWidth += glyph.width;
		}

		minWidth = maxGlyphWidth;

		requireLayout = true;
	}

	function clearGlyph(glyph) {
		switch (glyph.type) {
		case K_MARKDOWN_GLYPH_TYPE_CHAR:
			glyph.word = void;
		}
	}

	// レイアウトのやり直し
	function layout(w) {
		// レイアウトの必要が無く、横幅が変化してないなら、そのまま終了
		if (! requireLayout
			&& width == w)
			return;

		// レイアウトの必要が無く、行が1行だけの時は幅を更新して終了
		if (! requireLayout
			&& rowRanges.count <= 1
			&& lastX <= w) {
			width = w;
			return;
		}
		requireLayout = false;

		var x, y, h, n, i;
		x = y = h = n = 0;
		rowRanges = [];
		var rowHeight = 0;
		x = indent + firstIndent;

		// 全グリフについて走査、表示座標を決定
		for (i = 0; i < glyphs.count; i++) {
			var glyph = glyphs[i];
			clearGlyph(glyph);
			// 横幅をオーバーしてたら改行
			if (x + glyph.width > w) {
				// 行情報を記録
				rowRanges.add([ n, i, x, y, rowHeight ]);
				// 改行
				y += rowHeight + lineSpacing;
				rowHeight = 0;
				x = indent;
				n = i;
			}
			// 文字の座標を記録
			if (typeof(glyph.indent) != K_UNDEFINED) {
				glyph.x = glyph.indent;
			} else {
				glyph.x = x;
				x += glyph.width;
			}
			glyph.y = y;
			rowHeight = Math.max(rowHeight, glyph.height);
		}
		// 末尾の改行位置の座標を記録
		lastX = x;
		// 最終行の情報を記録
		rowRanges.add([ n, i, x, y, rowHeight ]);
		h = y + rowHeight + paragraphSpacing;

		// レンジからグリフ位置を補正
		for (var i = 0; i < rowRanges.count; i++) {
			var rowRange = rowRanges[i];
			var from = rowRange[0];
			var to = rowRange[1];
			var top = rowRange[3];
			var height = rowRange[4];
			for (var j = from; j < to; j++) {
				var glyph = glyphs[j];
				var align = typeof(glyph.align) != K_UNDEFINED ? glyph.align : ALIGN_BOTTOM;
				switch (align) {
				case ALIGN_TOP:    glyph.y = top; break;
				case ALIGN_CENTER: glyph.y = top + (height - glyph.height) / 2; break;
				case ALIGN_BOTTOM: glyph.y = top + height - glyph.height; break;
				}
			}
		}

		// ヒントグリフを集める
		hintedGlyphs.clear();
		for (var i = 0; i < glyphs.count; i++) {
				var glyph = glyphs[i];
			switch (glyph.type) {
			case K_MARKDOWN_GLYPH_TYPE_IMAGE: {
				if (glyph.hint == "")
					continue;
				hintedGlyphs.add(glyph);
			}
			}
		}

		// サイズ設定
		setSize(w, h);
	}

	function findSequence(from, to) {
		var result = %[ from: from, to: from + 1];
		var topGlyph = glyphs[from];
		if (topGlyph.type != K_MARKDOWN_GLYPH_TYPE_CHAR
			|| typeof(topGlyph.indent) != K_UNDEFINED)
			return result;
		var i;
		for (i = from + 1; i < to; i++) {
			var glyph = glyphs[i];
			if (glyph.type != topGlyph.type
				|| glyph.mi != topGlyph.mi)
				break;
		}
		result.to = i;
		return result;
	}

	function drawSequence(from, to) {
		var topGlyph = glyphs[from];
		switch (topGlyph.type) {
		case K_MARKDOWN_GLYPH_TYPE_CHAR: {
			var word = topGlyph.word;
			if (word === void) {
				word = "";
				for (var i = from; i < to; i++)
					word += glyphs[i].char;
				topGlyph.word = word;
			}
			owner.drawRowText(topGlyph.mi, left + topGlyph.x, top + topGlyph.y, word);
			break;
		}
		case K_MARKDOWN_GLYPH_TYPE_IMAGE: {
			owner.operateRect(left + topGlyph.x + topGlyph.padding, top + topGlyph.y,
							  owner.findIcon(topGlyph.image), 0, 0, topGlyph.width, topGlyph.height);
			break;
		}
		}
	}

		// 再描画
	function redraw {
		owner.fillRect(left, top, width, height, owner.borderStyle.backgroundColor);
		// 行単位でさくっと描画
		for (var i = 0; i < rowRanges.count; i++) {
			// まず普通に描画
			var from, to;
			from = rowRanges[i][0];
			to = rowRanges[i][1];
			while (from < to) {
				var seq = findSequence(from, to);
				drawSequence(seq.from, seq.to);
				from = seq.to;
			}
		}
	}

	function getHint(x, y) {
		x -= left;
		y -= top;
		for (var i = 0; i < hintedGlyphs.count; i++) {
			var glyph = hintedGlyphs[i];
			if (glyph.x <= x && x < glyph.x + glyph.width
				&& glyph.y <+ y && y < glyph.y + glyph.height)
				return glyph.hint;
		}
		return "";
	}
}

global.KMarkdownWidgetStyleDefinition =
	[
		[ "paragraphSpacing", "paragraphSpacing", 12 ],
		[ "lineSpacing", "lineSpacing", 6 ],
		[ "firstIndent", "firstIndent", 12 ],
		[ "imagePadding", "imagePadding", 2 ],
		[ "headingScaleFactor", "headingScaleFactor", [ 2 ] ],
		[ "headingStrong", "headingStrong", [ true ] ],
		[ "headingEm", "headingEm", [ false ] ],
		[ "headingUnderline", "headingUnderline", [ true ] ],
		[ "listMarkIcon", "listMarkIcon", [ "$circle(8,#000000)" ] ],
		[ "listIndent", "listIndent", 16 ],
		[ "listIconPadding", "listIconPadding", 4 ],
		[ "orderedListMarkWidth", "orderedListMarkWidth", 24 ],
		[ "orderedListMarkDigits", "orderedListMarkDigits", [ [] ] ]
	];


class KMarkdown extends KVirtualWidget
{
	var LST_CHAR = 0;
	var LST_IMAGE1 = 1;
	var LST_IMAGE2 = 2;
	var LST_IMAGE3 = 3;
	var LST_IMAGE4 = 4;
	var LST_ESCAPE = 5;
	var LST_EMSTR1 = 6;
	var LST_EMSTR2 = 7;
	var LST_STROUT = 8;
	var LST_HEAD   = 9;

	var _text = "";
	var rows = [];
	var fontSizeCache = %[];
	var linefeedPat = /\r\n|\r|\n/;
	var fullWhiteSpaceLinePat = /^\s*$/;
	var whiteSpacePat = /\s/;
	var listPat = /^(\s*)[-+*]\s(.+)$/;
	var orderedListPat = /^(\s*)([0-9])(\\)?\.\s(.+)$/;
	var materials = [];
	var curMaterialIndex = -1;
	var lineWrapping = false;
	var parseRequired = true;
	var customFontStyle;

	function KMarkdown(window, options) {
		var newOptions = %[ middleButtonDrag: true,
							marginalMinWidth: 50,
							marginalMaxWidth: K_WIDGET_MAX_POSSIBLE_WIDTH,
							marginalMaxHeight: K_WIDGET_MAX_POSSIBLE_WIDTH ];
		(Dictionary.assign incontextof newOptions)(options, false);
		super.KVirtualWidget(window, newOptions);
		_text = getOption("text", "");
		lineWrapping = getOption("lineWrapping", true);
		parseRequired = true;
	}

	property widgetStyleDefinition {
		getter {
			return concatArray(super.widgetStyleDefinition, KMarkdownWidgetStyleDefinition);
		}
	}

	property text {
		getter {
			return _text;
		}
		setter(v) {
			if (_text == v)
				return;
			_text = v;
			parseRequired = true;
			redrawContents();
		}
	}

	function findMaterial(materialTemplate) {
		for (var i = 0; i < materials.count; i++) {
			if (equalStruct(materials[i], materialTemplate))
				return i;
		}
		materials.add(duplicateStruct(materialTemplate));
		return materials.count - 1;
	}

	function parseText() {
		if (! parseRequired)
			return;

		parseRequired = false;
		materials.clear();

		var row = new KMarkdownRow(this);
		var lines = _text.split(linefeedPat);

		var listIndentSpaceLevels = [];
		var listOrderCounts = [];

		while (lines.count > 0) {
			var line = lines.shift();

			if (line == "" || fullWhiteSpaceLinePat.test(line)) {
				if (! row.empty) {
					rows.add(row);
					row = new KMarkdownRow(this);
				}
			}

			var material = %[ scaleFactor: 1, em: false, strong: false, strikeout: false, underline: false ];
			var mi = findMaterial(material);

			var lst = LST_CHAR;
			var state = %[];

			// 順序無リスト
			if (listPat.test(line)) {
				var matches = listPat.matches;
				var listIndentSpaceCount = matches[1].length;
				line = matches[2];
				var i;
				for (i = 0; i < listIndentSpaceLevels.count; i++) {
					if (listIndentSpaceCount <= listIndentSpaceLevels[i]) {
						listIndentSpaceLevels[i] = listIndentSpaceCount;
						listIndentSpaceLevels = sliceArray(listIndentSpaceLevels, 0, i + 1);
						break;
					}
				}
				if (i == listIndentSpaceLevels.count)
					listIndentSpaceLevels.add(listIndentSpaceCount);
				var indent = widgetStyle.listIndent * (i + 1);
				var listMarkIcon = widgetStyle.listMarkIcon[i % widgetStyle.listMarkIcon.count];
				var iconImage = findIcon(listMarkIcon);

				if (! row.empty) {
					rows.add(row);
					row = new KMarkdownRow(this);
				}

				row.indent = indent;
				row.add(%[ type: K_MARKDOWN_GLYPH_TYPE_IMAGE,
						   image: listMarkIcon,
						   hint: "",
						   padding: widgetStyle.listIconPadding,
						   width: iconImage.width + widgetStyle.listIconPadding * 2,
						   height: iconImage.height,
						   indent: indent - (iconImage.width + widgetStyle.listIconPadding * 2),
						   align: ALIGN_CENTER,
						 ]);
			} 
			// 順序ありリスト
			else if (orderedListPat.test(line)) {
				var matches = orderedListPat.matches;
				var listIndentSpaceCount = matches[1].length;
				var digits = matches[2];
				var digitEscape = matches[3];
				line = matches[4];
				var i;
				for (i = 0; i < listIndentSpaceLevels.count; i++) {
					if (listIndentSpaceCount <= listIndentSpaceLevels[i]) {
						listIndentSpaceLevels[i] = listIndentSpaceCount;
						listIndentSpaceLevels = sliceArray(listIndentSpaceLevels, 0, i + 1);
						listOrderCounts = sliceArray(listOrderCounts, 0, i + 1);
						break;
					}
				}
				if (i == listIndentSpaceLevels.count) {
					listIndentSpaceLevels.add(listIndentSpaceCount);
					listOrderCounts.add(0);
				}
				var indent = widgetStyle.listIndent * (i + 1);
				var listOrderCount = digitEscape.length ? +digits : listOrderCounts[i] + 1;
				listOrderCounts[i] = listOrderCount;
				var digit = widgetStyle.orderedListMarkDigits[i % widgetStyle.orderedListMarkDigits.count][listOrderCount - 1];
				if (digit === void)
					digit = string(listOrderCount);
				var mark = digit + ".";

				if (! row.empty) {
					rows.add(row);
					row = new KMarkdownRow(this);
				}

				row.indent = indent;
				row.add(%[ type: K_MARKDOWN_GLYPH_TYPE_CHAR,
						   mi: mi,
						   char: mark,
						   indent: indent - (widgetStyle.orderedListMarkWidth),
						 ]);
			} else {
				listIndentSpaceLevels.clear();
				listOrderCounts.clear();
			}

			for (var i = 0; i < line.length; i++) {
				var char = line[i];

				switch (lst) {
				case LST_CHAR: {
					if (whiteSpacePat.test(char)) 
						continue;

					else if (char == "!") { lst = LST_IMAGE1; }
					else if (char == "\\") { lst = LST_ESCAPE; }
					else if (char == "*") { lst = LST_EMSTR1; }
					else if (char == "_") { lst = LST_EMSTR2; }
					else if (char == "~") { lst = LST_STROUT; }
					else if (char == "#" && row.empty) { lst = LST_HEAD; state.headingLength = 1; }
					else {
						row.add(%[ type: K_MARKDOWN_GLYPH_TYPE_CHAR,
								   char: char,
								   mi: mi,
								 ]);
					}
					break;
				}
				case LST_ESCAPE: {
					row.add(%[ type: K_MARKDOWN_GLYPH_TYPE_CHAR,
							   char: char,
							   mi: mi,
							 ]);
					lst = LST_CHAR;
					break;
				}
				case LST_IMAGE1: if (char == "[") { lst = LST_IMAGE2; state.imageAlt = ""; } else if (char == "(") { lst= LST_IMAGE4; state.imageAlt = state.imageName = ""; } else { lst = LST_CHAR; i--; } break;
				case LST_IMAGE2: if (char == "]") { lst = LST_IMAGE3; } else { state.imageAlt += char; } break;
				case LST_IMAGE3: if (char == "(") { lst = LST_IMAGE4; state.imageName = ""; } else { lst = LST_CHAR; i--; } break;
				case LST_IMAGE4: {
					if (char == ")") {
						lst = LST_CHAR;
						var icon = findIcon(state.imageName);
						row.add(%[ type: K_MARKDOWN_GLYPH_TYPE_IMAGE,
								   image: state.imageName,
								   hint: state.imageAlt,
								   padding: widgetStyle.imagePadding,
								   width: icon.width + widgetStyle.imagePadding * 2,
								   height: icon.height,
								 ]);
					} else {
						state.imageName += char;
					}
					break;
				}
				case LST_EMSTR1: {
					if (char == "*") {
						material.strong = ! material.strong;
						mi = findMaterial(material);
					} else {
						material.em = ! material.em;
						mi = findMaterial(material);
						i--;
					}
					lst = LST_CHAR;
					break;
				}
				case LST_EMSTR2: {
					if (char == "_") {
						material.strong = ! material.strong;
						mi = findMaterial(material);
					} else {
						material.em = ! material.em;
						mi = findMaterial(material);
						i--;
					}
					lst = LST_CHAR;
					break;
				}
				case LST_STROUT: {
					if (char == "~") {
						material.strikeout = ! material.strikeout;
						mi = findMaterial(material);
					} else {
						i--;
					}
					lst = LST_CHAR;
					break;
				}
				case LST_HEAD: {
					if (char == "#") {
						state.headingLength++;
					} else {
						rows.add(row);
						row = new KMarkdownRow(this);
						lst = LST_CHAR;
						var headingLength = Math.min(state.headingLength, widgetStyle.headingScaleFactor.count);
						var i = headingLength - 1;
						material.scaleFactor = widgetStyle.headingScaleFactor[i];
						material.strong = widgetStyle.headingStrong[i];
						material.em = widgetStyle.headingEm[i];
						material.underline = widgetStyle.headingUnderline[i];
						mi = findMaterial(material);
						row.spacingScaleFactor = material.scaleFactor;
						i--;
					}
					break;
				}
				}
			}
		}

		if (! row.empty)
			rows.add(row);
		else
			invalidate row;
	}

	function updateFontSize() {
		curMaterialIndex = -1;
		for (var i = 0; i < materials.count; i++) {
			var material = materials[i];
			material.fontHeight = int(material.scaleFactor * fontStyle.fontHeight);
			material.fontWidthCache = %[];
		}
		for (var i = 0; i < rows.count; i++) 
			rows[i].updateFont();
	}

	function activateMaterial(materialIndex) {
		if (materialIndex == curMaterialIndex)
			return;
		curMaterialIndex = materialIndex;
		var material = materials[materialIndex];
		var style = customFontStyle = duplicateStruct(fontStyle);
		style.fontHeight = material.fontHeight;
		style.fontBold = material.strong;
		style.fontItalic = material.em;
		style.fontStrikeout = material.strikeout;
		style.fontUnderline = material.underline;
	}

	function getTextHeight(materialIndex) {
		var material = materials[materialIndex];
		return material.fontHeight;
	}

	function getTextWidth(materialIndex, char) {
		var material = materials[materialIndex];
		if (typeof(material.fontWidthCache[char]) != K_UNDEFINED)
			return material.fontWidthCache[char];

		activateMaterial(materialIndex);
		applyFontStyle(font, customFontStyle);
		var result = material.fontWidthCache[char] = font.getTextWidth(char);
		return result;
	}

	function drawRowText(materialIndex, x, y, word) {
		activateMaterial(materialIndex);
		drawUIText(customFontStyle, x, y, word);
	}

	function onDrawContents() {
		var oldWidth, oldHeight;
		oldWidth = width;
		oldHeight = height;

		onCalculateLayout();

		if (oldWidth == width
			&& oldHeight == height)
			onLocateLayout();
	}

	function onSizeModified(width, height) {
		if (! respondToStyleModification)
			return;
		super.onSizeModified(...);
		locateLayout();
	}

	function onCalculateLayout() {
		parseText();
		updateFontSize();
		locateLayout();
	}

	function onLocateLayout() {
		redrawAll();
	}

	// Y座標に対応する行のインデックスを取得する
	function findRowIndex(y) {
		if (y < borderPaddingTop)
			return 0;
		if (y >= rows[rows.count - 1].top)
			return rows.count - 1;
		var begin, end, mid;
		begin = 0, end = rows.count;
		while (begin < end) {
			mid = int((begin + end) / 2);
			var row = rows[mid];
			if (row.top <= y && y < row.top + row.height)
				return mid;
			if (y > row.top)
				begin = mid + 1;
			else
				end = mid;
		}
	}

	// レイアウトを行う
	function locateLayout {
		var innerWidth = width - borderPaddingWidth;
		if (lineWrapping) {
			// 全ての行を、横幅に合わせてレイアウトする
			var w = 0;
			var y = borderPaddingTop;
			for (var i = 0; i < rows.count; i++) {
				var row = rows[i];
				row.setPos(borderPaddingLeft, y);
				row.layout(innerWidth);
				y += row.height;
				w = Math.max(w, row.minWidth);
			}
			// 最小サイズを決定する
			w += borderPaddingWidth;
			y += borderPaddingHeight;
			setMinMaxSize(w, y, w, y);
		} else {
			// 全ての行を、最大の横幅でレイアウトする
			var w = 0;
			for (var i = 0; i < rows.count; i++) {
				w = Math.max(rows[i].sumWidth, w);
			}
			var y = borderPaddngTop;
			for (var i = 0; i < rows.count; i++) {
				var row = rows[i];
				row.setPos(borderPaddingLeft, y);
				row.layout(w);
				y += row.height;
			}
			// 最小サイズを決定する
			w += borderPaddingWidth;
			y += borderPaddingHeight;
			setMinMaxSize(w, y, w, y);
		}
		redrawAll();
	}

	function onDraw(l, t, w, h) {
		fillRect(l, t, w, h, borderStyle.backgroundColor);
		if (rows.count == 0)
			return;
		var from = findRowIndex(t);
		var to = findRowIndex(t + h);
		for (var i = from; i <= to ; i++)
			rows[i].redraw();
	}

	function onMouseMove(x, y) {
		super.onMouseMove(...);
		if (rows.count == 0)
			hint = getOption("hint", "");
		else {
			var i = findRowIndex(y);
			var row = rows[findRowIndex(y)];
			hint = getOption("hint", row.getHint(x, y));
		}
	}
}
