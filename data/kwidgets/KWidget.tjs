//
// $Id: KWidget.tjs,v 1.22 2007/09/17 12:09:52 m2 Exp $
//


global._dragging_packet_ = void;


/**----------------------------------------------------------------------
 * ウィジェット関連グローバル変数
 ----------------------------------------------------------------------*/

/// デフォルトのフォントフェイス
global.defaultFontFace = "MS UI Gothic";
/// デフォルトのフォントヘイト
global.defaultFontHeight = 14;
/// デフォルトのフォントカラー
global.defaultFontColor = 0x00000000;
/// デフォルトのマージン
global.defaultMarginLeft = 0;
global.defaultMarginTop = 0;
global.defaultMarginRight = 0;
global.defaultMarginBottom = 0;
/// デフォルトのスペース
global.defaultSpaceVertical = 0;
global.defaultSpaceHorizontal = 0;
/// デフォルトのアライメント
global.defaultAlignHorizontal = ALIGN_LEFT;
global.defaultAlignVertical = ALIGN_TOP;
/// デフォルトのフォーカス能
global.defaultFocusable = false;

property defaultMargin {
	setter(v) {
		defaultMarginLeft = defaultMarginTop = defaultMarginRight = defaultMarginBottom = v;
	}
}

property defaultMarginHorizontal {
	setter(v) {
		defaultMarginLeft = defaultMarginRight = v;
	}
}

property defaultMarginVertical {
	setter(v) {
		defaultMarginTop = defaultMarginBottom = v;
	}
}

property defaultSpace {
	setter(v) {
		defaultSpaceVertical = defaultSpaceHorizontal = v;
	}
}

global.K_WIDGET_MARGIN_LEFT_PROPERTY_KEYS   = [ "marginLeft",   "marginHorizontal", "margin" ];
global.K_WIDGET_MARGIN_TOP_PROPERTY_KEYS    = [ "marginTop",    "marginVertical",   "margin" ];
global.K_WIDGET_MARGIN_RIGHT_PROPERTY_KEYS  = [ "marginRight",  "marginHorizontal", "margin"];
global.K_WIDGET_MARGIN_BOTTOM_PROPERTY_KEYS = [ "marginBottom", "marginVertical",   "margin" ];
global.K_WIDGET_ALIGN_HORIZONTAL_PROPERTY_KEYS = [ "alignHorizontal", "align" ];
global.K_WIDGET_ALIGN_VERTICAL_PROPERTY_KEYS =   [ "alignVertical",   "align" ];
global.K_WIDGET_PADDING_OFFSET_HORIZONTAL_PROPERTY_KEYS   = [ "paddingOffsetHorizontal",   "paddingOffset" ];
global.K_WIDGET_PADDING_OFFSET_VERTICAL_PROPERTY_KEYS   = [ "paddingOffsetVertical",   "paddingOffset" ];
global.K_WIDGET_PADDING_INSET_HORIZONTAL_PROPERTY_KEYS   = [ "paddingInsetHorizontal",   "paddingInset" ];
global.K_WIDGET_PADDING_INSET_VERTICAL_PROPERTY_KEYS   = [ "paddingInsetVertical",   "paddingInset" ];
global.K_WIDGET_PADDING_LEFT_PROPERTY_KEYS   = [ "paddingLeft",   "paddingHorizontal", "padding" ];
global.K_WIDGET_PADDING_TOP_PROPERTY_KEYS    = [ "paddingTop",    "paddingVertical",   "padding" ];
global.K_WIDGET_PADDING_RIGHT_PROPERTY_KEYS  = [ "paddingRight",  "paddingHorizontal", "padding"];
global.K_WIDGET_PADDING_BOTTOM_PROPERTY_KEYS = [ "paddingBottom", "paddingVertical",   "padding" ];
global.K_WIDGET_SPACE_HORIZONTAL_PROPERTY_KEYS = [ "spaceHorizontal", "space" ];
global.K_WIDGET_SPACE_VERTICAL_PROPERTY_KEYS =   [ "spaceVertical",   "space" ];
global.K_WIDGET_BORDER_LEFT_WIDTH_PROPERTY_KEYS   = [ "borderWidthLeft",   "borderHorizontalWidth", "borderWidth" ];
global.K_WIDGET_BORDER_TOP_WIDTH_PROPERTY_KEYS    = [ "borderWidthTop",    "borderVerticalWidth",   "borderWidth" ];
global.K_WIDGET_BORDER_RIGHT_WIDTH_PROPERTY_KEYS  = [ "borderWidthRight",  "borderHorizontalWidth", "borderWidth" ];
global.K_WIDGET_BORDER_BOTTOM_WIDTH_PROPERTY_KEYS = [ "borderWidthBottom", "borderVerticalWidth",   "borderWidth" ];
global.K_WIDGET_BORDER_LEFT_COLOR_PROPERTY_KEYS   = [ "borderColorLeft",   "borderHorizontalColor", "borderColor" ];
global.K_WIDGET_BORDER_TOP_COLOR_PROPERTY_KEYS    = [ "borderColorTop",    "borderVerticalColor",   "borderColor" ];
global.K_WIDGET_BORDER_RIGHT_COLOR_PROPERTY_KEYS  = [ "borderColorRight",  "borderHorizontalColor", "borderColor" ];
global.K_WIDGET_BORDER_BOTTOM_COLOR_PROPERTY_KEYS = [ "borderColorBottom", "borderVerticalColor",   "borderColor" ];
global.K_WIDGET_BORDER_LEFT_STYLE_PROPERTY_KEYS   = [ "borderStyleLeft",   "borderHorizontalStyle", "borderStyle" ];
global.K_WIDGET_BORDER_TOP_STYLE_PROPERTY_KEYS    = [ "borderStyleTop",    "borderVerticalStyle",   "borderStyle" ];
global.K_WIDGET_BORDER_RIGHT_STYLE_PROPERTY_KEYS  = [ "borderStyleRight",  "borderHorizontalStyle", "borderStyle" ];
global.K_WIDGET_BORDER_BOTTOM_STYLE_PROPERTY_KEYS = [ "borderStyleBottom", "borderVerticalStyle",   "borderStyle" ];
global.K_WIDGET_BORDER_LEFTTOP_RADIUS_PROPERTY_KEYS =     [ "borderRadiusLeftTop",     "borderRadiusLeft",  "borderRadiusTop",    "borderRadius" ];
global.K_WIDGET_BORDER_RIGHTTOP_RADIUS_PROPERTY_KEYS =    [ "borderRadiusRightTop",    "borderRadiusRight", "borderRadiusTop",    "borderRadius" ];
global.K_WIDGET_BORDER_LEFTBOTTOM_RADIUS_PROPERTY_KEYS =  [ "borderRadiusLeftBottom",  "borderRadiusLeft",  "borderRadiusBottom", "borderRadius" ];
global.K_WIDGET_BORDER_RIGHTBOTTOM_RADIUS_PROPERTY_KEYS = [ "borderRadiusRightBottom", "borderRadiusRight", "borderRadiusBottom", "borderRadius" ];

global.K_WIDGET_APPEARANCE_STYLE_DEFINITION = [
	[ "compositeState", "compositeState", [] ],
	[ "statePriority", "statePriority", [] ],
	[ "callback", "callback", "" ],
	[ "opacity",    "opacity",  255 ]
];

global.K_WIDGET_LOCATE_STYLE_DEFINITIION = [
	[ "marginLeft", K_WIDGET_MARGIN_LEFT_PROPERTY_KEYS, void, void, "_marginLeft" ],
	[ "marginTop", K_WIDGET_MARGIN_TOP_PROPERTY_KEYS, void, void, "_marginTop" ],
	[ "marginRight", K_WIDGET_MARGIN_RIGHT_PROPERTY_KEYS, void, void, "_marginRight" ],
	[ "marginBottom", K_WIDGET_MARGIN_BOTTOM_PROPERTY_KEYS, void, void, "_marginBottom" ],
	[ "alignHorizontal", K_WIDGET_ALIGN_HORIZONTAL_PROPERTY_KEYS, void, void, "_alignHorizontal" ],
	[ "alignVertical", K_WIDGET_ALIGN_VERTICAL_PROPERTY_KEYS, void, void, "_alignVertical" ]
];

global.K_WIDGET_FONT_STYLE_DEFINITION = [
	[ "fontHeight",       "fontHeight", void, void, "_fontHeight" ],
	[ "fontFace",         "fontFace", void, void, "_fontFace" ],
	[ "fontColor",        "fontColor", void, "resolveColor", "_fontColor" ],
	[ "fontAntiAlias",    "fontAntiAlias",  true ],
	[ "fontOutline",      "fontOutline", false ],
	[ "fontOutlineColor", "fontOutlineColor", 0 ],
	[ "fontBold",         "fontBold", false ],
	[ "fontItalic",       "fontItalic", false ],
	[ "fontStrikeout",    "fontStrikeout", false ],
	[ "fontUnderline",    "fontUnderline", false ]
];

global.K_WIDGET_LAYOUT_STYLE_DEFINITION = [
	[ "paddingOffsetHorizontal", K_WIDGET_PADDING_OFFSET_HORIZONTAL_PROPERTY_KEYS, 0 ],
	[ "paddingOffsetVertical",   K_WIDGET_PADDING_OFFSET_VERTICAL_PROPERTY_KEYS, 0 ],
	[ "paddingInsetHorizontal",  K_WIDGET_PADDING_INSET_HORIZONTAL_PROPERTY_KEYS, 0 ],
	[ "paddingInsetVertical",     K_WIDGET_PADDING_INSET_VERTICAL_PROPERTY_KEYS, 0 ],
	[ "spaceHorizontal", K_WIDGET_SPACE_HORIZONTAL_PROPERTY_KEYS, void, void, "_spaceHorizontal" ],
	[ "spaceVertical", K_WIDGET_SPACE_VERTICAL_PROPERTY_KEYS,     void, void, "_spaceVertical" ],
	[ "paddingLeft",   K_WIDGET_PADDING_LEFT_PROPERTY_KEYS,       0,    void, void, "resolvePaddingLeft" ],
	[ "paddingTop",    K_WIDGET_PADDING_TOP_PROPERTY_KEYS,        0,    void, void, "resolvePaddingTop" ],
	[ "paddingRight",  K_WIDGET_PADDING_RIGHT_PROPERTY_KEYS,      0,    void, void, "resolvePaddingRight" ],
	[ "paddingBottom", K_WIDGET_PADDING_BOTTOM_PROPERTY_KEYS,     0,    void, void, "resolvePaddingBottom" ]
];

global.K_WIDGET_BORDER_STYLE_DEFNITION = [
	[ "backgroundColor", "backgroundColor", 0xfff0f0f0, "resolveColor" ],
	[ "borderWidthLeft",   K_WIDGET_BORDER_LEFT_WIDTH_PROPERTY_KEYS, 0 ],
	[ "borderWidthTop",    K_WIDGET_BORDER_TOP_WIDTH_PROPERTY_KEYS,    0 ],
	[ "borderWidthRight",  K_WIDGET_BORDER_RIGHT_WIDTH_PROPERTY_KEYS,  0 ],
	[ "borderWidthBottom", K_WIDGET_BORDER_BOTTOM_WIDTH_PROPERTY_KEYS, 0 ],
	[ "borderColorLeft",   K_WIDGET_BORDER_LEFT_COLOR_PROPERTY_KEYS,   0, "resolveColor" ],
	[ "borderColorTop",    K_WIDGET_BORDER_TOP_COLOR_PROPERTY_KEYS,    0, "resolveColor" ],
	[ "borderColorRight",  K_WIDGET_BORDER_RIGHT_COLOR_PROPERTY_KEYS,  0, "resolveColor" ],
	[ "borderColorBottom", K_WIDGET_BORDER_BOTTOM_COLOR_PROPERTY_KEYS, 0, "resolveColor" ],
	[ "borderStyleLeft",   K_WIDGET_BORDER_LEFT_STYLE_PROPERTY_KEYS,   BORDER_STYLE_NONE ],
	[ "borderStyleTop",    K_WIDGET_BORDER_TOP_STYLE_PROPERTY_KEYS,    BORDER_STYLE_NONE ],
	[ "borderStyleRight",  K_WIDGET_BORDER_RIGHT_STYLE_PROPERTY_KEYS,  BORDER_STYLE_NONE ],
	[ "borderStyleBottom", K_WIDGET_BORDER_BOTTOM_STYLE_PROPERTY_KEYS, BORDER_STYLE_NONE ],
	[ "borderRadiusLeftTop",     K_WIDGET_BORDER_LEFTTOP_RADIUS_PROPERTY_KEYS,     0 ],
	[ "borderRadiusRightTop",    K_WIDGET_BORDER_RIGHTTOP_RADIUS_PROPERTY_KEYS,    0 ],
	[ "borderRadiusLeftBottom",  K_WIDGET_BORDER_LEFTBOTTOM_RADIUS_PROPERTY_KEYS,  0 ],
	[ "borderRadiusRightBottom", K_WIDGET_BORDER_RIGHTBOTTOM_RADIUS_PROPERTY_KEYS, 0 ]
];

global.K_APPEARANCE_STYLE_MODIFIED_MASK = 1 << 0;
global.K_LOCATE_STYLE_MODIFIED_MASK     = 1 << 1;
global.K_FONT_STYLE_MODIFIED_MASK       = 1 << 2;
global.K_LAYOUT_STYLE_MODIFIED_MASK     = 1 << 3;
global.K_BORDER_STYLE_MODIFIED_MASK     = 1 << 4;
global.K_WIDGET_STYLE_MODIFIED_MASK     = 1 << 5;

/*------------------------------
 * ドラッグ用パケット
 ------------------------------*/
class KPacket
{
	var name, arg;

	/**------------------------------
	 * コンストラクタ
	 *
	 * ドラッグ用パケットを作る
	 *
	 * @param name 名前
	 * @param arg 引数
	 ------------------------------*/
	function KPacket(name, arg) {
		this.name = name;
		this.arg = arg;
	}
}


/**----------------------------------------------------------------------
 * ウィジェット基底クラス
 ----------------------------------------------------------------------*/
class KWidget extends Layer
{
	// ウィジェットの最小、最大サイズ
	var _computed = %[];
	var _marginal = %[];
	var _specified = %[];
	// ウィジェットの上下左右のマージン
	var _marginLeft, _marginTop, _marginRight, _marginBottom;
	// ウィジェットのアライメント
	var _alignHorizontal, _alignVertical;
	// スペース
	var _spaceHorizontal, _spaceVertical;
	// フォントフェイス
	var _fontFace;
	// フォントヘイト
	var _fontHeight;
	// フォントカラー
	var _fontColor;
	// フォントアンチエイリアス
	var _fontAntiAlias;
	// オプション
	var _options;
	// スタイル
	var _theme;
	var _style = %[], _styleArch;
	var _styleChain;
	var _styleModificationDelayRefCount = 0;
	var _styleModificationLocked = false;
	var _lockStyleModificationOnAttach = false;
	var _styleModified = false;
	var appearanceStyle = %[ compositeState: [], statePriority: [], callback: "" ];
	var fontStyle;
	var borderStyle;
	var layoutStyle;
	var locateStyle;
	var widgetStyle;

	// nameプロパティを上書き
	var _name;
	// idプロパティ
	var _id = "";
	// 辞書登録を避けるかどうか
	var _isAvoidDictionaryRegistration = false;
	var _allowChildDictionaryRegistration = true;
	// Ｄ＆Ｄ
	var _pressing = false;
	var isReadyToDrag, isDragging;
	var myDraggingPacket;
	var mouseDownX, mouseDownY;
	var dragStartX, dragStartY;
	var curDragTarget, curDragTargetAcceptPacket;
	var dragEnabledShiftMask;
	var cursorOrig;
	// ステータス関連
	var _status;
	var _inStatus;
	// ウィジェット
	var _nameCache = %[];
	// 不定値
	var _indeterminate = false;
	// ドラッグ閾値
	var mouseDragThreshold = 4;
	// ヴァーチャルウィジェットのウィンドウ親
	var isVirtualWidgetWindowedParent = false;
	// クラスツリー
	var _classTrees;
	// ウィンドウにアタッチ済み
	var _isAttachedToWindow = false;
	// ホバー状態
	var hover = false;
	// ドラッグホバー状態
	var dragHover = false;
	// 辞書
	var _dict;
	// 祖先
	var _ancestors;
	// スタイル更新フラグ
	var _styleModifiedMask = 0;
	// スタイルコールバック
	var styleCallback = "";
	var omitText = "...";
	
	/**------------------------------
	 * コンストラクタ
	 *
	 * @param win ウィジェットの属するウィンドウ
	 * options
     name: 名前
     id: ID
     status: ステータス
     hint: ヒント
     style: スタイル
	 ------------------------------*/
	function KWidget(win, options = %[]) {
		if (! (win instanceof "KWindow"))
			throw new Exception("first option must be KWindow.");

		// nameを指定している旧形式なら、optionsへ自動的に変換する
		if (! (options instanceof "Dictionary"))
			options = %[ name: options ];

		if (typeof(options.hint) != K_UNDEFINED
			&& options.hint === "") {
			options = duplicateStruct(options);
			delete options.hint;
		}

		if (options.primary)
			super.Layer(win, null);
		else
			super.Layer(win, win.primaryWidget.widgetDepot);

		_options = options;
		// スタイルを取得
		initStyleObject();
		_theme = getOption("theme", "");
		_styleArch = styleRepository.normalizeStyle(getOption("style", %[]));
		// IDを設定
		_id = getOption("id", "");
		// 名前を設定
		_name = getOption("name", void);
		// 最小・最大サイズを暫定サイズに決定
		_marginal = %[ minw: getOption("marginalMinWidth", 0),
					   minh: getOption("marginalMinHeight", 0),
					   maxw: getOption("marginalMaxWidth", 0),
					   maxh: getOption("marginalMaxHeight", 0) ];
		_computed.minw = _specified.minw = width;
		_computed.maxw = _specified.maxw = width;
		_computed.minh = _specified.minh = height;
		_computed.maxh = _specified.maxh = height;
		// マージンを暫定値に決定
		_marginLeft = win.defaultMarginLeft;
		_marginTop = win.defaultMarginTop;
		_marginRight = win.defaultMarginRight;
		_marginBottom = win.defaultMarginBottom;
		// アラインメントを暫定値に決定
		_alignVertical = win.defaultAlignVertical;
		_alignHorizontal = win.defaultAlignHorizontal;
		// スペースを暫定値に決定
		_spaceHorizontal = win.defaultSpaceHorizontal;
		_spaceVertical = win.defaultSpaceVertical;
		// デフォルトのフォントを決定
		_fontFace = font.face = win.defaultFontFace;
		_fontHeight = font.height = win.defaultFontHeight;
		_fontColor = win.defaultFontColor;
		// ミドルボタンドラッグ
		_middleButtonDrag = getOption("middleButtonDrag", false);
		// 可視
		visible = getOption("visible", true);
		// ドラッグ初期化
		isDragging = isReadyToDrag = false;
		curDragTargetAcceptPacket = false;
		dragEnabledShiftMask = 0;
		// 辞書登録回避
		_isAvoidDictionaryRegistration = getOption("isAvoidDictionaryRegistration", false);
		// ステータス初期化
		_status = getOption("status", "");
		_inStatus = false;
		// ヒント初期化
		hint = getOption("hint", "");
		// アタッチ時のロック動作制御
		_lockStyleModificationOnAttach = getOption("lockStyleModificationOnAttach", false);
		// missing を有効にする
		Scripts.setCallMissing(this);
	}

	/**------------------------------
	 * デストラクタ
	 *
	 * 自動的に、自分が保持している子レイヤーを全てinvalidateする。
	 ------------------------------*/
	function finalize {
		invalidate(_middleButtonDragInterp);
		// 辞書を解除
		if (_dict !== void)
			onUnbindPersistentDictionary(_dict);
		// 子レイヤーを全て破棄する
		discardArray(children);
		super.finalize(...);
	}

	/**------------------------------
	 * アイコンを探す
	 ------------------------------*/
	function findIcon(filename) {
		return window.primaryWidget.findIcon(filename);
	}

	/**------------------------------
	 * 引数を解析する
	 ------------------------------*/
	function parseOldStyleWidgetArgs(format, args*) {
		if (args.count == 1
			&& args[0] instanceof "Dictionary")
			return args[0];

		var style = %[];

		for (var i = 0; i < format.count; i++) {
			var key = format[i].key;
			if (args[i] === void)
				style[key] = format[i].defaultValue;
			else
				style[key] = args[i];
		}
		return style;
	}

	/**------------------------------
	 * スタイルプロパティを取得
	 ------------------------------*/
	property styleParent {
		getter {
			if (_isAttachedToWindow)
				return parent;
			else
				return styleRepository;
		}
	}

	var customStyleStates = [];
	var styleStates = [];

	function onFocus {
		updateStyleStates();
		invalidateStyles();
		updateAncestorsStates();
	}

	function onBlur {
		updateStyleStates();
		invalidateStyles();
		updateAncestorsStates();
	}

	function hasStyleState(state) {
		return styleStates.find(state) >= 0;
	}

	function addCustomStyleState(state, onlyAdd = false) {
		customStyleStates.add(state);
		updateStyleStates();
		if (onlyAdd)
			return;
		invalidateStyles();
	}

	function removeCustomStyleState(state) {
		customStyleStates.remove(state, true);
		updateStyleStates();
		invalidateStyles();
	}

	function addRemoveCustomStyleState(addState, removeState) {
		customStyleStates.add(addState);
		customStyleStates.remove(removeState, true);
		updateStyleStates();
		invalidateStyles();
	}

	function updateCustomStyleStates(states) {
		customStyleStates = states;
		updateStyleStates();
		invalidateStyles();
	}

	function updateStyleStates() {
		var prevStates = duplicateStruct(styleStates);
		styleStates.assign(customStyleStates);
		if (! nodeEnabled)
			styleStates.add("nodeDisabled");
		if (_indeterminate)
			styleStates.add("indeterminate");
		if (isDragging)
			styleStates.add("drag");
		var leftButton = System.getKeyState(VK_LBUTTON);
		var rightButton = System.getKeyState(VK_RBUTTON);
		if (_pressing) {
			if (leftButton)
				styleStates.add("mouseDownLeft");
			if (rightButton)
				styleStates.add("mouseDownRight");
			if (leftButton || rightButton)
				styleStates.add("mouseDown");
		}
		if (hover)
			styleStates.add("hover");
		if (dragHover)
			styleStates.add("dragHover");
		if (focused)
			styleStates.add("focus");

		if (isAncestorOf(window.focusedLayer)) {
			if (window.focusedLayer.hover)
			styleStates.add("descendantHover");
			if (window.focusedLayer.dragHover)
				styleStates.add("descendantDragHover");
			if (window.focusedLayer.focused)
				styleStates.add("descendantFocus");
		}

		resolveCompositeState(styleStates);
		resolveStatePriority(styleStates);

		return ! equalStruct(prevStates, styleStates);
	}

	function resolveCompositeState(states) {
		var compositeState = appearanceStyle.compositeState;
		if (compositeState.count == 0)
			return;
		var insertionIndex = states.count;
		var foundStates = [];
		for (var i = 0; i < compositeState.count; i++) {
			var target = compositeState[i];
			var index = states.find(target);
			if (index < 0)
				continue;
			insertionIndex = Math.min(index, insertionIndex);
			foundStates.add(target);
		}
		if (foundStates.count <= 1)
			return;
		var result = foundStates[0];
		for (var i = 1; i < foundStates.count; i++) {
			var state = foundStates[i];
			result += state[0].toUpperCase() + state.substr(1);
		}
		states.insert(insertionIndex, result);
	}

	function resolveStatePriority(states) {
		var statePriority = appearanceStyle.statePriority;
		if (statePriority.count <= 1)
			return;

		var matched = [];
		for (var i = 0; i < statePriority.count; i++) {
			var state = statePriority[i];
			if (states.find(state) >= 0)
				matched.add(state);
		}

		if (matched.count <= 1)
			return;

		for (var i = 0; i < matched.count - 1; i++) {
			var priorState = matched[i];
			var priorStateIndex = states.find(priorState);
			for (var j = i + 1; j < matched.count; j++) {
				var comparedState = matched[j];
				var comparedStateIndex = states.find(comparedState);
				if (comparedStateIndex < priorStateIndex) {
					states.insert(priorStateIndex + 1, comparedState);
					states.erase(comparedStateIndex);
				}
			}
		}
	}

	function updateAncestorsStates() {
		var list = ancestors;
		for (var i = 0; i < list.count; i++)
			if (list[i].updateStyleStates())
				list[i].invalidateStyles();
	}

	function onNodeEnabled() {
		updateStyleStates();
		invalidateStyles();
	}

	function onNodeDisabled() {
		updateStyleStates();
		invalidateStyles();
	}

	function updateTheme() {
		_style = unionDictionary(styleRepository.findTheme(_theme), _styleArch, true);
	}

	function testStyleModification() {
		if (_styleModified
			&& respondToStyleModification) {
			_styleModified = false;
			onStyleModified();
		}
	}

	function requireStyleModificationDelay {
		_styleModificationDelayRefCount++;
	}

	function releaseStyleModificationDelay {
		_styleModificationDelayRefCount--;
		testStyleModification();
	}

	function lockStyleModification() {
		_styleModificationLocked = true;
	}

	function unlockStyleModification() {
		_styleModificationLocked = false;
		testStyleModification();
	}

	property respondToStyleModification {
		getter {
			return _styleModificationDelayRefCount == 0
				&& ! _styleModificationLocked;
		}
	}

	property styleModified {
		getter {
			return _styleModified;
		}
		setter (v) {
			_styleModified = v;
		}
	}

	function onStyleModified() {
	}

	function onChildLocateStyleModified() {
	}

	property defaultDefinitions {
		getter {
			return [ K_WIDGET_APPEARANCE_STYLE_DEFINITION,
					 K_WIDGET_LOCATE_STYLE_DEFINITIION,
					 K_WIDGET_FONT_STYLE_DEFINITION,
					 K_WIDGET_LAYOUT_STYLE_DEFINITION,
					 K_WIDGET_BORDER_STYLE_DEFNITION,
					 widgetStyleDefinition ];
		}
	}

	/*------------------------------
	 * スタイル更新マスク
	 ------------------------------*/
	function clearStyleModifiedMask() {
		_styleModifiedMask = 0;
	}

	property appearanceStyleModified {
		getter {
			return (_styleModifiedMask & K_APPEARANCE_STYLE_MODIFIED_MASK) != 0;
		}
		setter (v) {
			if (v)
				_styleModifiedMask |= K_APPEARANCE_STYLE_MODIFIED_MASK;
			else
				_styleModifiedMask &= ~K_APPEARANCE_STYLE_MODIFIED_MASK;
		}
	}

	property locateStyleModified {
		getter {
			return (_styleModifiedMask & K_LOCATE_STYLE_MODIFIED_MASK) != 0;
		}
		setter (v) {
			if (v)
				_styleModifiedMask |= K_LOCATE_STYLE_MODIFIED_MASK;
			else
				_styleModifiedMask &= ~K_LOCATE_STYLE_MODIFIED_MASK;
		}
	}

	property fontStyleModified {
		getter {
			return (_styleModifiedMask & K_FONT_STYLE_MODIFIED_MASK) != 0;
		}
		setter (v) {
			if (v)
				_styleModifiedMask |= K_FONT_STYLE_MODIFIED_MASK;
			else
				_styleModifiedMask &= ~K_FONT_STYLE_MODIFIED_MASK;
		}
	}

	property layoutStyleModified {
		getter {
			return (_styleModifiedMask & K_LAYOUT_STYLE_MODIFIED_MASK) != 0;
		}
		setter (v) {
			if (v)
				_styleModifiedMask |= K_LAYOUT_STYLE_MODIFIED_MASK;
			else
				_styleModifiedMask &= ~K_LAYOUT_STYLE_MODIFIED_MASK;
		}
	}

	property borderStyleModified {
		getter {
			return (_styleModifiedMask & K_BORDER_STYLE_MODIFIED_MASK) != 0;
		}
		setter (v) {
			if (v)
				_styleModifiedMask |= K_BORDER_STYLE_MODIFIED_MASK;
			else
				_styleModifiedMask &= ~K_BORDER_STYLE_MODIFIED_MASK;
		}
	}

	property widgetStyleModified {
		getter {
			return (_styleModifiedMask & K_WIDGET_STYLE_MODIFIED_MASK) != 0;
		}
		setter (v) {
			if (v)
				_styleModifiedMask |= K_WIDGET_STYLE_MODIFIED_MASK;
			else
				_styleModifiedMask &= ~K_WIDGET_STYLE_MODIFIED_MASK;
		}
	}

	/*------------------------------
	 * スタイルが配列中のキーをひとつでも持つか判定
	 ------------------------------*/
	function isStyleHasAnyKey(style, keys) {
		for (var i = 0; i < keys.count; i++)
			if (typeof(style[keys[i]]) !== K_UNDEFINED)
				return true;
	}

	/**------------------------------
	 * スタイルを上書き
	 ------------------------------*/
	function overwriteStyle(newStyle) {
		var oldStyle = duplicateStruct(_styleArch);
		newStyle = styleRepository.normalizeStyle(newStyle);
		(Dictionary.assign incontextof _styleArch)(newStyle, false) ;
		if (equalStructNumericLoose(oldStyle, _styleArch))
			return;
		updateTheme();
		invalidateStylesToDescendants();
	}

	/**------------------------------
	 * ウィジェットオプションを取得
	 ------------------------------*/
	function getOption(key, defaultValue, options = _options) {
		if (typeof(options[key]) != K_UNDEFINED)
			return options[key];
		else
			return defaultValue;
	}

	/**------------------------------
	 * nameプロパティを文字列以外も受け取るように変更
	 ------------------------------*/
	property name {
		getter {
			return _name;
		}
		setter (v) {
			_name = v;
		}
	}

	/**------------------------------
	 * id プロパティを更新
	 ------------------------------*/
	property id {
		getter {
			return _id;
		}
		setter(v) {
			if (_id == v)
				return;
			_id = v;
			invalidateStyles();
		}
	}

	/**------------------------------
	 * 不定値
	 *
	 * valueの値が不定であるかどうかを設定する
	 ------------------------------*/
	property indeterminate {
		getter {
			return _indeterminate;
		}
		setter (v) {
			if (v == _indeterminate)
				return;
			_indeterminate = v;
			updateStyleStates();
			invalidateStyles();
		}
	}

	/**------------------------------
	 * 可視
	 *
	 * 可視状態の変更は親へ通知される。
	 ------------------------------*/
	property visible {
		getter {
			return super.visible;
		}
		setter (v) {
			if (super.visible == v)
				return;
			super.visible = v;
			if (isInWidgetTree)
				parentWidget.onChildVisibleModified(this, v);
		}
	}

	/**------------------------------
	 * 子の可視状態が変更された時に呼ばれるフック
	 *
	 * 可視状態の変更は親へ通知される。
	 ------------------------------*/
	function onChildVisibleModified(child, value) {
	}

	/**------------------------------
	 * ステータス
	 *
	 * ステータスバーに表示するステータス文字列を設定します。
	 * ウィンドウにKStatusBarが登録されていれば、ウィジェットに
	 * マウスが侵入した時に、自動的にステータス文字列が表示されます。
	 *
	 * @param v ステータス
	 * @return ステータス
	 ------------------------------*/
	property status {
		getter {
			for (var w = this; w != null; w = w.parent)
				if (w._status.length)
					return w._status;
			return "";
		}
		setter (v) {
			_status = v;
			if (_inStatus
				&& window.statusBar !== void) {
				window.statusBar.label = _status;
			}
		}
	}

	/**------------------------------
	 * クラスツリー
	 *
	 * @return 自分自身の属するクラスツリーを配列で返す
	 ------------------------------*/
	property classTrees {
		getter {
			if (_classTrees === void)
				_classTrees = Scripts.getClassNames(this);
			return _classTrees;
		}
	}

	/**------------------------------
	 * クラス名
	 *
	 * @return 自分自身のクラス名を返す
	 ------------------------------*/
	property className {
		getter {
			return classTrees[0];
		}
	}

	/**------------------------------
	 * 親ウィジェット。
	 *
	 * @return プライマリレイヤならwindowを、それ以外のレイヤならparentを返す
	 ------------------------------*/
	property parentWidget {
		getter {
			if (isPrimary)
				return window;
			else
				return parent;
		}
	}

	/**------------------------------
	 * ウィジェットデポット
	 *
	 * addする前のウィジェットを格納する親レイヤ。ウィジェットの一時保管所
	 ------------------------------*/
	property widgetDepot {
		getter {
			return window.primaryWidget.widgetDepot;
		}
	}

	/**------------------------------
	 * ウィジェットツリーの中に存在するかどうか
	 ------------------------------*/
	property isInWidgetTree {
		getter {
			if (isPrimary)
				return true;
			else
				return parent != widgetDepot;
		}
	}

	/**------------------------------
	 * 祖先ウィジェットの一覧
	 ------------------------------*/
    property ancestors {
		getter {
			if (_ancestors !== void) 
				return duplicateStruct(_ancestors);
			var result;
			if (isPrimary)
				result = [];
			else {
				if (parent instanceof "KWidget") {
					result = parent.ancestors;
					result.add(parent);
				} else {
					result = [];
				}
			}
			if (_isAttachedToWindow) 
				_ancestors = result;
			return duplicateStruct(result);
		}
	}

	// 祖先であるかどうか判定
	function isWidgetAncestorOf(item) {
		if (item === void)
			return false;
		for (; item instanceof "KWidget"; item = item.parent) {
			if (item == this)
				return true;
		}
		return false;
	}

	// 祖先であるかどうか判定
	function isAncestorOf(item) {
		return isWidgetAncestorOf(item);
	}

	/**------------------------------
	 * 子孫ウィジェットの一覧
	 ------------------------------*/
	property descendants {
		getter {
			var result = [];
			for (var i = 0; i < children.count; i++) {
				var child = children[i];
				if (child instanceof "KWidget") {
					result.add(child);
					var childDescendants = child.descendants;
					for (var j = 0; j < childDescendants.count; j++)
						result.add(childDescendants[j]);
				}
			}
			return result;
		}
	}

	property widgetDescendants {
		getter {
			var result = [];
			for (var i = 0; i < children.count; i++) {
				var child = children[i];
				if (child instanceof "KWidget") {
					result.add(child);
					var childDescendants = child.widgetDescendants;
					for (var j = 0; j < childDescendants.count; j++)
						result.add(childDescendants[j]);
				}
			}
			return result;
		}
	}

	// 子孫判定
	function isDescendantOf(item) {
		if (item === void)
			return false;
		return item.isAncestorOf(this);
	}

	/**------------------------------
	 * 子孫ウィジェットから特定の名前を持った子ウィジェットを捜す
	 ------------------------------*/
	var _findPath = [];

	function find(name) {
		if (this.name === name)
			return this;
		for (var i = 0; i < children.count; i++) {
			var child = children[i];
			if (child instanceof "KWidget") {
				var widget = child.find(name);
				if (widget)
					return widget;
			}
		}
		for (var i = 0; i < _findPath.count; i++) {
			var object = _findPath[i];
			var widget = object.find(name);
			if (widget)
				return widget;
		}
		return void;
	}

	function addFindPath(object) {
		_findPath.add(object);
	}

	function removeFindPath(object) {
		_findPath.remove(object);
		_nameCache = %[];
	}

	function clearFindPath() {
		_findPath.clear();
		_nameCache = %[];
	}

	/**------------------------------
	 * ウィジェットツリーから特定の名前を持った子ウィジェットを捜します
	 *
	 * find関数を経由せずに、オブジェクトのプロパティ扱いで名前を指定して
	 * ウィジェットツリー中のウィジェットを参照することが出来ます。
	 *
	 * パフォーマンスの都合で、グローバルに同名のシンボルが存在する場合は
	 * 優先的にそちらを見に行くという挙動をするので注意。
	 ------------------------------*/
	function missing(get_or_set, name, value) {
		if (! get_or_set) {
			if (typeof(global[name]) != "undefined")
				return false;
			if (typeof(_nameCache[name]) != "undefined") {
				var widget = _nameCache[name];
				if (widget isvalid
					&& widget.name == name) {
						*value = widget;
					return true;
				} else {
					delete _nameCache[name];
				}
			}
			var widget = find(name);
			if (widget) {
				_nameCache[name] = widget;
					*value = widget;
				return true;
			}
		}
		return false;
	}

	/**------------------------------
	 * 指定位置のウィジェットを取得
	 *
	 * @param x 取得したいウィジェットの位置の x 座標を表示座標上でピクセル単位で指定します。
	 * @param y 取得したいウィジェットの位置の y 座標を表示座標上でピクセル単位で指定します。
	 * @param exclude_self 　ウィジェットの検索から自分自身を除外するかどうかを指定します。
	 * @param get_disabled 　無効になっているウィジェットのオブジェクトを得るかどうかを指定します。
	 ------------------------------*/
	function getWidgetAt(x, y, exclude_self = false, get_disabled = false) {
		for (var targetLayer = getLayerAt(x, y, exclude_self, get_disabled);
			 targetLayer;
			 targetLayer = targetLayer.parent) {
			if ((targetLayer instanceof "KWidget")) {
				if (exclude_self)
					return void;
				else
					return targetLayer;
			}
		}
		return void;
	}

	/*----------------------------------------------------------------------
	 * ウィンドウにアタッチ済みかどうか
	 ----------------------------------------------------------------------*/
	property isAttachedToWindow {
		getter {
			return _isAttachedToWindow;
		}
		setter (v) {
			if (v == _isAttachedToWindow)
				return;
			_isAttachedToWindow = v;
			_ancestors = void;
		}
	}

	// ウィンドウにアタッチ
	function attachToWindow() {
		clearStyleFragCache();

		if (isInWidgetTree)
			parentWidget.requireStyleModificationDelay();

		var widgets = widgetDescendants;
		widgets.insert(0, this);

		widgets.reverse();

		for (var i = 0; i < widgets.count; i++) {
			var widget = widgets[i];
			if (widget._lockStyleModificationOnAttach)
				widget.lockStyleModification();
			widget.requireStyleModificationDelay();
			widget.clearStyleFragCache();
			widget.isAttachedToWindow = true;
			widget.updateTheme();
		}

		for (var i = 0; i < widgets.count; i++) {
			var widget = widgets[i];
			widget.updateStyleStates();
			widget.invalidateStyles();
			widget.onAttachedToWindow();
			widget.releaseStyleModificationDelay();
		}

		if (isInWidgetTree)
			parentWidget.releaseStyleModificationDelay();
	}

	// ウィンドウからデタッチ
	function detachFromWindow() {
		var widgets = widgetDescendants;
		widgets.insert(0, this);

		for (var i = 0; i < widgets.count; i++) {
			var widget = widgets[i];
			widget.isAttachedToWindow = false;
			widget.onDetachedFromWindow();
		}
	}

	// ウィンドウにアタッチされた時に呼ばれるフック関数
	function onAttachedToWindow() {
	}

	// ウィンドウからデタッチされた時に呼ばれるフック関数
	function onDetachedFromWindow() {
	}

	/*----------------------------------------------------------------------
	 * ボーダースタイルの適用
	 ----------------------------------------------------------------------*/
	function extractBorderStyle() {
		return extractStyle(K_WIDGET_BORDER_STYLE_DEFNITION);
	}

	function updateBorderStyle() {
		var newStyle = extractBorderStyle();

		if (equalStruct(borderStyle, newStyle))
			return false;

		borderStyle = newStyle;
		borderStyleModified = true;

		return true;
	}

	/*----------------------------------------------------------------------
	 * アピアランススタイルの適用
	 ----------------------------------------------------------------------*/
	function extractAppearanceStyle() {
		return extractStyle(K_WIDGET_APPEARANCE_STYLE_DEFINITION);
	}

	function updateAppearanceStyle() {
		var newStyle = extractAppearanceStyle();

		if (equalStruct(appearanceStyle, newStyle))
			return false;

		appearanceStyle = newStyle;
		appearanceStyleModified = true;

		return true;
	}

	/*----------------------------------------------------------------------
	 * フォントスタイルの適用
	 ----------------------------------------------------------------------*/
	function extractFontStyle() {
		return extractStyle(K_WIDGET_FONT_STYLE_DEFINITION);
	}

	function updateFontStyle() {
		var newStyle = extractFontStyle();

		if (equalStruct(fontStyle, newStyle))
			return false;

		fontStyle = newStyle;
		fontStyleModified = true;

		return true;
	}

	function applyFontStyle(font, fontStyle) {
		font.height =    fontStyle.fontHeight;
		font.face =      fontStyle.fontFace;
		font.bold =      fontStyle.fontBold;
		font.italic =    fontStyle.fontItalic;
		font.strikeout = fontStyle.fontStrikeout;
		font.underline = fontStyle.fontUnderline;
	}

	/*----------------------------------------------------------------------
	 * レイアウトスタイルの適用
	 ----------------------------------------------------------------------*/
	function extractLayoutStyle() {
		return extractStyle(K_WIDGET_LAYOUT_STYLE_DEFINITION);
	}

	function updateLayoutStyle() {
		var newStyle = extractLayoutStyle();

		if (equalStruct(layoutStyle, newStyle))
			return false;

		layoutStyle = newStyle;
		layoutStyleModified = true;

		return true;
	}

	function resolvePaddingLeft(v, style) {
		return v + style.paddingOffsetHorizontal + style.paddingInsetHorizontal;
	}

	function resolvePaddingTop(v, style) {
		return v + style.paddingOffsetVertical + style.paddingInsetVertical;
	}

	function resolvePaddingRight(v, style) {
		return v - style.paddingOffsetHorizontal + style.paddingInsetHorizontal;
	}

	function resolvePaddingBottom(v, style) {
		return v - style.paddingOffsetVertical   + style.paddingInsetVertical;
	}

	/*----------------------------------------------------------------------
	 * パディングの参照
	 ----------------------------------------------------------------------*/
	property paddingLeft {
		getter {
			return layoutStyle.paddingLeft;
		}
	}

	property paddingTop {
		getter {
			return layoutStyle.paddingTop;
		}
	}

	property paddingRight {
		getter {
			return layoutStyle.paddingRight;
		}
	}

	property paddingBottom {
		getter {
			return layoutStyle.paddingBottom;
		}
	}

	/*----------------------------------------------------------------------
	 * ロケートスタイルの適用
	 ----------------------------------------------------------------------*/
	function extractLocateStyle {
		return extractStyle(K_WIDGET_LOCATE_STYLE_DEFINITIION);
	}

	function updateLocateStyle() {
		var newStyle = extractLocateStyle();

		if (equalStruct(locateStyle, newStyle))
			return false;

		locateStyle = newStyle;
		locateStyleModified = true;

		return true;
	}

	/*----------------------------------------------------------------------
	 * ウィジェットスタイルの適用
	 ----------------------------------------------------------------------*/
	property widgetStyleDefinition {
		getter {
			return [];
		}
	}

	function extractWidgetStyle {
		var widgetStyle = extractStyle(widgetStyleDefinition);
		onExtractWidgetStyle(widgetStyle);
		return widgetStyle;
	}

	function onExtractWidgetStyle(widgetStyle) {
	}

	function updateWidgetStyle() {
		var newStyle = extractWidgetStyle();

		if (equalStruct(widgetStyle, newStyle))
			return false;

		widgetStyle = newStyle;
		widgetStyleModified = true;

		return true;
	}

	function earlyUpdateWidgetStyle() {
		updateTheme();
		updateStyleComp(styleRepository.getWidgetStyleDefinition(this), "earlywidget");
		updateWidgetStyle();
	}

	/*----------------------------------------------------------------------
	 * スタイルプロパティのショートカット
	 ----------------------------------------------------------------------*/
	property borderPaddingLeft {
		getter {
			return layoutStyle.paddingLeft + borderStyle.borderWidthLeft;
		}
	}

	property borderPaddingRight {
		getter {
			return layoutStyle.paddingRight + borderStyle.borderWidthRight;
		}
	}

	property borderPaddingTop {
		getter {
			return layoutStyle.paddingTop + borderStyle.borderWidthTop;
		}
	}

	property borderPaddingBottom {
		getter {
			return layoutStyle.paddingBottom + borderStyle.borderWidthBottom;
		}
	}

	property borderPaddingWidth {
		getter {
			return borderPaddingLeft + borderPaddingRight;
		}
	}

	property borderPaddingHeight {
		getter {
			return borderPaddingTop + borderPaddingBottom;
		}
	}

	//------------------------------
	// スタイルの更新チェックを子へ波及させる
	//------------------------------
	function invalidateStylesToDescendants(fullUpdate = false) {
		if (isInWidgetTree)
			parentWidget.requireStyleModificationDelay();
		clearStyleFragCache();

		var widgets = widgetDescendants;
		widgets.insert(0, this);

		widgets.reverse();

		for (var i = 0; i < widgets.count; i++) {
			var widget = widgets[i];
			widget.requireStyleModificationDelay();
			widget.clearStyleFragCache();
		}

		for (var i = 0; i < widgets.count; i++) {
			var widget = widgets[i];
			if (widget._lockStyleModificationOnAttach)
				widget.lockStyleModification();
			if (fullUpdate) {
				widget.beforeStyleFullUpdate();
				widget.updateTheme();
			}
			widget.invalidateStyles();
			if (fullUpdate)
				widget.afterStyleFullUpdate();
			widget.releaseStyleModificationDelay();
		}

		if (isInWidgetTree)
			parentWidget.releaseStyleModificationDelay();
	}

	function beforeStyleFullUpdate() {
	}

	function afterStyleFullUpdate() {
	}

	//------------------------------
	// スタイルの更新チェック
	//------------------------------
	function invalidateStyles(force = false) {
		if (! force &&
			! isAttachedToWindow)
			return;
		if (isInWidgetTree)
			parentWidget.requireStyleModificationDelay();
		requireStyleModificationDelay();
		updateStyleComp();
		var modified = false;
		modified ||= updateAppearanceStyle();
		modified ||= updateBorderStyle();
		modified ||= updateFontStyle();
		modified ||= updateLayoutStyle();
		modified ||= updateWidgetStyle();
		if (modified)
			onStyleModified();
		modified = updateLocateStyle();
		if (modified
			&& isInWidgetTree)
			parentWidget.onChildLocateStyleModified();
		releaseStyleModificationDelay();
		if (isInWidgetTree)
			parentWidget.releaseStyleModificationDelay();
		invalidateStyleCallback();
	}

	function invalidateStyleCallback() {
		if (styleCallback == appearanceStyle.callback)
			return;
		styleCallback = appearanceStyle.callback;
		if (styleCallback != ""
			&& typeof(this[styleCallback]) != K_UNDEFINED)
			this[styleCallback]();
	}

	/*----------------------------------------------------------------------
	 * parentプロパティの拡張
	 *
	 * parentが更新された時に、onParentModifiedが呼ばれるようにする
	 ----------------------------------------------------------------------*/
	property parent {
		getter {
			return super.parent;
		}

		setter(v) {
			if (super.parent == v)
				return;

			var prev = super.parent;
			super.parent = v;

			if (v !== widgetDepot) {
				if (v.isAttachedToWindow)
					attachToWindow();
			} else {
				if (prev.isAttachedToWindow)
					detachFromWindow();
			}

			onParentModified(v == widgetDepot ? void : v);
		}
	}

	/**----------------------------------------------------------------------
	 * parentが更新された時に呼ばれる関数
	 *
	 * @param p 新しくparentになったウィジェット。removeされてdepot行きになった時はvoidが設定されて呼ばれる
	 */
	function onParentModified(parent) {
	}

	/**------------------------------
	 * 永続化辞書のバインドを避けるかどうか
	 *
	 * @param v 永続化辞書のバインドを避けるかどうか
	 * @return 永続化辞書のバインドを避けるかどうか
	 ------------------------------*/
	property isAvoidDictionaryRegistration {
		getter {
			return _isAvoidDictionaryRegistration;
		}
		setter(v) {
			_isAvoidDictionaryRegistration = v;
		}
	}

	/**------------------------------
	 * 永続化辞書をバインドする
	 *
	 * ウィジェットを KPersistentDictionary クラスのオブジェクトにバインドします。
	 * デフォルトでは、全ての子ウィジェットを探索し、それらの
	 * ウィジェットの bindPersistentDictionary を再帰的に呼び出すという動作をします。
	 *
	 * @param dict バインドする辞書
	 ------------------------------*/
	function bindPersistentDictionary(dict) {
		if (_isAvoidDictionaryRegistration)
			return;

		_dict = dict;
		onBindPersistentDictionary(dict);

		if (! _allowChildDictionaryRegistration)
			return;

		for (var i = 0; i < children.count; i++) {
			var child = children[i];
			if (child instanceof "KWidget")
				child.bindPersistentDictionary(dict);
		}
	}

	function onBindPersistentDictionary(dict) {
	}

	function onUnbindPersistentDictionary(dict) {
	}

	/**------------------------------
	 * 最小幅
	 *
	 * @return 最小幅
	 * @param w 最小幅
	 ------------------------------*/
	property minWidth {
		getter {
			return _computed.minw;
		}

		setter(w) {
			setMinMaxSize(w, _specified.minh, _specifeid.maxw, _specified.maxh);
		}
	}

	/**------------------------------
	 * 最小高さ
	 *
	 * @return 最小高さ
	 * @param w 最小高さ
	 ------------------------------*/
	property minHeight {
		getter {
			return _computed.minh;
		}

		setter(h) {
			setMinMaxSize(_specified.minw, h, _specified.maxw, _specified.maxh);
		}
	}

	/**------------------------------
	 * 最小サイズ設定
	 *
	 * @param w 最小幅
	 * @param h 最小高さ
	 ------------------------------*/
	function setMinSize(w, h) {
		setMinMaxSize(w, h, _specified.maxw, _specified.maxh);
	}

	/**------------------------------
	 * 最大幅
	 *
	 * @return 最大幅
	 * @param h 最大幅
	 ------------------------------*/
	property maxWidth {
		getter {
			return _computed.maxw;
		}

		setter(w) {
			setMinMaxSize(_specified.minw, _specified.minh, w, _specified.maxh);
		}
	}

	/**------------------------------
	 * 最大高さ
	 *
	 * @return 最大高さ
	 * @param h 最大高さ
	 ------------------------------*/
	property maxHeight {
		getter {
			return _computed.maxh;
		}

		setter(h) {
			setMinMaxSize(_specified.minw, _specified.minh, _specified.maxw, h);
		}
	}

	/*------------------------------
	 * 最大サイズ設定
	 *
	 * @param w 最大幅
	 * @param h 最大高さ
	 */
	function setMaxSize(w, h) {
		setMinMaxSize(_specified.minw, _specified.minh, w, h);
	}

	/**------------------------------
	 * 最大サイズと最小サイズを、同時に同じ値に設定
	 *
	 * @param w 幅
	 * @param h 高さ
	 ------------------------------*/
	function setFixedSize(w, h) {
		setMinMaxSize(w, h, w, h);
	}

	/**------------------------------
	 * 最大サイズと最小サイズを、イメージサイズに設定
	 *
	 * @param w 幅
	 * @param h 高さ
	 ------------------------------*/
	function setFixedSizeToImageSize() {
		setMinMaxSize(imageWidth, imageHeight, imageWidth, imageHeight);
	}

	/*------------------------------
	 * 最大サイズと最小サイズを同時設定
	 *
	 * @param minW 最小幅
	 * @param minH 最小高さ
	 * @param maxW 最大幅
	 * @param maxH 最大高さ
	 ------------------------------*/
	function setMinMaxSize(minW, minH, maxW, maxH) {
		// minとmaxの逆転をチェック
		if (minW > maxW || minH > maxH)
			throw new Exception("%s: minmax size mismatch(minw:%d,minh:%d,maxw:%d,maxh:%d".sprintf(className, minW,minH,maxW,maxH));
		_specified.minw = int(minW);
		_specified.minh = int(minH);
		_specified.maxw = int(maxW);
		_specified.maxh = int(maxH);
		invalidateMinMaxSize();
	}

	/*------------------------------
	 * 「最低限度の」「最大サイズと最小サイズを同時設定
	 *
	 * @param minW 最小幅
	 * @param minH 最小高さ
	 * @param maxW 最大幅
	 * @param maxH 最大高さ
	 ------------------------------*/
	function setMarginalMinMaxSize(minW, minH, maxW, maxH) {
		_marginal.minw = int(minW);
		_marginal.minh = int(minH);
		_marginal.maxw = int(maxW);
		_marginal.maxh = int(maxH);
		invalidateMinMaxSize();
	}

	function setMarginalMinSize(w, h) {
		setMarginalMinMaxSize(w, h, _marginal.maxw, _marginal.maxh);
	}

	function setMarginalMaxSize(w, h) {
		setMarginalMinMaxSize(_marginal.minw, _marginal.minh, w, h);
	}

	function setMarginalFixedSize(w, h) {
		setMarginalMinMaxSize(w, h, w, h);
	}

	/*------------------------------
	 * 最大最小サイズを更新
	 ------------------------------*/
	function invalidateMinMaxSize() {
		var maxw = int(Math.min(K_WIDGET_MAX_POSSIBLE_WIDTH, Math.max(_specified.maxw, _marginal.maxw)));
		var minw = int(Math.min(maxw, Math.max(_specified.minw, _marginal.minw)));
		var maxh = int(Math.min(K_WIDGET_MAX_POSSIBLE_WIDTH, Math.max(_specified.maxh, _marginal.maxh)));
		var minh = int(Math.min(maxh, Math.max(_specified.minh, _marginal.minh)));
		var newer = %[ minw: minw, minh: minh, maxw: maxw, maxh: maxh ];
		// 変更があった時のみ処理
		if (equalStructNumericLoose(_computed, newer))
			return;

		// サイズを更新
		var older = _computed;
		_computed = newer;
		// サイズ変更を親に通知
		if (isInWidgetTree)
			parentWidget.onChildMinMaxSizeModified(this,
												   newer.minw, newer.minh, newer.maxw, newer.maxh,
												   older.minw, older.minh, older.maxw, older.maxh);
		// サイズ変更
		invalidateSize();
	}

	/**----------------------------------------------------------------------
	 * 子ウィジェットの最小サイズ、最大サイズの更新に伴って呼ばれるフック関数
	 *
	 * @param child 最小・最大サイズの更新された子ウィジェット
	 * @param newMinWidth 新規最小幅
	 * @param newMinHeight 新規最小高さ
	 * @param newMaxWidth 新規最大幅
	 * @param oldMinWidth 変更前の最小幅
	 * @param oldMinHeight 変更前の最小高さ
	 * @param oldMaxWidth 変更前の最大幅
	 * @param oldMaxHeight 変更前の最大高さ
	 ----------------------------------------------------------------------*/
	function onChildMinMaxSizeModified(child,
                                       newMinWidth, newMinHeight, newMaxWidth, newMaxHeight,
                                       oldMinWidth, oldMinHeight, oldMaxWidth, oldMaxHeight) {
		if (isInWidgetTree)
			parent.onChildMinMaxSizeModified(...);
	}

	/**------------------------------
	 * ウィジェットの最大/最小サイズが変更された時に呼ばれ、
	 * 実際のサイズが変更されたかどうかを判定する関数。
	 *
	 * 実際のサイズが変更されていた場合、onSizeModified() が呼ばれる
	 ------------------------------*/
	function invalidateSize {
		// サイズを変更する
		setSize(width, height);
	}

	function setSize(newWidth, newHeight) {
		// 最小サイズと最大サイズを元に現在のサイズを丸め込み
		newWidth = int(Math.min(_computed.maxw, Math.max(_computed.minw, newWidth)));
		newHeight = int(Math.min(_computed.maxh, Math.max(_computed.minh, newHeight)));

		// サイズが変更された時のみ処理を行う
		if (newWidth == width
			&& newHeight == height)
			return;

		// 実際にサイズを変更する
		var oldWidth, oldHeight;
		oldWidth = width;
		oldHeight = height;
		super.setSize(newWidth, newHeight);

		// サイズの変更を、自分自身に通知する
		onSizeModified(newWidth, newHeight, oldWidth, oldHeight);
	}

	property width {
		getter {
			return super.width;
		}
		setter (v) {
			setSize(v, height);
		}
	}

	property height {
		getter {
			return super.height;
		}
		setter (v) {
			setSize(width, v);
		}
	}

	/**------------------------------
	 * ウィジェットの最小サイズ、最大サイズの更新に伴って
	 * ウィジェット自身のサイズが変更された時に呼ばれるフック関数。
	 *
	 * @param newWidth 新規幅
	 * @param newHeight 新規高さ
	 * @param oldWidth 変更前の幅
	 * @paarm oldHeight 変更前の幅
	 ------------------------------*/
	function onSizeModified(newWidth, newHeight, oldWidth, oldHeight) {
	}

	/**------------------------------
	 * 水平方向の区切スペースの大きさを指定します
	 *
	 * @param space スペース
	 * @return スペース
	 ------------------------------*/
	property spaceHorizontal {
		getter {
			return layoutStyle.spaceHorizontal;
		}
		setter(space) {
			if (space == _spaceHorizontal)
				return;
			var oldSpace = _spaceHorizontal;
			_spaceHorizontal = space;
			onSpaceModified(space, _spaceVertical, oldSpace, _spaceVertical);
		}
	}

	/**------------------------------
	 * 垂直方向の区切スペースの大きさを指定します
	 *
	 * @param space スペース
	 * @return スペース
	 ------------------------------*/
	property spaceVertical {
		getter {
			return layoutStyle.spaceVertical;
		}
		setter(space) {
			if (space == _spaceVertical)
				return;
			var oldSpace = _spaceVertical;
			_spaceVertical = space;
			onSpaceModified(_spaceHorizontal, space, _spaceHorizontal, _spaceVertical);
		}
	}

	/**------------------------------
	 * 水平と垂直方向の区切スペースの大きさをまとえて指定します
	 *
	 * @param space スペース
	 ------------------------------*/
	property space {
		setter(s) {
			if (s == _spaceHorizontal
				&& s == _spaceVertical)
				return;
			var oldSpaceHorizontal, oldSpaceVertical;
			oldSpaceHorizontal = _spaceHorizontal;
			oldSpaceVertical = _spaceVertical;
			_spaceHorizontal = _spaceVertical = s;
			onSpaceModified(_spaceHorizontal, _spaceVertical, oldSpaceHorizontal, oldSpaceVertical);
		}
	}

	/**------------------------------
	 * スペースが変更された時に呼ばれるフック関数
	 *
	 * @param newSpaceHorizontal 新規水平スペース
	 * @param newSpaceVertical 新規垂直スペース
	 * @param oldSpaceHorizontal 変更前の水平スペース
	 * @param newSpaceVertical 変更前の垂直スペース
	 ------------------------------*/
	function onSpaceModified(newSpaceHorizontal, newSpaceVertical,
							 oldSpaceHorizontal, oldSpaceVertical) {
		if (updateLayoutStyle()
			&& isAttachedToWindow)
			onStyleModified();
	}

	/**----------------------------------------------------------------------
	 * マージンを含めた幅(読み出し専用)
	 *
	 * @return width + marginLeft + marginRight
	 ----------------------------------------------------------------------*/
	property marginIncludeWidth {
		getter {
			return width + marginHorizontal;
		}
	}

	/**----------------------------------------------------------------------
	 * マージンを含めた高さ(読み出し専用)
	 *
	 * @return height + marginTop + marginBottom
	 ----------------------------------------------------------------------*/
	property marginIncludeHeight {
		getter {
			return height + marginVertical;
		}
	}

	/**----------------------------------------------------------------------
	 * 横方向マージンの合計(読み出し専用)
	 *
	 * @return marginLeft + marginRight
	 ----------------------------------------------------------------------*/
	property marginHorizontal {
		getter {
			return locateStyle.marginLeft + locateStyle.marginRight;
		}
	}

	/**----------------------------------------------------------------------
	 * 縦方向マージンの合計(読み出し専用)
	 *
	 * @return marginTop + marginBottom
	 ----------------------------------------------------------------------*/
	property marginVertical {
		getter {
			return locateStyle.marginTop + locateStyle.marginBottom;
		}
	}

	/**------------------------------
	 * 左マージン
	 *
	 * レイアウト時に、ウィジェットの左側にどれだけのマージンを空けるか設定します。
	 *
	 * @return 左マージン
	 * @param l 左マージン
	 ------------------------------*/
	property marginLeft {
		getter {
			return locateStyle.marginLeft;
		}

		setter(l) {
			// マージンの値が変更された時のみ処理する
			if (_marginLeft == l)
				return;
			// マージンを更新する
			invalidateMargin(l, _marginTop, _marginRight, _marginBottom);
		}
	}

	/**------------------------------
	 * 上マージン
	 *
	 * レイアウト時に、ウィジェットの上側にどれだけのマージンを空けるか設定します。
	 *
	 * @return 上マージン
	 * @param t 上マージン
	 ------------------------------*/
	property marginTop {
		getter {
			return locateStyle.marginTop;
		}

		setter(t) {
			// マージンの値が変更された時のみ処理する
			if (_marginTop == t)
				return;
			// マージンを更新する
			invalidateMargin(_marginLeft, t, _marginRight, _marginBottom);
		}
	}

	/**------------------------------
	 * 右マージン
	 *
	 * レイアウト時に、ウィジェットの右側にどれだけのマージンを空けるか設定します。
	 *
	 * @return 右マージン
	 * @param r 右マージン
	 ------------------------------*/
	property marginRight {
		getter {
			return locateStyle.marginRight;
		}

		setter(r) {
			// マージンの値が変更された時のみ処理する
			if (_marginRight == r)
				return;
			// マージンを更新する
			invalidateMargin(_marginLeft, _marginTop, r, _marginBottom);
		}
	}

	/**------------------------------
	 * 下マージン
	 *
	 * レイアウト時に、ウィジェットの下側にどれだけのマージンを空けるか設定します。
	 *
	 * @return 下マージン
	 * @param b 下マージン
	 ------------------------------*/
	property marginBottom {
		getter {
			return locateStyle.marginBottom;
		}

		setter(b) {
			// マージンの値が変更された時のみ処理する
			if (_marginBottom == b)
				return;
			// マージンを更新する
			invalidateMargin(_marginLeft, _marginTop, _marginRight, b);
		}
	}

	/**------------------------------
	 * マージンの設定
	 *
	 * マージンをまとめて設定します。
	 *
	 * 引数を1つだけ指定した場合、上下左右全てのマージンを同じ値に設定します。
	 *
	 * 引数を2つだけ指定した場合、第一引数を左右マージン、第二引数を上下マージンに設定します。
	 *
	 * 引数を4つ全て指定した場合、それぞれのマージンを個別に設定します。
	 *
	 * @param l 左マージン
	 * @param t 上マージン
	 * @param r 右マージン
	 * @param b 下マージン
	 ------------------------------*/
	function setMargin(l, t = void, r = void, b = void) {
		// 引数展開
		if (t === void) {
			t = r = b = l;
		} else if (r === void) {
			r = l;
			b = t;
		}

		// 変更があった時のみ処理
		if (_marginLeft == l
			&& _marginTop == t
			&& _marginRight == r
			&& _marginBottom == b)
			return;

		// マージン変更
		invalidateMargin(l, t, r, b);
	}

	/**------------------------------
	 * マージンの設定
	 *
	 * 上下左右全てのマージンをまとめて設定します。
	 *
	 * @param m マージン
	 ------------------------------*/
	property margin {
		setter(m) {
			// 変更があった時のみ処理
			if (_marginLeft == m
				&& _marginTop == m
				&& _marginRight == m
				&& _marginBottom == m)
				return;

			// マージン変更
			invalidateMargin(m, m, m, m);
		}
	}

	/*------------------------------
	 * ウィジェットのマージンが変更された時に呼ばれる関数。
	 *
	 * 親の onChildMarginModified() が呼ばれる
	 ------------------------------*/
	function invalidateMargin(newMarginLeft, newMarginTop, newMarginRight, newMarginBottom) {
		// 以前のマージンを記録
		var oldMarginLeft, oldMarginTop, oldMarginRight, oldMarginBottom;
		oldMarginLeft = _marginLeft;
		oldMarginTop = _marginTop;
		oldMarginRight = _marginRight;
		oldMarginBottom = _marginBottom;
		// マージンを更新
		_marginLeft = newMarginLeft;
		_marginTop = newMarginTop;
		_marginRight = newMarginRight;
		_marginBottom = newMarginBottom;
		updateLocateStyle();
		// 親に通知する
		if (isInWidgetTree)
			parentWidget.onChildMarginModified(this,
											   newMarginLeft, newMarginTop, newMarginRight, newMarginBottom,
											   oldMarginLeft, oldMarginTop, oldMarginRight, oldMarginBottom);
	}

	/**------------------------------
	 * 子ウィジェットのマージンが変更された時に呼ばれるフック関数
	 *
	 * @param child マージンの変更された子ウィジェット
	 * @param newMarginLeft   新規左マージン
	 * @param newMarginTop    新規上マージン
	 * @param newMarginRight  新規右マージン
	 * @param newMarginBottom 新規下マージン
	 * @param oldMarginLeft   変更前の左マージン
	 * @param oldMarginTop    変更前の上マージン
	 * @param oldMarginRight  変更前の右マージン
	 * @param oldMarginBottom 変更前の下マージン
	 *------------------------------*/
	function onChildMarginModified(child,
                                   newMarginLeft, newMarginTop, newMarginRight, newMarginBottom,
                                   oldMarginLeft, oldMarginTop, oldMarginRight, oldMarginBottom) {
		onChildLocateStyleModified();
	}

	/**------------------------------
	 * 水平アライメント
	 *
	 * レイアウトの関係でウィジェットが本来のサイズより大きい領域に配置されることに
	 * なった時に、ウィジェットを左右のどちらに寄せるかを設定します。
	 *
	 * ALIGN_LEFT, ALIGN_CENTER, ALIGN_RIGHT のいずれかの値を設定できます。
	 *
	 * @return 水平アライメント
	 * @param align 水平アライメン
	 ------------------------------*/
	property alignHorizontal {
		getter {
			return locateStyle.alignHorizontal;
		}
		setter(align) {
			// 変更があった時のみ更新
			if (_alignHorizontal == align)
				return;
			// 更新
			invalidateAlign(align, _alignVertical);
		}
	}


	/**------------------------------
	 * 垂直アライメント
	 *
	 * レイアウトの関係でウィジェットが本来のサイズより大きい領域に配置されることに
	 * なった時に、ウィジェットを上下のどちらに寄せるかを設定します。
	 *
	 * ALIGN_TOP, ALIGN_CENTER, ALIGN_BOTTOM のいずれかの値を設定できます。
	 *
	 * @return 垂直アライメント
	 * @param align 垂直アライメン
	 ------------------------------*/
	property alignVertical {
		getter {
			return locateStyle.alignVertical;
		}
		setter(align) {
			// 変更があった時のみ更新
			if (_alignVertical == align)
				return;
			// 更新
			invalidateAlign(_alignHorizontal, align);
		}
	}

	/**------------------------------
	 * アライメントの設定
	 *
	 * アライメントをまとめて設定します。
	 *
	 * @param h 水平アライメント
	 * @param v 垂直アライメント
	 ------------------------------*/
	function setAlign(h, v) {
		// 変更があった時のみ更新
		if (h == _alignHorizontal
			&& v == _alignVertical)
			return;
		// 更新
		invalidateAlign(h, v);
	}

	/*------------------------------
	 * ウィジェットのアライメントが変更された時に呼ばれる関数。
	 *
	 * 親の onChildMarginModified() が呼ばれる
	 ------------------------------*/
	function invalidateAlign(newAlignHorizontal, newAlignVertical) {
		// 古い値を保存
		var oldAlignHorizontal, oldAlignVertical;
		oldAlignHorizontal = _alignHorizontal;
		oldAlignVertical = _alignVertical;
		// 更新
		_alignHorizontal = newAlignHorizontal;
		_alignVertical = newAlignVertical;
		updateLocateStyle();
		// フック関数を呼ぶ
		if (isInWidgetTree)
			parentWidget.onChildAlignModified(this,
											  newAlignHorizontal, newAlignVertical,
											  oldAlignHorizontal, oldAlignVertical);
	}

	/*------------------------------
	 * 子ウィジェットのアライメントが変更された時に呼ばれるフック関数
	 *
	 * @param child アライメントの変更された子ウィジェット
	 * @param newAlignHorizontal 新規水平アライメント
	 * @param newAlignVertical 新規垂直アライメント
	 * @param oldAlignHorizontal 変更前の水平アライメント
	 * @param oldAlignVertical 変更前の垂直アライメント
	 ------------------------------*/
	function onChildAlignModified(child,
                                  newAlignHorizontal, newAlignVertical,
                                  oldAlignHorizontal, oldAlignVertical) {
		onChildLocateStyleModified();
	}

	/**------------------------------
	 * フォントフェイス
	 *
	 * フォントフェイスが更新されると onFontFaceModified 関数が呼ばれます。
	 *
	 * @param newFace 新規フェイス
	 * @return フェイス
	 ------------------------------*/
	property fontFace {
		getter {
			return fontStyle.fontFace;
		}
		setter(newFace) {
			// 更新がある時だけ処理
			if (font.face == newFace)
				return;
			// 更新
			var oldFace = font.face;
			font.face = newFace;
			// フック関数呼び出し
			onFontFaceModified(newFace, oldFace);
		}
	}

	/*------------------------------
	 * フォントフェイスが変更された時に呼ばれるフック関数
	 *
	 * @param newFontFace 新規フォントフェイス
	 * @param oldFontFace 変更前のフォントフェイス
	 *------------------------------*/
	function onFontFaceModified(newFontFace, oldFontFace) {
		if (updateFontStyle()
			&& isAttachedToWindow)
			onStyleModified();
	}

	/**------------------------------
	 * フォントヘイト
	 *
	 * フォントヘイトが更新されると onFontHeightModified 関数が呼ばれます。
	 *
	 * @param newHeight 新規ヘイト
	 * @return ヘイト
	 ------------------------------*/
	property fontHeight {
		getter {
			return fontStyle.fontHeight;
		}
		setter(newHeight) {
			// 更新がある時だけ処理
			if (font.height == newHeight)
				return;
			// 更新
			var oldHeight = font.height;
			font.height = newHeight;
			// フック関数呼び出し
			onFontHeightModified(newHeight, oldHeight);
		}
	}

	/*------------------------------
	 * フォントヘイトが変更された時に呼ばれるフック関数
	 *
	 * @param newFontHeight 新規フォントヘイト
	 * @param oldFontHeight 変更前のフォントヘイト
	 *------------------------------*/
	function onFontHeightModified(newFontHeight, oldFontHeight) {
		if (updateFontStyle()
			&& isAttachedToWindow)
			onStyleModified();
	}

	/**------------------------------
	 * フォントカラー
	 *
	 * フォントカラーが更新されると onFontColorModified 関数が呼ばれます。
	 *
	 * @param color 新規カラー
	 * @return カラー
	 ------------------------------*/
	property fontColor {
		getter {
			return fontStyle.fontColor;
		}
		setter(color) {
			// 更新がある時だけ処理
			if (color == _fontColor)
				return;
			// 更新
			var oldFontColor = _fontColor;
			_fontColor = color;
			// フック関数呼び出し
			onFontColorModified(color, oldFontColor);
		}
	}

	/**------------------------------
	 * フォントカラーが変更された時に呼ばれるフック関数
	 *
	 * @param newFontColor 新規フォントカラー
	 * @param oldFontColor 変更前のフォントカラー
	 ------------------------------*/
	function onFontColorModified(newFontColor, oldFontColor) {
		if (updateFontStyle()
			&& isAttachedToWindow)
			onStyleModified();
	}

	/**------------------------------
	 * 「値」が変わった時に呼ばれるフック関数
	 *
	 * 「値」を持つウィジェットで、値が変更された時に呼ばれます。
	 * デフォルトでは、parent の onChildValueModifiedを呼ぶように設定されています。
	 *
	 * @param newValue 新規の値
	 * @param oldValue 変更前の値
	 ------------------------------*/
	function onValueModified(newValue, oldValue) {
		indeterminate = false;
		if (isInWidgetTree)
			parentWidget.onChildValueModified(this, newValue, oldValue);
	}

	/**------------------------------
	 * 子ウィジェットの「値」が変わった時に呼ばれるフック関数
	 *
	 * 子ウィジェットの「値」値が変更された時に呼ばれます。
	 * デフォルトでは、さらに parent の onChildValueModifiedを呼ぶように設定されています。
	 * どこかのウィジェットが関数をオーバーライドして処理を行わない限り、
	 * 値変更の通知は KWindow まで届きます。
	 *
	 * @param newValue 新規の値
	 * @param oldValue 変更前の値
	 ------------------------------*/
	function onChildValueModified(child, newValue, oldValue) {
		if (isInWidgetTree)
			parentWidget.onChildValueModified(...);
	}

	/*------------------------------
	 * UIテキストを書く
	 ------------------------------*/
	function drawUIText(fontStyle, x, y, text, overrideFontColor = void) {
		var fontColor = overrideFontColor !== void ? overrideFontColor : fontStyle.fontColor;
		var opacity = appearanceStyle.opacity;
		if ((fontColor & 0xff000000) != 0) {
			opacity = opacity * (fontColor >> 24) / 255;
			fontColor &= 0xff000000;
		}
		applyFontStyle(font, fontStyle);
		if (! fontStyle.fontOutline)
			drawText(x, y, text, fontColor, opacity, fontStyle.fontAntiAlias);
		else
			drawText(x, y, text, fontColor, opacity, fontStyle.fontAntiAlias, 2048, fontStyle.fontOutlineColor, 2.5);
	}

	//------------------------------
	// 指定範囲に収まるようにテキストを描画する（はみ出る分は省略）
	//------------------------------
	function getTextOmitLength() {
		var omitTextWidth = font.getTextWidth(omitText);
		return omitTextWidth;
	}

	function drawUITextInRange(fontStyle, x, y, w, text, alignment, fill = false, textWidth = void, textOmitLength = void, overrideFontColor = void) {
		if (w <= 0)
			return %[ inRange: false, x: x, y: y, width: w ];
		var omitTextWidth = textOmitLength !== void ? textOmitLength : font.getTextWidth(omitText);
		var len = table_find_text_range(font, text, w, omitTextWidth);
		if (len === void) {
			var tw = textWidth !== void ? textWidth : font.getTextWidth(text);
			switch (alignment) {
			case ALIGN_LEFT: break;
			case ALIGN_CENTER: x += (w - tw) / 2; break;
			case ALIGN_RIGHT:  x += w - tw; break;
			}
			if (fill) {
				if (fill instanceof "Function")
					fill(x, y, tw, font.height, borderStyle.backgroundColor);
				else
					fillRect(x, y, tw, font.height, borderStyle.backgroundColor);
			}
			drawUIText(fontStyle, x, y, text, overrideFontColor);
			return %[ inRange: true, x: x, y: y, w: tw ];
		} else {
			if (fill) {
				if (fill instanceof "Function")
					fill(x, y, w, font.height, borderStyle.backgroundColor);
				else
					fillRect(x, y, w, font.height, borderStyle.backgroundColor);
			}
			drawUIText(fontStyle, x, y, text.substr(0, len) + omitText, overrideFontColor);
			return %[ inRange: false, x: x, y: y, w: w ];
		}
	}

	function getUITextInRange(fontStyle, w, text) {
		if (w <= 0)
			return %[ inRange: false, text: text ];
		applyFontStyle(font, fontStyle);
		var omitTextWidth = font.getTextWidth(omitText);
		var len = table_find_text_range(font, text, w, omitTextWidth);
		if (len === void) {
			return %[ inRange: true, text: text ];
		} else {
			return %[ inRange: false, text: text.substr(0, len) + omitText ];
		}
	}

	/*------------------------------
	 * テキストエリアを展開する
	 ------------------------------*/
	function extractTextArea(fontStyle, text, lineSpacing) {
		var texts = text.split(/\r\n|\r|\n/);
		var textWidths = [];
		var textAreaWidth = 0, textAreaHeight = 0;
		applyFontStyle(font, fontStyle);

		for(var i = 0; i < texts.count; i++) {
			var textWidth = font.getTextWidth(texts[i]);
			textWidths.add(textWidth);
			textAreaWidth = Math.max(textAreaWidth, textWidth);
		}

		textAreaHeight = texts.count * fontStyle.fontHeight + (texts.count - 1) * lineSpacing;

		var result = %[
			texts: texts,
			textWidths: textWidths,
			width: textAreaWidth,
			height: textAreaHeight
		];

		return result;
	}

	/*------------------------------
	 * テキストエリアを描画する
	 ------------------------------*/
	function drawTextArea(fontStyle, x, y, w, lineSpacing, texts, textWidths, textAlign) {
		applyFontStyle(font, fontStyle);
		var textOmitLength = getTextOmitLength();
		var inRange = true;
		for (var i = 0; i < texts.count; i++) {
			var drawResult = drawUITextInRange(fontStyle, x, y, w, texts[i], textAlign, false, textWidths[i], textOmitLength);
			if (! drawResult.inRange)
				inRange = false;
			y += fontStyle.fontHeight + lineSpacing;
		}
		return %[ inRange: inRange ];
	}

	/*------------------------------
	 * ボーダーを書く
	 ------------------------------*/
	var borderPenLayer;
	var borderCornerLayers = [];

	function darkenColor(color) {
		var r = (color >> 16) & 0xff, g = (color >> 8) & 0xff, b = color & 0xff;
		var hsv = global.Layer.RGB2HSV(r, g, b);
		hsv.v  = Math.max(0, hsv.v - 25);
		var rgb = global.Layer.HSV2RGB(hsv.h, hsv.s, hsv.v);
		return (rgb.r << 16) | (rgb.g << 8) | rgb.b;
	}

	function generateBorderPen(penLayer, dir, style, width, color, bgColor) {
		var lt = (dir == "left" || dir == "top");

		if (style == BORDER_STYLE_DASHED) {
			if (dir == "top" || dir == "bottom") {
				penLayer.setSize(width * 3, width);
				penLayer.fillRect(0, 0, width * 3, width, bgColor | 0xff000000);
				penLayer.fillRect(0, 0, width * 2, width, color | 0xff000000);
			} else {
				penLayer.setSize(width, width * 3);
				penLayer.fillRect(0, 0, width, width * 3, bgColor | 0xff000000);
				penLayer.fillRect(0, 0, width, width * 2, color | 0xff000000);
			}
			return;
		}

		width *= 6;
		penLayer.setSize(width, 2);

		switch (style) {
		case BORDER_STYLE_NONE:
			penLayer.fillRect(0, 0, width, 1, bgColor | 0xff000000);
			break;
		case BORDER_STYLE_SOLID: {
			penLayer.fillRect(0, 0, width, 1, color | 0xff000000);
			break;
		}
		case BORDER_STYLE_DOUBLE: {
			var m1 = int(width / 3);
			var m2 = int(width * 2 / 3);
			penLayer.fillRect(0, 0, width, 1, color | 0xff000000);
			penLayer.fillRect(m1, 0, m2 - m1, 1, bgColor | 0xff000000);
			break;
		}
		case BORDER_STYLE_GROOVE: {
			var m =  int(width / 2);
			penLayer.fillRect(0, 0, m, 1, darkenColor(color) | 0xff000000);
			penLayer.fillRect(m, 0, width - m, 1, color | 0xff000000);
			break;
		}
		case BORDER_STYLE_RIDGE: {
			var m =  int(width / 2);
			penLayer.fillRect(0, 0, m, 1, color | 0xff000000);
			penLayer.fillRect(m, 0, width - m, 1, darkenColor(color) | 0xff000000);
			break;
		}
		case BORDER_STYLE_INSET: {
			penLayer.fillRect(0, 0, width, 1, (lt ? darkenColor(color) : color) | 0xff000000);
			break;
		}
		case BORDER_STYLE_OUTSET: {
			penLayer.fillRect(0, 0, width, 1, (lt ? color : darkenColor(color)) | 0xff000000);
			break;
		}
		}

		width /= 3;
		penLayer.stretchCopy(0, 1, width, 1, penLayer, 0, 0, width * 3, 1, stFastLinear);
		penLayer.copyRect(0, 0, penLayer, 0, 1, width, 1);
		width /= 2;
		penLayer.stretchCopy(0, 1, width, 1, penLayer, 0, 0, width * 2, 1, stFastLinear);
		penLayer.copyRect(0, 0, penLayer, 0, 1, width, 1);
		penLayer.setSize(width, 1);

		if (dir == "top" || dir == "bottom") {
			penLayer.setSize(width, width);
			penLayer.affineCopy(penLayer, 0, 0, width, 1,
								true, 0, 1, -1, 0, 0, 0);
			penLayer.setSize(1, width);
		}
	}

	function drawBorderEdge(borderStyle, dir, x, y, w, h) {
		var camelDir = dir[0].toUpperCase() + dir.substr(1);

		var width = borderStyle[ "borderWidth" + camelDir ];
		if (width == 0)
			return;

		var color = borderStyle[ "borderColor" + camelDir ];
		var style = borderStyle[ "borderStyle" + camelDir ];
		var bgColor = borderStyle.backgroundColor;

		generateBorderPen(borderPenLayer, dir, style, width, color, bgColor);

		switch (dir) {
		case "left":
		case "right": {
			var wt = Math.max(0, borderStyle.borderWidthTop - 1);
			var wb = Math.max(0, borderStyle.borderWidthBottom, -1);

			for (var i = 0; i < w; i++) {
				var ra = i / (w == 1 ? 1 : (w - 1));
				var t = y + int(ra * wt);
				var b = y + h - int(ra * wb);
				var _x = dir == "left" ? (x + i) : (x + w - i - 1);
				var _y = t;
				var _h = b - t;
				blendWrappedRect(_x, _y, 1, _h, borderPenLayer, 0, 0, borderPenLayer.width, borderPenLayer.height, -x, -y, appearanceStyle.opacity);
			}
			break;
		}
		case "top":
		case "bottom": {
			var wl = Math.max(0, borderStyle.borderWidthLeft - 1);
			var wr = Math.max(0, borderStyle.borderWidthRight - 1);

			for (var i = 0; i < h; i++) {
				var ra = i / (h == 1 ? 1 : (h - 1));
				var l = x + int(ra * wl);
				var r = x + w - int(ra * wr);
				var _x = l;
				var _y = dir == "top" ? (y + i) : (y + h - i - 1);
				var _w = r - l;
				blendWrappedRect(_x, _y, _w, 1, borderPenLayer, 0, 0, borderPenLayer.width, borderPenLayer.height, -x, -y, appearanceStyle.opacity);
			}
			break;
		}
		}
	}

	function hasDrawableBorder(borderStyle) {
		return borderStyle.borderWidthLeft != 0
			|| borderStyle.borderWidthRight != 0
			|| borderStyle.borderWidthTop != 0
			|| borderStyle.borderWidthBottom != 0;
	}

	function hasBorderRoundCorner(borderStyle) {
		return borderStyle.borderRadiusLeftTop
			|| borderStyle.borderRadiusRightTop
			|| borderStyle.borderRadiusLeftBottom
			|| borderStyle.borderRadiusRightBottom;
	}

	function storeABorderCornerOne(index, l, t, r) {
		if (r == 0)
			return;
		if (borderCornerLayers[index] === void)
			borderCornerLayers[index] = new global.Layer(window, this);
		var bufLayer = borderCornerLayers[index];
		bufLayer.setSize(r, r);
		bufLayer.copyRect(0, 0, this, l, t, r, r);
	}

	function storeBorderCorner(borderStyle, x, y, w, h) {
		storeABorderCornerOne(0, x, y, borderStyle.borderRadiusLeftTop);
		storeABorderCornerOne(1, x + w - borderStyle.borderRadiusRightTop, y, borderStyle.borderRadiusRightTop);
		storeABorderCornerOne(2, x, y + h - borderStyle.borderRadiusLeftBottom, borderStyle.borderRadiusLeftBottom);
		storeABorderCornerOne(3, x + w - borderStyle.borderRadiusRightBottom, y + h - borderStyle.borderRadiusRightBottom, borderStyle.borderRadiusRightBottom);
	}

	function restoreABorderCornerOne(index, l, t, r) {
		if (r == 0)
			return;
		var bufLayer = borderCornerLayers[index];
		bufLayer.operateRect(0, 0, this, l, t, r, r, omAuto, appearanceStyle.opacity);
		copyRect(l, t, bufLayer, 0, 0, r, r);
	}

	function restoreBorderCorner(borderStyle, x, y, w, h) {
		restoreABorderCornerOne(0, x, y, borderStyle.borderRadiusLeftTop);
		restoreABorderCornerOne(1, x + w - borderStyle.borderRadiusRightTop, y, borderStyle.borderRadiusRightTop);
		restoreABorderCornerOne(2, x, y + h - borderStyle.borderRadiusLeftBottom, borderStyle.borderRadiusLeftBottom);
		restoreABorderCornerOne(3, x + w - borderStyle.borderRadiusRightBottom, y + h - borderStyle.borderRadiusRightBottom, borderStyle.radiusRightBottom);
	}

	function drawBorder(borderStyle, x, y, w, h, clear = true) {
		if (borderPenLayer === void) {
			borderPenLayer = new global.Layer(window, this);
		}

		var blendCorner = (! clear) && hasBorderRoundCorner(borderStyle);

		if (blendCorner)
			storeBorderCorner(borderStyle, x, y, w, h);

		fillRect(x, y, w, h, borderStyle.backgroundColor);

		drawBorderEdge(borderStyle, "left", x, y, borderStyle.borderWidthLeft, h);
		drawBorderEdge(borderStyle, "top", x, y, w, borderStyle.borderWidthTop);
		drawBorderEdge(borderStyle, "right", x + w - borderStyle.borderWidthRight, y, borderStyle.borderWidthRight, h);
		drawBorderEdge(borderStyle, "bottom", x, y + h - borderStyle.borderWidthBottom, w, borderStyle.borderWidthBottom);

		if (borderStyle.borderRadiusLeftTop) {
			var r = Math.min(int(width / 2), Math.min(int(height / 2), borderStyle.borderRadiusLeftTop));
			roundRect(x, y,
					  r, r,
					  x + r - 1, y + r - 1);
		}
		if (borderStyle.borderRadiusRightTop) {
			var r = Math.min(int(width / 2), Math.min(int(height / 2), borderStyle.borderRadiusRightTop));
			roundRect(x + w - r, y,
					  r, r,
					  x + w - r, y + r - 1);
		}
		if (borderStyle.borderRadiusLeftBottom) {
			var r = Math.min(int(width / 2), Math.min(int(height / 2), borderStyle.borderRadiusLeftBottom));
			roundRect(x, y + h - r,
					  r, r,
					  x + r - 1, y + h - r);
		}
		if (borderStyle.borderRadiusRightBottom) {
			var r = Math.min(int(width / 2), Math.min(int(height / 2), borderStyle.borderRadiusRightBottom));
			roundRect(x + w - r, y + h - r,
					  r, r,
					  x + w - r, y + h - r);
		}

		if (blendCorner)
			restoreBorderCorner(borderStyle, x, y, w, h);
	}

	/*------------------------------
	 * へっこんだフレームを描く
	 *
	 * @param x フレームの左端
	 * @param y フレームの上端
	 * @param w フレームの幅
	 * @param h フレームの高さ
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function drawSunkenFrame(x, y, w, h, boxColor = WIN_BG) {
		fillRect(x + 0, y + 0, w - 1, 1, WIN_DARKEN1);
		fillRect(x + 0, y + 0, 1, h - 1, WIN_DARKEN1);
		fillRect(x + 1, y + 1, w - 3, 1, WIN_DARKEN2);
		fillRect(x + 1, y + 1, 1, h - 3, WIN_DARKEN2);
		fillRect(x + 0, y + h - 1, w, 1, WIN_LIGHTEN2);
		fillRect(x + w - 1, y + 0, 1, h, WIN_LIGHTEN2);
		fillRect(x + 1, y + h - 2, w - 2, 1, WIN_LIGHTEN1);
		fillRect(x + w - 2, y + 1, 1, h - 2, WIN_LIGHTEN1);
		fillRect(x + 2, y + 2, w - 4, h - 4, boxColor);
	}

	/*------------------------------
	 * へっこんだフレームでレイヤ全体を塗り潰す
	 *
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function fillSunkenFrame(boxColor = WIN_BG) {
		drawSunkenFrame(0, 0, width, height, boxColor);
	}

	/*------------------------------
	 * 出っぱったフレームを描く
	 *
	 * @param x フレームの左端
	 * @param y フレームの上端
	 * @param w フレームの幅
	 * @param h フレームの高さ
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function drawRaisedFrame(x, y, w, h, boxColor = WIN_BG) {
		fillRect(x + 0, y + 0, w - 1, 1, WIN_LIGHTEN2);
		fillRect(x + 0, y + 0, 1, h - 1, WIN_LIGHTEN2);
		fillRect(x + 1, y + 1, w - 3, 1, WIN_LIGHTEN1);
		fillRect(x + 1, y + 1, 1, h - 3, WIN_LIGHTEN1);
		fillRect(x + 0, y + h - 1, w, 1, WIN_DARKEN2);
		fillRect(x + w - 1, y + 0, 1, h, WIN_DARKEN2);
		fillRect(x + 1, y + h - 2, w - 2, 1, WIN_DARKEN1);
		fillRect(x + w - 2, y + 1, 1, h - 2, WIN_DARKEN1);
		fillRect(x + 2, y + 2, w - 4, h - 4, boxColor);
	}

	/*------------------------------
	 * 出っぱったフレームでレイヤ全体を塗り潰す
	 *
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function fillRaisedFrame(boxColor = WIN_BG) {
		drawRaisedFrame(0, 0, width, height, boxColor);
	}

	/*------------------------------
	 * 平坦なフレームを描く
	 *
	 * @param x フレームの左端
	 * @param y フレームの上端
	 * @param w フレームの幅
	 * @param h フレームの高さ
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function drawFlattenFrame(x, y, w, h, boxColor = WIN_BG) {
		fillRect(x, y, 1, h, WIN_DARKEN1);
		fillRect(x, y, w, 1, WIN_DARKEN1);
		fillRect(x + w - 1, y, 1, h, WIN_DARKEN1);
		fillRect(x, y + h - 1, w, 1, WIN_DARKEN1);
		fillRect(x + 1, y + 1, w - 2, h - 2, boxColor);
	}

	/*------------------------------
	 * 平坦なフレームでレイヤ全体を塗り潰す
	 *
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function fillFlattenFrame(boxColor = WIN_BG) {
		drawFlattenFrame(0, 0, width, height, boxColor);
	}

	/*------------------------------
	 * フレームを描く
	 *
	 * @param type タイプ
	 * @param x フレームの左端
	 * @param y フレームの上端
	 * @param w フレームの幅
	 * @param h フレームの高さ
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function drawFrame(type, x, y, w, h, boxColor = WIN_BG) {
		switch (type) {
		case FRAME_FLATTEN:
			drawFlattenFrame(x, y, w, h, boxColor);
			break;
		case FRAME_SUNKEN:
			drawSunkenFrame(x, y, w, h, boxColor);
			break;
		case FRAME_RAISED:
			drawRaisedFrame(x, y, w, h, boxColor);
			break;
		}
	}

	/*------------------------------
	 * フレームでレイヤ全体を塗り潰す
	 *
	 * @param type タイプ
	 * @param boxColor 塗り潰すフレームの地の色
	 ------------------------------*/
	function fillFrame(type, boxColor = WIN_BG) {
		switch (type) {
		case FRAME_FLATTEN:
			fillFlattenFrame(boxColor);
			break;
		case FRAME_SUNKEN:
			fillSunkenFrame(boxColor);
			break;
		case FRAME_RAISED:
			fillRaisedFrame(boxColor);
			break;
		}
	}

	/*------------------------------
	 * チェッカー模様を描く
	 *
	 * @param l チェッカーの左端
	 * @param t チェッカーの上端
	 * @param w チェッカーの幅
	 * @param h チェッカーの高さ
	 * @param csize チェッカーサイズ
	 * @param color1 カラー1
	 * @param color2 カラー2
	 * @param sx シフトX
	 * @param sy シフトY
	 ------------------------------*/
	function drawChecker(l, t, w, h, csize, color1 = 0xFFFFFFFF, color2 = 0xFFC0C0C0, sx = 0, sy = 0) {
		var srcLayer = new global.Layer(window, this);
		srcLayer.setSize(csize * 2, csize * 2);
		srcLayer.fillRect(0, 0, csize, csize, color1);
		srcLayer.fillRect(csize, 0, csize, csize, color2);
		srcLayer.fillRect(0, csize, csize, csize, color2);
		srcLayer.fillRect(csize, csize, csize, csize, color1);
		copyWrappedRect(l, t, w, h,
						srcLayer, 0, 0, csize * 2, csize * 2,
						sx, sy);
		invalidate srcLayer;
	}

	/*------------------------------
	 * チェッカー模様で全体を塗り潰す
	 *
	 * @param csize チェッカーサイズ
	 * @param color1 カラー1
	 * @param color2 カラー2

	 ------------------------------*/
	function fillChecker(csize, color1 = 0xFFFFFFFF, color2 = 0xFFC0C0C0) {
		drawChecker(0, 0, width, height, csize, color1, color2);
	}

	/*------------------------------
	 * ウィジェットを配置する
	 ------------------------------*/
	function locateChild(x, y, w, h, child) {
		switch (child.alignHorizontal) {
		case ALIGN_LEFT:
			child.left = x + child.marginLeft;
			break;

		case ALIGN_CENTER:
			child.left = int(x + (w - child.marginIncludeWidth) / 2 + child.marginLeft);
			break;

		case ALIGN_RIGHT:
			child.left = int(x + (w - child.width - child.marginRight));
			break;
		}

		switch (child.alignVertical) {
		case ALIGN_TOP:
			child.top = int(y) + child.marginTop;
			break;

		case ALIGN_CENTER:
			child.top = int(y + (h - child.marginIncludeHeight) / 2 + child.marginTop);
			break;

		case ALIGN_BOTTOM:
			child.top = int(y + (h - child.height - child.marginBottom));
			break;
		}
	}

	function getChildBounds(child) {
		var mh = child.marginHorizontal;
		var mv = child.marginVertical;
		var bpw = borderPaddingWidth;
		var bph = borderPaddingHeight;
		return %[ minWidth: child.minWidth + mh + bpw,
				  maxWidth: Math.min(K_UNLIMITED_SIZE, child.maxWidth + mh + bpw),
				  minHeight: child.minHeight + mv + bph,
				  maxHeight: Math.min(K_UNLIMITED_SIZE, child.maxHeight + mv + bph) ];
	}

	function embedChild(x, y, w, h, child, clear = false) {
		drawBorder(borderStyle, x, y, w, h, clear);
		var cw = w - borderPaddingWidth;
		var ch = h - borderPaddingHeight;
		child.setSize(cw - child.marginHorizontal, ch - child.marginVertical);
		locateChild(x + borderPaddingLeft, y + borderPaddingTop, cw, ch, child);
	}

	function getChildBoundsWithoutPadding(child) {
		var mh = child.marginHorizontal;
		var mv = child.marginVertical;
		var bpw = layoutStyle.borderLeft + layoutStyle.borderRight;
		var bph = layoutStyle.borderTop + layoutStyle.borderBottom;
		return %[ minWidth: child.minWidth + mh + bpw,
				  maxWidth: Math.min(K_UNLIMITED_SIZE, child.maxWidth + mh + bpw),
				  minHeight: child.minHeight + mv + bph,
				  maxHeight: Math.min(K_UNLIMITED_SIZE, child.maxHeight + mv + bph) ];
	}

	function embedChildWithoutPadding(x, y, w, h, child, clear = false) {
		drawBorder(borderStyle, x, y, w, h, clear);
		var bpw = layoutStyle.borderLeft + layoutStyle.borderRight;
		var bph = layoutStyle.borderTop + layoutStyle.borderBottom;
		var cw = w - bpw;
		var ch = h - bph;
		child.setSize(cw - child.marginHorizontal, ch - child.marginVertical);
		locateChild(x + layoutStyle.borderLeft, y + layoutStyle.borderTop, cw, ch, child);
	}

	function getChildBoundsWithoutBorderPadding(child) {
		var mh = child.marginHorizontal;
		var mv = child.marginVertical;
		var bpw = 0;
		var bph = 0;
		return %[ minWidth: child.minWidth + mh + bpw,
				  maxWidth: child.maxWidth + mh + bpw,
				  minHeight: child.minHeight + mv + bph,
				  maxHeight: child.maxHeight + mv + bph ];
	}

	function embedChildWithoutBorderPadding(x, y, w, h, child, clear = false) {
		var bpw = 0;
		var bph = 0;
		var cw = w - bpw;
		var ch = h - bph;
		child.setSize(cw - child.marginHorizontal, ch - child.marginVertical);
		locateChild(x + layoutStyle.borderLeft, y + layoutStyle.borderTop, cw, ch, child);
	}
	
		/*------------------------------
	 * 外部からファイルがドロップされた
	 *
	 * デフォルト動作では、親のonFileDropを呼ぶ。
	 * 順ぐりに、子から親へメッセージがチェーンされ、
	 * どこかのウィジェットが関数をオーバーライドして
	 * 処理を行うまでチェーンが続く
	 *
	 * @param x ファイルがドロップされた時のマウスのX座標
	 * @param y ファイルがドロップされた時のマウスのY座標
	 * @param files ドロップされたファイル名が格納された配列(Array)オブジェクトです。
	 * @param shift キーが押された時に同時に押されていたシフト系のキーの状態です。
	 ------------------------------*/
	function onFileDrop(x, y, files, shift) {
		if (parent)
			parent.onFileDrop(x + left,
							  y + top,
							  files,
							  shift);
	}

	/*------------------------------
	 * マウスホイールイベント
	 *
	 * 自分自身でホイールをトラップしない時は、
	 * ホイールイベントは親へ通知される
	 ------------------------------*/
	function onMouseWheel(shift, delta, x, y) {
		if (parent)
			parent.onMouseWheel(shift, delta, x + left, y + top);
	}

	function onHoverMouseWheel(shift, delta, x, y) {
		if (parent)
			parent.onHoverMouseWheel(shift, delta, x + left, y + top);
	}

	/*------------------------------
	 * マウス関連イベント。
	 *
	 * Ｄ＆Ｄ関連の制御を行う
	 ------------------------------*/
	function onMouseDown(x, y, button, shift) {
		_pressing = true;
		updateStyleStates();
		invalidateStyles();
		// 左クリックでドラッグ準備開始
		if (button == mbLeft
			&& (! dragEnabledShiftMask || (shift & dragEnabledShiftMask))) {
			// ドラッグ中にウィジェットがスクロールする事を考慮して
			// 基準座標はprimaryLayerから取得する
			mouseDownX = window.primaryLayer.cursorX;
			mouseDownY = window.primaryLayer.cursorY;
			dragStartX = x;
			dragStartY = y;
			// ドラッグ準備開始
			isReadyToDrag = true;
		} else if (button == mbRight
				   && ! isDragging) {
			// 右クリックなら onRightClick を呼ぶ
			onRightClick(x, y, shift);
		} else if (button == mbMiddle) {
			var target = findMiddleButtonDragTarget();
			if (target !== void)
				startMiddleButtonDrag(target);
		}
	}

	function onMouseMove(x, y, shift) {
		// 中ボタンドラッグ
		if (_middleButtonDragging)
			progressMiddleButonDrag();
		// ドラッグ中なら onDragMove を呼び出す
		if (isDragging) {
			onDragMove(x, y, shift);
		}
		// ドラッグ準備が出来ており、4ドット以上マウスが動いたら
		// ドラッグ開始
		if (isReadyToDrag) {
			if (Math.abs(window.primaryLayer.cursorX - mouseDownX) > mouseDragThreshold
				|| Math.abs(window.primaryLayer.cursorY - mouseDownY) > mouseDragThreshold) {
				isReadyToDrag = false;
				isDragging = true;
				updateStyleStates();
				invalidateStyles();
				// ウィジェットローカルのドラッグ開始を通知
				onDragEnter(dragStartX,
							dragStartY,
							shift);
			}
		}
		// パケットのドラッグ中の処理
		if (myDraggingPacket) {
			// アクティブなウィンドウより、ターゲットウィジェットを特定
			var dragTarget = void;
			for (var i = 0;
				 i < _existentWindowList.count;
				 i++) {
				var targetWindow = _existentWindowList[i];
				if (! targetWindow.visible)
					continue;
				dragTarget = targetWindow.primaryLayer.getWidgetAt(targetWindow.primaryLayer.cursorX,
																   targetWindow.primaryLayer.cursorY);
				if (dragTarget)
					break;
			}

			// ターゲットウィジェットが継続していたら
			// onPacketMoveを通知
			if (dragTarget == curDragTarget) {
				if (curDragTargetAcceptPacket)
					curDragTarget.onPacketMove
				(curDragTarget.cursorX,
				 curDragTarget.cursorY,
				 _dragging_packet_,
				 shift);
			} else {
				// ターゲットウィジェットが変更された時の処理
				if (curDragTargetAcceptPacket) {
					// 直前のターゲットに onPacketLeave を通知
					curDragTarget.dragHover = false;
					curDragTarget.updateStyleStates();
					curDragTarget.invalidateStyles();
					curDragTarget.onPacketLeave
					(curDragTarget.cursorX,
					 curDragTarget.cursorY,
					 _dragging_packet_,
					 shift);
				}
				curDragTarget = dragTarget;
				// 新規ターゲットがパケットを受け入れるなら
				// onPacketEnterを通知
				if (curDragTarget !== void
					&& curDragTarget.isPacketAcceptable(_dragging_packet_)) {
					curDragTargetAcceptPacket = true;
					curDragTarget.dragHover = true;
					curDragTarget.updateStyleStates();
					curDragTarget.invalidateStyles();
					curDragTarget.onPacketEnter
					(curDragTarget.cursorX,
					 curDragTarget.cursorY,
					 _dragging_packet_,
					 shift);
				} else {
					curDragTargetAcceptPacket = false;
				}
			}
		}
	}

	function onMouseUp(x, y, button, shift) {
		_pressing = false;
		updateStyleStates();
		invalidateStyles();
		// 中ボタンドラッグ
		if (_middleButtonDragging)
			stopMiddleButtonDrag();
		if (button == mbLeft) {
			// ドラッグ中であれば、ドラッグの終了を通知
			if (isDragging) {
				onDragLeave(x, y, shift);
			}

			isReadyToDrag = isDragging = false;
			updateStyleStates();
			invalidateStyles();

			// パケットのドラッグ中であれば
			// ターゲットにパケットのドロップを通知
			if (myDraggingPacket) {
				if (curDragTargetAcceptPacket
					&& curDragTarget.isPacketConfirmed(curDragTarget.cursorX,
													   curDragTarget.cursorY,
													   _dragging_packet_,
													   shift)) {
					curDragTarget.dragHover = false;
					curDragTarget.updateStyleStates();
					curDragTarget.invalidateStyles();
					curDragTarget.onPacketLeave(curDragTarget.cursorX,
												curDragTarget.cursorY,
												_dragging_packet_,
												shift);
					curDragTarget.onPacketDrop(curDragTarget.cursorX,
											   curDragTarget.cursorY,
											   _dragging_packet_,
											   shift);
				} else {
					curDragTarget.dragHover = false;
					curDragTarget.updateStyleStates();
					curDragTarget.invalidateStyles();
					onPacketCancel(_dragging_packet_);
				}
				curDragTarget = void;
				curDragTargetAcceptPacket = false;
				myDraggingPacket = false;
				_dragging_packet_ = void;
				cursor = cursorOrig;
			}
		}
	}

	function onMouseEnter {
		// ホバーオン
		hover = true;
		updateStyleStates();
		invalidateStyles();
		updateAncestorsStates();
		// ステータスバーにステータスを設定
		var s = status;
		_inStatus = true;
		if (window.statusBar !== void) {
			window.statusBar.label = s;
		}
	}

	function onMouseLeave {
		// ホバーオフ
		hover = false;
		updateStyleStates();
		invalidateStyles();
		updateAncestorsStates();
		// ステータスバーのステータスをクリア
		if (_inStatus) {
			_inStatus = false;
			if (window.statusBar !== void)
				window.statusBar.label = "";
		}
	}

	/*------------------------------
	 * ミドルボタンドラッグ
	 ------------------------------*/
	var _middleButtonDrag = false;
	var _middleButtonDragTarget = void;
	var _middleButtonDragging = false;
	var _middleButtonDragBaseX = 0;
	var _middleButtonDragBaseY = 0;
	var _middleButtonDragInterp;
	var _middleButtonDragNextTarget;

	function findMiddleButtonDragTarget() {
		for (var widget = this;
			 widget instanceof "KWidget";
			 widget = widget.parent) {
			if (widget._middleButtonDrag)
				return widget;
		}
		return void;
	}

	function startMiddleButtonDrag(target) {
		_middleButtonDragging = true;
		_middleButtonDragTarget = target;
		_middleButtonDragBaseX = window.primaryWidget.cursorX;
		_middleButtonDragBaseY = window.primaryWidget.cursorY;
		if (_middleButtonDragInterp === void)
			_middleButtonDragInterp =
			new KInterpolateDispatcher(this,
									   %[ valueName: "middleButtonDragTargetValue",
										  dispatchName: "dispatchMiddleButtonDrag",
										  lerpFunction: function(a, b, t)
										  { return %[ left: a.left + (b.left - a.left) * t,
													  top: a.top + (b.top - a.top) * t ]; } ]);
	}

	function progressMiddleButonDrag() {
		var ofstx = -(window.primaryWidget.cursorX - _middleButtonDragBaseX);
		var ofsty = -(window.primaryWidget.cursorY - _middleButtonDragBaseY);
		_middleButtonDragBaseX = window.primaryWidget.cursorX;
		_middleButtonDragBaseY = window.primaryWidget.cursorY;
		var completedValue = _middleButtonDragInterp.completedValue;
		_middleButtonDragInterp.interpolate(%[ left: completedValue.left + ofstx,
											   top: completedValue.top + ofsty ]);
	}

	function stopMiddleButtonDrag() {
		_middleButtonDragging = false;
	}

	property middleButtonDragTargetValue {
		getter {
			var rect = _middleButtonDragTarget.viewingRect;
			return %[ left: rect.left, top: rect.top ];
		}
		setter(v) {
			_middleButtonDragNextTarget = v;
		}
	}

	function dispatchMiddleButtonDrag() {
		var rect = _middleButtonDragTarget.viewingRect;
		_middleButtonDragTarget.noticeRect(_middleButtonDragNextTarget.left,
										   _middleButtonDragNextTarget.top,
										   rect.width,
										   rect.height);
	}

	/**------------------------------
	 * マウスが右クリックされた時に呼ばれる
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param shift シフトキー
	 ------------------------------*/
	function onRightClick(x, y, shift) {
	}

	/**------------------------------
	 * ウィジェット内でのドラッグの開始の通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param shift シフトキー
	 ------------------------------*/
	function onDragEnter(x, y, shift) {
	}

	/**------------------------------
	 * ウィジェット内でのドラッグ中のマウス移動の通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param shift シフトキー
	 ------------------------------*/
	function onDragMove(x, y, shift) {
	}

	/**------------------------------
	 * ウィジェット内でのドラッグの終了の通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param shift シフトキー
	 ------------------------------*/
	function onDragLeave(x, y, shift) {
	}

	/**------------------------------
	 * パケットのドラッグ開始
	 *
	 * 他のウィジェットへのパケットのドラッグを開始する
	 *
	 * @param packet パケット
	 ------------------------------*/
	function beginDragPacket(packet) {
		_dragging_packet_ = packet;
		myDraggingPacket = true;
		cursorOrig = cursor;
		cursor = crDrag;
		curDragTarget = void;
	}

	/**------------------------------
	 * 自分自身が特定のパケットを受け入れられるかどうか判定する
	 *
	 * @param packet ドラッグ中のパケット
	 * @return パケットを受け入れ可能かどうか
	 ------------------------------*/
	function isPacketAcceptable(packet) {
		return false;
	}

	/**------------------------------
	 * 最終的にパケットを受け入れるかどうか判定する
	 *
	 * @param packet ドラッグ中のパケット
	 * @return パケットを受け入れるかどうか
	 ------------------------------*/
	function isPacketConfirmed(x, y, packet, shift) {
		return true;
	}

	/**------------------------------
	 * パケットの侵入を通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param packet パケット
	 * @param shift シフト
	 ------------------------------*/
	function onPacketEnter(x, y, packet, shift) {
	}

	/**------------------------------
	 * パケットの移動を通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param packet パケット
	 * @param shift シフト
	 ------------------------------*/
	function onPacketMove(x, y, packet, shift) {
	}

	/**------------------------------
	 * パケットの離脱を通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param packet パケット
	 * @param shift シフト
	 ------------------------------*/
	function onPacketLeave(x, y, packet, shift) {
	}

	/**------------------------------
	 * パケットのドロップを通知
	 *
	 * @param x X座標
	 * @param y Y座標
	 * @param packet パケット
	 * @param shift シフト
	 ------------------------------*/
	function onPacketDrop(x, y, packet, shift) {
	}

	/*------------------------------
	 * パケットがドロップされなかった事を通知
	 *
	 * @packet パケット
	 ------------------------------*/
	function onPacketCancel(packet) {
	}

	/**------------------------------
	 * 視野に注目する
	 *
	 * ウィジェットの全体像を表示しないレイアウトにおいて、
	 * 子ウィジェットの任意の範囲を表示させるために呼び出す。
	 * ただちに parent の onChildNoticeRect が呼び出される。
	 *
	 * @param l 矩形左上X座標
	 * @param t 矩形左上Y座標
	 * @param w 矩形幅
	 * @param h 矩形高さ
	 n   ------------------------------*/
	function noticeRect(l, t, w, h) {
		if (isInWidgetTree
			&& parentWidget.isAttachedToWindow)
			parentWidget.onChildNoticeRect(this, l, t, w, h);
	}

	/**------------------------------
	 * 子ウィジェットの視野に注目するよう通知
	 *
	 * @child 子ウィジェット
	 * @param l 矩形左上X座標
	 * @param t 矩形左上Y座標
	 * @param w 矩形幅
	 * @param h 矩形高さ
	 ------------------------------*/
	function onChildNoticeRect(child, l, t, w, h) {
		if (isInWidgetTree
			&& ! isPrimary
			&& parentWidget.isAttachedToWindow)
			parentWidget.onChildNoticeRect(child, child.left + l, child.top + t, w, h);
	}

	/**------------------------------
	 * ウィジェットの視矩形
	 *
	 * @return 視矩形
	 ------------------------------*/
	property viewingRect {
		getter {
			var rect = %[ left:0, top:0, right:width, bottom:height ];
			var diffX, diffY;
			var layer;
			diffX = diffY = 0;
			for (layer = this; layer.parent; layer = layer.parent) {
				rect.left = Math.max(rect.left, 0);
				rect.top = Math.max(rect.top, 0);
				rect.right = Math.min(rect.right, layer.width);
				rect.bottom = Math.min(rect.bottom, layer.height);
				rect.left += layer.left;
				rect.top += layer.top;
				rect.right += layer.left;
				rect.bottom += layer.top;
				diffX += layer.left;
				diffY += layer.top;
			}
			rect.left -= diffX;
			rect.top -= diffY;
			rect.right -= diffX;
			rect.bottom -= diffY;
			rect.width = rect.right - rect.left;
			rect.height = rect.bottom - rect.top;
			return rect;
		}
	}

	/**------------------------------
	 * ウィジェットの視矩形(ウィンドウ座標系)
	 *
	 * @return 視矩形
	 ------------------------------*/
	property globalViewingRect {
		getter {
			var rect = %[ left:0, top:0, right:width, bottom:height ];
			var layer;
			for (layer = this; layer.parent; layer = layer.parent) {
				rect.left = Math.max(rect.left, 0);
				rect.top = Math.max(rect.top, 0);
				rect.right = Math.min(rect.right, layer.width);
				rect.bottom = Math.min(rect.bottom, layer.height);
				rect.left += layer.left;
				rect.top += layer.top;
				rect.right += layer.left;
				rect.bottom += layer.top;
			}
			rect.width = rect.right - rect.left;
			rect.height = rect.bottom - rect.top;
			return rect;
		}
	}

	/**------------------------------
	 * 視矩形が更新された時に呼ばれるコールバック
	 *
	 * @param vleft 矩形左端
	 * @param vtop 矩形右端
	 * @param vwidth 矩形幅
	 * @param vheight 矩形高さ
	 *
	 * 視矩形が更新されたタイミングで呼ばれるコールバック関数。
	 * 常に呼び出されるわけではなく、特定のWidgetの子として登録
	 * している時にのみ呼び出される。
	 *
	 * このコールバックを発生させるWidgetの一覧は以下の通り
	 * - KScrollLayout
	 * - KRelativeLayout
	 ------------------------------*/
	function onViewModified(vleft, vtop, vwidth, vheight) {
		for (var i = 0; i < children.count; i++) {
			var child = children[i];
			if (child instanceof "KWidget") {
				var rect = %[ left: vleft, top: vtop, right :vleft + vwidth, bottom: vtop + vheight ];
				rect.left = Math.max(rect.left, child.left);
				rect.top = Math.max(rect.top, child.top);
				rect.right = Math.min(rect.right, child.left + child.width);
				rect.bottom = Math.min(rect.bottom, child.top + child.height);
				child.onViewModified(rect.left - child.left, rect.top - child.top, rect.right - rect.left, rect.bottom - rect.top);
			}
		}
	}

	function onWindowActivate {
	}

	function onWindowDeactivate {
	}
};

mixin(KWidget, KStyleObject);


/**----------------------------------------------------------------------
 * 値持ちウィジェット
 ----------------------------------------------------------------------*/
class KValueWidget extends KWidget
{
	// 辞書
	var dict;

	/*------------------------------
	 * コンストラクタ
	 *
	 * プロパティ「value」を持つウィジェットの総称です。
	 * bindPersistentDictionary() を呼んでプロパティと
	 * バインドすることで、valueの値を永続化することが出来ます。
	 *
	 * @param win ウィンドウ
	 * @param name 名前。ユニークな名前を指定しないと永続化は行なわれません。
	 ------------------------------*/
	function KValueWidget(win, name) {
		super.KWidget(win, name);
	}

	/*------------------------------
	 * ファイナライザ
	 ------------------------------*/
	function finalize {
		if (dict) {
			dict.set(name, value);
		}
		super.finalize(...);
	}

	/**------------------------------
	 * イベントを発生させ強制的に現在の値を通知する。
	 *
	 * 現在の値で onValueModifiedを呼びます。
	 ------------------------------*/
	function invalidateValue {
		if (nodeEnabled)
			onValueModified(value);
	}

	/*------------------------------
	 * 永続化辞書を値にバインドする
	 ------------------------------*/
	function bindPersistentDictionary(dict) {
		if (_isAvoidDictionaryRegistration)
			return;

		if (name !== void) {
			this.dict = dict;
			value = dict.init(name, value);
		}
	}
}
